import "C:/Documents and Settings/Dirk Zimmer/My Documents/Modelica/BondLib2_1/BondLib.mo";


package MultiBondLib "Modelica library for modelling using MultiBond Graphs"
  package UsersGuide "User's Guide"
    annotation (DocumentationClass=true,Documentation(info="<html>
<h3><font color=\"#008000\" size=5>Users Guide of package MultiBondLib</font></h3>
<p>
Library <b>MultiBondLib</b> is a <b>free</b> Modelica package providing components to model multi-energy physical systems by the usage of multibond graphs.
These multibondgraphic components offer a general modeling approach for various physical domains.
Additionaly, the MultiBondLib offers three subpackages that contain domain specific solutions for the modeling of mechanical systems.
<p>
This package contains the <b>users guide</b> to the library, and has the following content:
</p>
<ol>
<li><a href=\"Modelica://MultiBondLib.UsersGuide.Overview\">Overview of library</a>
       gives an overview of the library.
</ol>

<h3>Please note:</h3>
Even if you are completely unfimiliar to bond graphs you
can use the sublibraries for mechanical systems.
Those libraries offer a domain specific solution and can be used without any knowledge of bond graphs.

</html>"));
    package Overview "Overview"
      class BGM "Bondgraphic modelling"
        annotation (Documentation(info="<html>
Bond graphs offer a generic domain-independent means to graphically modeling physical systems in an object-oriented fashion.
<p>
To comfortably model with bond graphs a Modelica library called \"BondLib\" has been developed by Francois E. Cellier and his students. Using this library, bond graphs can be created in an object oriented fashion.

<p>
The <a href=\"Modelica://BondLib\">BondLib</a> also offers an excellent <a href=\"Modelica://BondLib.UsersGuide\">introduction</a>.
If you're unfamiliar to bondgraphic modelling this is a good way to start.

<p>
Please note, that the \"BondLib\" is also partially required by the MultiBondLib.
The MultiBondLib is also very similar to the BondLib in its structure and in its way of usage.
All your modeling abilities with respect to the BondLib can be adobted for the MultiBondLib.
</html>"));
      end BGM;

      class MBGM "Multibondgraphic modelling"
        annotation (Documentation(info="<html>

<h3>Presentation of Multibonds</h3>
The Multibonds, sometimes also called vector bonds,  are an important extension of the classic bondgraphic terminology. Multibonds carry a variable number of bonds of the
same domain or at least of closely related domains (like the translational and the rotational domain) and
model multi-dimensional power flows.
<p>
The next figure illustrates the abbreviation of three parallel bonds by a multibond. The cardinality of the multibond is denoted by the placed in the middle of the multibond .

<p>
<img src=\"../Images/MultiBond.png\">
</p>

<h3>Causal and acausal Multibonds</h3>
Of course, there are also multibond counterparts for the causal bonds, but it has to be mentioned that these two causal multibonds do not cover all possible causalizations, because mixed causality is possible. Anyhow a notation for mixed causality is missing and also not very meaningful. If we want to explicitly show it, we have to decompose the multibond into single causal bonds.
<p>
<img src=\"../Images/CausalMultiBonds.png\">
</p>

<h3>Multibondgraphic elements</h3>
Each vertex element of a single bond graph has its multibondgraphic counterpart. The elementary
equations of the basic bondgraphic elements remain the same. A transformation to the
multibondgraphic terminolgy just extends the equations to be written in vectorial form.

<h3>Advanced multibondgraphic elements</h3>
Sensor elements for bondgraphic effort, flow, position and charge are provided as well.
These elements provide an acausal real signal.
<p>
Also multibondgraphic switches have been developed, although their usage is barely meaningful.

<h3>Additional elements for multibond graphs</h3>
Elements are needed to allow a composition, decomposition and reordering of multibond graphs.
These elements can be found in the subpackage: \"Compositions\"
The converter bonds provide an interface to the single bond elements of the \"BondLib\".

<h3>Applications of multibond graphs</h3>
Multibond graphs are mainly used to model multidimensional processes. These can be diffusion
processes like a heat distribution in planar electric circuit. In the sublibraries multibond graphs are used
to model multidimensional mechanics. Another interesting field of application is the modeling of
chemical reaction dynamics. Multibonds may also be applicable in the field of general relativity.

</html>"));
      end MBGM;

      class Wrapping "Wrapping multibond graphs"

        annotation (Documentation(info="<html>
Although multibond graphs can be used to describe arbitrarily complex physical systems, they offer a fairly low-level interface and are therefore not always easily readable. Especially multibond graphs of mechanical
systems tend to become pretty large and hard to read. Furthermore, different modelers may prefer different modeling mechanisms, because they are more familiar with them. <p>

Since bond graphs offer a low-level interface, it is always possible to wrap bond graphs inside other modeling metaphors.  For example, the model of a damper in planar mechanics: <p>

<img src=\"../Images/DamperIcon.png\"> <p>

contains the simple bond graph: <p>

<img src=\"../Images/DamperModel.png\"> <p>

The <b>M2D->MBG</b> and <b>MBG->M2D</b> models are converter elements that transform the mechanical connectors to bond graph connectors, and vice versa.
<p>
Wrapping is extensively used in the domain specific subpackages of the MultiBondLib.
</html>"));
      end Wrapping;

      class planarMechLib "The planar mechanics library"
        annotation (Documentation(info="<html>
  The MultiBondLib contains a subpackage for planar mechanical models: PlanarMechanics.
  <p>
  This library is similar in its structure
  and way of usage to the <a href=\"Modelica://Modelica.Mechanics.MultiBody\">MultiBody</a> library.
<p>
<img src=\"../Images/PlanarLoop2.png\">
<img src=\"../Images/CraneCrab.png\">
</p>
<p>
This library offers an object-oriented solution for the modeling of planar mechanical systems.
Mechanical systems can be composed out of single ideal elements. They are separated according to their nature
into subpackages. These packages contain:
<ul>
<li> basic parts: like bodies or massless rods<br>
<li> joint elements <br>
<li> force elements <br>
</ul>
<p>
All the basic elements consist of multibond graphs.

<h3>Tutorial</h3>
The <a href=\"Modelica://Modelica.Mechanics.MultiBody\">MultiBody</a> library offers an excelent  <a href=\"Modelica://Modelica.Mechanics.MultiBody.UsersGuide\">tutorial</a>.
The models of this library can be treated essentially the same way.

<h3>Wrapped MultiBond Graphs</h3>
A look into the mechanical models reveals the corresponding multibond graphs.
The standard multibond for planar mechanical systems is of cardinality 3 and summarizes the translational and rotational domain. The first two bonds belong to the translational domain
whereas the third one is of the rotational domain. A multibond's effort vector is then {fx, fy, t}
and the corresponding flow vector: {vx,vy,w}. The composition is illustrated in the next figure.
<p>
<img src=\"../Images/PlanarMechBond.png\">
</p>
<p>
The processing of the positional variables is done by acausal signals.
All bondgraphic variables and the positional signals are resolved in the inertial system.
<p>
Two converter elements convert the bondgraphic variables to the variables of the main connectors and vice-versa. These elements create a shell for the multibond graph.
The figure below presents such a typical shell. The multibond graph is indicated by 1-junctions.
<p>
<img src=\"../Images/PlanarShell.png\">
</p>

<h3>Kinematic Loops</h3>
Kinematic loops are not problematic and can be modeled in a fully object-oriented way.
The appearing redundant statements are removed automatically.
Whenever loop structures occur, non-linear algebraic equations are present on \"position level\", but
usually they are solved fast and robustly and cause no further problems.

Also an element for the manual closure of kinematic loops is provided.
The application of this element is meaningful, if you want to \"cut\" the loop at a specific point.
(This might lead to better equations)


<h3>Efficency</h3>
The PlanarMechanics library offers a comprehensive set of ideal elements for planar mechanics.
Planar systems can be comfortably modeled and efficiently simulated.
<p>
The selection of the state variables is of major importance for the efficiency of the resulting simulation.
This selection is automatically done by Dymola. The resulting state variables are then always the states of a joint's relative position and motion. So each joint is declaring state variables, unless there is a kinematic loop.
<p>
The state selection can be improved or fully determined by the advanced parameter \"enforceStates\"
that is part of all joints. This helpful to avoid sets of dynamic state selection as they occur in kinematic loops.
<p>
The resulting systems of linear equations are usually small and can be solved
fast and accurately. Kinematic loops usually lead to a system of 2 non-linear equations.

<h3>Examples</h3>
A small set of examples demonstrate the usage of the PlanarMechanics library.
They are easy to understand and offer a good starting point to make yourself familiar with this
library.

</html>"));
      end planarMechLib;

      class MechLib "The 3D mechanics library"
        annotation (Documentation(info="<html>
  <p>
  This library is a partial reimplementation of the <a href=\"Modelica://Modelica.Mechanics.MultiBody\">MultiBody</a> library of Prof. Dr. Martin Otter.
<p>
<img src=\"../Images/Bicycle.png\">
<img src=\"../Images/FourBarLoop.png\">
</p>
<p>
This library offers an object-oriented solution for the modeling of 3D-mechanical systems.
Mechanical systems can be composed out of single ideal elements. They are separated according to their nature
into subpackages. These packages contain:
<ul>
<li> basic parts: like bodies or massless rods<br>
<li> joint elements <br>
<li> ideal rolling objects <br>
<li> force elements <br>
</ul>
<p>
All the basic elements consist of multibond graphs.

<h3>Tutorial</h3>
The <a href=\"Modelica://Modelica.Mechanics.MultiBody\">MultiBody</a> library offers an excelent  <a href=\"Modelica://Modelica.Mechanics.MultiBody.UsersGuide\">tutorial</a>.
The models of this library can be treated essentially the same way.

<h3>Wrapped MultiBond Graphs</h3>
A look into the mechanical models reveals the corresponding multibond graphs.
There are separate multibonds for the translational and rotational domain, both of cardinality 3.
 The composition of them is illustrated in the next figure.
<p>
<img src=\"../Images/3DMechBond.png\">
</p>
<p>

This separation is necessary because the corresponding bondgraphic variables are resolved in different coordinate systems. The translational variables are resolved with respect to the inertial system. The rotational variables are resolved with respect to the body system. The body system is defined by the
signal R that contains the 3x3 orientation matrix.
Again, the the positional variables are processed by acuasal signals and are of course resolved in the inertial system.
<p>
Two converter elements convert the bondgraphic variables to the variables of the main connectors and vice-versa. These elements create a shell for the multibond graph.
The figure below presents such a typical shell. The multibond graph is indicated by 1-junctions.
<p>
<img src=\"../Images/3DShell.png\">
</p>

<h3>Kinematic Loops</h3>
Kinematic loops are not problematic and can be modeled in a fully object-oriented way.
The appearing redundant statements are removed automatically.
Whenever loop structures occur, non-linear algebraic equations are present on \"position level\", but
usually they are solved fast and robustly and cause no further problems.
<p>
Also an element for the manual closure of kinematic loops is provided.
The application of this element is meaningful, if you want to \"cut\" the loop at a specific point.
(This might lead to better equations)
<p>
Planar loops cannot be handled autoatically. To close such a strucute a special revolute joint is provided.

<h3>Efficency</h3>
The Mechanics3D library offers a comprehensive set of ideal elements for 3D-mechanics.
Mechanical systems can be comfortably modeled and efficiently simulated.
<p>
The selection of the state variables is of major importance for the efficiency of the resulting simulation.
This selection is automatically done by Dymola. The resulting state variables are then always the states of a joint's relative position and motion. So each joint is declaring state variables, unless there is a kinematic loop.
<p>
The state selection can be improved or fully determined by the advanced parameter \"enforceStates\"
that is part of all joints. This helpful to avoid sets of dynamic state selection as they occur in kinematic loops.
<p>
The resulting systems of linear equations are usually small and can be solved
fast and accurately. Kinematic loops lead to a systems non-linear equations.

<h3>Examples</h3>
A comprehensive set of examples demonstrate the usage of the Mechanics3D library.
They are easy to understand and offer a good starting point to make yourself familiar with this
library. Don't forget the examples of the PlanarMechanics library.
</html>"));
      end MechLib;

      class HybridMechLib "The hybrid 3D mechanics library "
        annotation (Documentation(info="<html>
  The MultiBondLib contains a subpackage for hybrid 3D-mechanical models: Mechanics3DwithImpulses.
  <p>
  It is an extension of the subpackage Mechanics3D.
  The continuous models are extended to hybrid models, that describe the behaviour of in situaions of continuous changement and in situations of sudden (impulse) changement.
The extension of the underlying continuous models is done by equations.
<p>
<img src=\"../Images/NewtonsCradle.png\">
<img src=\"../Images/Cue.png\">
</p>
<p>
The library is used to create models of mechanical systems that underly hard collisions and impacts.
Again, mechanical systems can be composed out of single ideal elements. They are seperated as in Mechanics3D into packages for:
<ul>
<li> basic parts like bodies or fixations
<li> joint elements
<li> force elements
<li> contact models
</ul>
<p>

<h3>Tutorial</h3>
The modeling of the actual mechanical systems doesn't differ from the Mechanics3D library.
<p>
A contact model needs to be applied to model an hard impact between two mechanical systems.
The contact model generates additionally a contact signal that needs to be manually connected to both colliding systmes. This is done via the \"InsertImpulse\" element of the subpackage \"interfaces\".
<p>
If a system underlies several possible impacts, the corresponding contact signals have to be merged
by a boolean \"or\" function.
<p>
Please, don't forget to take a look at the examples.

<h3>Extension of the continuous models</h3>
The existing continuous models of the Mechanics3D library are extended by their corresponding impulse equations. The necessary equations are added in textual form. The continuous models remain unchanged.
<p>
To afford such an extension of the continuous models, it is necessary to redeclare the existing connectors. The new connectors are an extended variant of the old ones.
The new connector contains also boolean variable that is the contact signals. This signal is set to true at the time of a force impulse and is transmitted between all rigid connections.

<h3>Kinematic Loops</h3>
Impacts on kinematic loops cause no severe problems. Only the loop needs to be closed manually
by a special CloseLoop elements of the package \"Joints\". The CloseLoop element is an
extension of the manual loop closer of the Mechanics3D library. It is needed, because
a further loop needs to be cut: the one of the boolean contact signal.

<h3>Efficency</h3>
The efficiency of the continuous models is not impaired in any way.
<p>
The efficiency of the computation at an discrete event is sufficient but could be better.
However, the resulting systems of linear equations are solved accurately and robustly.


<h3>Examples</h3>
A small set of examples demonstrate the usage of the Mechanics3DwithImpulses library.
They offer a good starting point to make yourself familiar with this library.

</html>"));
      end HybridMechLib;

      class Examples "Examples"
        annotation (Documentation(info="<html>
  The main library offers a few general examples:
  <ul>
  <li><a href=\"Modelica://MultiBondLib.Examples\">Basic examples</a>
  </ul>
  <p>
  Most of the examples are provided in the domain-specific sublibraries:
  <ul>
  <li><a href=\"Modelica://MultiBondLib.PlanarMechanics.Examples\">Examples of planar mechanical systems.</a>
  <li><a href=\"Modelica://MultiBondLib.Mechanics3D.Examples\">Examples of 3D mechanical systems.</a>
  <li><a href=\"Modelica://MultiBondLib.Mechanics3DwithImpulses.Examples\">Examples of 3D collisions.</a>
  </ul>
</html>"));
      end Examples;

      class Literature "Literature"
        annotation (Documentation(info="<html>
This modeling of this library is described in the corresponding
<a href='http://www.inf.ethz.ch/~fcellier/MS/zimmer_ms.pdf'>master thesis</a>.
The master thesis offers an introduction to bondgraphic and multibondgraphic modeling and
provides explanations of the fundamental mechanical models.
<p>
Additionally, we offer a fairly substantial bibliography of bond graph modeling in the \"<a href=\"http://www.inf.ethz.ch/~fcellier/BondGraphs/bg.html\">Bond Graph Compendium</a>.\"
</html>"));
      end Literature;

      annotation (Documentation(info="<html>
This overview contains the following sections: <p>

<ol>
<li><a href=\"Modelica://MultiBondLib.UsersGuide.Overview.BGM\">Bondgraphic modeling</a>
<li><a href=\"Modelica://MultiBondLib.UsersGuide.Overview.MBGM\">Multibondgraphic modeling</a>
<li><a href=\"Modelica://MultiBondLib.UsersGuide.Overview.Wrapping\">Wrapping multibond graphs</a>
<li><a href=\"Modelica://MultiBondLib.UsersGuide.Overview.planarMechLib\">The planar mechanics library</a>
<li><a href=\"Modelica://MultiBondLib.UsersGuide.Overview.MechLib\">The 3D mechanics library</a>
<li><a href=\"Modelica://MultiBondLib.UsersGuide.Overview.HybridMechLib\">The hybrid 3D mechanics library</a>
<li><a href=\"Modelica://MultiBondLib.UsersGuide.Overview.Examples\">Examples</a>
<li><a href=\"Modelica://MultiBondLib.UsersGuide.Overview.Literature\">Literature</a>
</ol>
</html>"));
    end Overview;
  end UsersGuide;

  model Defaults "Default settings for all Bond Graphic elements"
    parameter Integer n = 1 "default cardinality of Bondgraphic elements";
  equation

    annotation (defaultComponentName="MBG_defaults",
      defaultComponentPrefixes="inner",
    Icon(
        Rectangle(extent=[-60,80; 80,-100], style(
            color=3,
            rgbcolor={0,0,255},
            fillColor=7,
            rgbfillColor={255,255,255})),
        Rectangle(extent=[60,54; 76,40], style(
            pattern=0,
            fillColor=9,
            rgbfillColor={175,175,175},
            fillPattern=1)),
        Rectangle(extent=[60,-46; 76,-60], style(
            pattern=0,
            fillColor=9,
            rgbfillColor={175,175,175},
            fillPattern=1)),
        Rectangle(extent=[60,8; 76,-6], style(
            pattern=0,
            fillColor=9,
            rgbfillColor={175,175,175},
            fillPattern=1)),
        Rectangle(extent=[-80,90; 60,-90], style(
            color=3,
            rgbcolor={0,0,255},
            fillColor=7,
            rgbfillColor={255,255,255})),
        Rectangle(extent=[40,66; 56,52], style(
            pattern=0,
            fillColor=9,
            rgbfillColor={175,175,175},
            fillPattern=1)),
        Rectangle(extent=[40,16; 56,2], style(
            pattern=0,
            fillColor=9,
            rgbfillColor={175,175,175},
            fillPattern=1)),
        Rectangle(extent=[40,-36; 56,-50], style(
            pattern=0,
            fillColor=9,
            rgbfillColor={175,175,175},
            fillPattern=1)),
        Rectangle(extent=[-100,100; 40,-80], style(
            color=3,
            rgbcolor={0,0,255},
            fillColor=7,
            rgbfillColor={255,255,255})),
        Text(
          extent=[-100,84; 40,-50],
          style(
            pattern=0,
            fillColor=9,
            rgbfillColor={175,175,175},
            fillPattern=1),
          string="%n"),
        Text(
          extent=[-102,144; 100,94],
          style(
            pattern=0,
            fillColor=9,
            rgbfillColor={175,175,175},
            fillPattern=1),
          string="%name")),
  preferedView="info",
  Documentation(info="<html>
This is the Default model of the  MultiBondLib.
<p>
This model sets the default cardinality of all bondgraphic elements.
Place this model in every multibondgraphic model and set the default cardinality
via the parameter menu. The default cardinality is then shown in the model icon and is used
in all basic elements downwards the model hierarchy if not stated otherwise.
<p>
Note: all basic bondgraphic elements expect an inner declaration of this Default model with the exact name
MBG_defaults. This model must be part of all complete multibondgraphic models.
</html>
"));
  end Defaults;
annotation (
  version="1.3",
  versionDate="2006-02-28",
  preferedView="info",
  Window(
    x=0,
    y=0.01,
    width=0.58,
    height=0.54,
    library=1,
    autolayout=1),
  Documentation(info="<HTML>
<p>
Library <b>MultiBondLib</b> is a  free Modelica package providing full support
for <b>multibondgraphic</b> modelling. Multibondgraphic modelling is a valuable
tool to model multidimensional process in physical systems.  It is similar in its structure and design
to the BondLib of Prof. Francois. E. Cellier.
</p>
<p>
This library contains also domain-specific subpackages for the modeling of <b>mechanical systems</b>.
</p>
<p>
<img src=\"../Images/Title.png\">
</p>
<dl>
  <dt><b>Author</b></dt>
  <dd>Dirk Zimmer, ETH Z&uuml;rich.<br>
      E-mail: <A HREF='mailto:dzimmer@inf.ethz.ch'>dzimmer@inf.ethz.ch</A><br>&nbsp;</dd>
      This package was developed and implemented in September 2005 - February 2006 at
      the Institute of Computational Science, <br>
      Dept. Computer Science, ETH Z&uuml;rich, Suisse<br>
      This package has been originaly developed as part of a <a href='http://www.inf.ethz.ch/~fcellier/MS/zimmer_ms.pdf'>master thesis</a>.
  </dd>
  <dt><b>Contact</b></dt>
  <dd><a href='http://www.inf.ethz.ch/personal/fcellier/'>Prof. Francois E. Cellier</a><br>
      Institute of Computational Science, <br>
      Dept. Computer Science, <br>
      ETH Z&uuml;rich, <br>
      Suisse<br>
      E-mail: <A HREF='mailto:fcellier@inf.ethz.ch'>fcellier@inf.ethz.ch</A><br>&nbsp;</dd>
      </dd>
</dl>
<h4>Acknowledgement</h4>
<p>The design of the mechanical libraries was significantly influenced by the MultiBody library of Prof. Martin Otter.</p>
<b>Copyright (C) 2007, Dirk Zimmer</b> <p>
<i>The MultiBondLib package is <b>free</b> software;
it can be redistributed and/or modified
under the terms of the <b>Modelica license</b>, see the license conditions
and the accompanying <b>disclaimer</b> in the documentation of package
Modelica in file \"Modelica/package.mo\".</i>
<h4>About version 1.3</h4>
This is the version 1.3. Actuated prismatic joints and revolute joints are now included<br>
This provides a convenient linkage to the 1D mechanical elements of the BondLib v2.1. <br>
Corresponding examples of the planar and three-dimensional mechanical libraries have been updated: <br>
<li><a href=\"Modelica://MultiBondLib.PlanarMechanics.Examples.PlanarPendulum\">Damped planar pendulum</a><br>
<li><a href=\"Modelica://MultiBondLib.Mechanics3D.Examples.CentrifugalForce\">Centrifugal force</a><br>
<h4>About version 1.2</h4>
Version 1.2 contained only minor changes and corrections of version 1.0.<br>
The mistakes in the mechanical sensor elements have been corrected.<br>
The sub-library \"Mechanics3DwithImpulses\" contains a new example and two new elements: <br>
<li><a href=\"Modelica://MultiBondLib.Mechanics3DwithImpulses.Examples.PistonEngine\">Piston engine</a><br>
<li><a href=\"Modelica://MultiBondLib.Mechanics3DwithImpulses.Joints.CutJoints.PlanarRevolute\">Planar cut revolute</a><br>
<li><a href=\"Modelica://MultiBondLib.Mechanics3DwithImpulses.Contacts.EnergyInjection\">Energy injection</a><br>
In addition to version 1.1 two force elements have been added to the planar mechanics library.


</HTML>"),
    uses(BondLib(version="2.1"), Modelica(version="2.2.1")));

  package Interfaces
    "Connectors and partial models for the Modelica multibond library"
  annotation(preferedView="info",Documentation(info="<html>
This package defines the bondgraphic connectors and contains templates (partial models) for the basic
bondgraphic elements. Besides, this package contains an acausal signal connector for real signals.
<p>
<b>MultiBondCon</b> is the main bondgraphic connector.
Flow and effort are vectors of a parameter size n.
It exists in two modifications:
 <b>eMultiBondCon</b> and <b>fMultiBondCon</b>. These modification are used in the causal multibonds.
<p>
The MultiBondCon is not compatible with the BondCon of the classic BondLib.
Use the converter elements of the package Compositions for this purpose.
</html>
"));

    connector MultiBondCon "bi-directional bondgraphic connector"
    annotation(Documentation(info="<html>
This is the main multibondgraphic connector: <b>MultiBondCon</b>.
This connector is acausal.
<p>
This connector references two vector variables which represent physical variables and one
boolean variable of topologic character:
<pre>
 e[n]:  Bondgraphic effort vector
 f[n]:  Bondgraphic flow vector
 d:     Directional boolean variable indicating the direction of positive power flow
</pre>
<p>
The size of the vector variables can be set by the parameter n and is called cardinality.<br>
Make sure that only connectors of the same cardinality are connected.
</html>
"));
      parameter Integer n=1 "Cardinality of Bond connection";
      Real e[n] "Bondgraphic effort variable";
      Real f[n] "Bondgraphic flow variable";
      Real d "Directional variable";

      annotation (Diagram, Icon(
                Ellipse(extent=[-60,60; 60,-60], style(
              color=71,
              rgbcolor={85,170,255},
              fillColor=71,
              rgbfillColor={85,170,255}))));
    end MultiBondCon;

    connector eMultiBondCon "uni-directional bondgraphic connector"
    annotation(Documentation(info="<html>
This is one of the two causal multibondgraphic connectors: <b>eMultiBondCon</b>
<p>
This connector references two vector variables which represent physical variables and one
boolean variable of topologic character:
<pre>
 e[n]:  Bondgraphic effort vector (input)
 f[n]:  Bondgraphic flow vector (output)
 d:     Directional boolean variable indicating the direction of positive power flow (output)
</pre>
<p>
The size of the vector variables can be set by the parameter n and is called cardinality.<br>
Make sure that only connectors of the same cardinality are connected.
</html>
"));
      parameter Integer n=1 "Cardinality of Bond connection";
      input Real e[n] "Bondgraphic effort variable";
      output Real f[n] "Bondgraphic flow variable";
      output Real d "Directional variable";

      annotation (Diagram, Icon(
                Ellipse(extent=[-60,60; 60,-60], style(
              color=71,
              rgbcolor={85,170,255},
              fillColor=71,
              rgbfillColor={85,170,255})),
            Text(
            extent=[-58,60; 60,-46],
            string="e",
            style(
              color=1,
              rgbcolor={255,0,0},
              fillColor=87,
              rgbfillColor={255,85,170}))));
    end eMultiBondCon;

    connector fMultiBondCon "uni-directional bondgraphic connector"
    annotation(Documentation(info="<html>
This is one of the two causal multibondgraphic connectors: <b>eMultiBondCon</b>
<p>
This connector references two vector variables which represent physical variables and one
boolean variable of topologic character:
<pre>
 e[n]:  Bondgraphic effort vector (output)
 f[n]:  Bondgraphic flow vector (input)
 d:     Directional boolean variable indicating the direction of positive power flow (output)
</pre>
<p>
The size of the vector variables can be set by the parameter n and is called cardinality.<br>
Make sure that only connectors of the same cardinality are connected.
</html>
"));

      parameter Integer n=1 "Cardinality of Bond connection";
      output Real e[n] "Bondgraphic effort variable";
      input Real f[n] "Bondgraphic flow variable";
      output Real d "Directional variable";

      annotation (Diagram, Icon(
                Ellipse(extent=[-60,60; 60,-60], style(
              color=71,
              rgbcolor={85,170,255},
              fillColor=71,
              rgbfillColor={85,170,255})),
            Text(
            extent=[-36,28; 36,-34],
            string="f",
            style(
              color=1,
              rgbcolor={255,0,0},
              fillColor=87,
              rgbfillColor={255,85,170}))));
    end fMultiBondCon;
  annotation (Icon(
        Text(
          extent=[-120,122; 120,73],
          string="%name",
          style(color=1)),
        Polygon(points=[-100,50; -80,70; 100,70; 80,50; -100,50],      style(
            color=58,
            fillColor=30,
            fillPattern=1)),
        Polygon(points=[100,70; 100,-80; 80,-100; 80,50; 100,70],      style(
            color=58,
            fillColor=30,
            fillPattern=1)),
        Rectangle(extent=[-100,-100; 80,50],   style(
            color=58,
            fillColor=30,
            fillPattern=1)),
        Text(
          extent=[-85,35; 65,-85],
          string="Library",
          style(color=58))));
    connector RealSignal "acausal real signal"
    annotation(Documentation(info="<html>
This is a connector for acausal real signals of arbitrary size.
<p>
These signal connector is used in the modulated multibondgraphic elements
and in the multibondgraphic sensors elements.
</html>
"));
       extends Modelica.Blocks.Interfaces.RealSignal;

      annotation (Icon(Polygon(points=[0,80; -80,0; 0,-80; 80,0; 0,80], style(
              color=3,
              rgbcolor={0,0,255},
              fillColor=7,
              rgbfillColor={255,255,255},
              fillPattern=1)), Text(
            extent=[-80,28; 80,-26],
            style(
              color=3,
              rgbcolor={0,0,255},
              fillColor=7,
              rgbfillColor={255,255,255},
              fillPattern=1),
            string="%name")));
    end RealSignal;

    partial model ActiveOnePort
      "partial model invoking one bondgraphic conncetor"
    annotation(Documentation(info="<html>
This is the template for active one-port elements (e.g.: source elements).
</html>
"));
      final parameter Integer N = MBG_defaults.n;
      parameter Integer n = N "Cardinality of Bond connection";
      MultiBondCon MultiBondCon1(n=n) annotation (extent=[-110,-10; -90,10]);
      Real e[n] "Bondgraphic effort variable";
      Real f[n] "Bondgraphic flow variable";
      annotation (Diagram, Icon);
    protected
      outer Defaults MBG_defaults;
    equation
      e = MultiBondCon1.e;
      f = (-MultiBondCon1.d)*MultiBondCon1.f;
    end ActiveOnePort;

    partial model EightPortZero
      "partial model invoking 8 optional bondgraphic connectors"
      final parameter Integer N = MBG_defaults.n;
      parameter Integer n = N "Cardinality of Bond connections";

      //define bondgraphic variables
      Real e1[n];
      Real f1[n];
      Real e2[n];
      Real f2[n];
      Real e3[n];
      Real f3[n];
      Real e4[n];
      Real f4[n];
      Real e5[n];
      Real f5[n];
      Real e6[n];
      Real f6[n];
      Real e7[n];
      Real f7[n];
      Real e8[n];
      Real f8[n];
      annotation (Coordsys(
          extent=[-200,-200; 200,200],
          grid=[2,2],
          component=[20,20]),  Documentation(info="<html>
This is the template for a 0-junction with up to eight ports.
Unused ports (connectors) are automatically deactivated.
<p>
The multibondgraphic effort and flow vectors can be accessed through the variables e1-e8 and f1-f8.
</html>
"),     Diagram);
      MultiBondCon MultiBondCon1(n=n)     annotation (extent=[-210,-10; -190,10]);
      MultiBondCon MultiBondCon2(n=n)     annotation (extent=[188,-10; 208,10]);
      MultiBondCon MultiBondCon3(n=n) annotation (extent=[-10,-210; 10,-190]);
      MultiBondCon MultiBondCon4(n=n) annotation (extent=[-10,188; 10,208]);
      MultiBondCon MultiBondCon5(n=n) annotation (extent=[-110,90; -90,110]);
      MultiBondCon MultiBondCon6(n=n) annotation (extent=[90,90; 110,110]);
      MultiBondCon MultiBondCon7(n=n) annotation (extent=[-110,-110; -90,-90]);
      MultiBondCon MultiBondCon8(n=n) annotation (extent=[92,-110; 112,-90]);
    protected
      outer Defaults MBG_defaults;
    equation

      //assign bondgraphic variables to optional connectors
      e1 = MultiBondCon1.e;
      f1 = MultiBondCon1.d*MultiBondCon1.f;
      e2 = MultiBondCon2.e;
      f2 = MultiBondCon2.d*MultiBondCon2.f;
      e3 = MultiBondCon3.e;
      f3 = MultiBondCon3.d*MultiBondCon3.f;
      e4 = MultiBondCon4.e;
      f4 = MultiBondCon4.d*MultiBondCon4.f;
      e5 = MultiBondCon5.e;
      f5 = MultiBondCon5.d*MultiBondCon5.f;
      e6 = MultiBondCon6.e;
      f6 = MultiBondCon6.d*MultiBondCon6.f;
      e7 = MultiBondCon7.e;
      f7 = MultiBondCon7.d*MultiBondCon7.f;
      e8 = MultiBondCon8.e;
      f8 = MultiBondCon8.d*MultiBondCon8.f;
      if cardinality(MultiBondCon1) == 0 then
        MultiBondCon1.d = 1;
        f1 = zeros(n);
      end if;
      if cardinality(MultiBondCon2) == 0 then
        MultiBondCon2.d = 1;
        f2 = zeros(n);
      end if;
      if cardinality(MultiBondCon3) == 0 then
        MultiBondCon3.d = 1;
        f3 = zeros(n);
      end if;
      if cardinality(MultiBondCon4) == 0 then
        MultiBondCon4.d = 1;
        f4 = zeros(n);
      end if;
      if cardinality(MultiBondCon5) == 0 then
        MultiBondCon5.d = 1;
        f5 = zeros(n);
      end if;
      if cardinality(MultiBondCon6) == 0 then
        MultiBondCon6.d = 1;
        f6 = zeros(n);
      end if;
      if cardinality(MultiBondCon7) == 0 then
        MultiBondCon7.d = 1;
        f7 = zeros(n);
      end if;
      if cardinality(MultiBondCon8) == 0 then
        MultiBondCon8.d = 1;
        f8 = zeros(n);
      end if;

    end EightPortZero;

    partial model EightPortOne
      "partial model invoking 8 optional bondgraphic connectors"
      final parameter Integer N = MBG_defaults.n;
      parameter Integer n = N "Cardinality of Bond connections";

      //define bondgraphic variables
      Real e1[n];
      Real f1[n];
      Real e2[n];
      Real f2[n];
      Real e3[n];
      Real f3[n];
      Real e4[n];
      Real f4[n];
      Real e5[n];
      Real f5[n];
      Real e6[n];
      Real f6[n];
      Real e7[n];
      Real f7[n];
      Real e8[n];
      Real f8[n];
      annotation (Coordsys(
          extent=[-200,-200; 200,200],
          grid=[2,2],
          component=[20,20]),  Documentation(info="<html>
This is the template for a 1-junction with up to eight ports.
Unused ports (connectors) are automatically deactivated.
<p>
The multibondgraphic effort and flow vectors can be accessed through the variables e1-e8 and f1-f8.
</html>
"),     Diagram);
      MultiBondCon MultiBondCon1(n=n)     annotation (extent=[-210,-10; -190,10]);
      MultiBondCon MultiBondCon2(n=n)     annotation (extent=[188,-10; 208,10]);
      MultiBondCon MultiBondCon3(n=n) annotation (extent=[-10,-210; 10,-190]);
      MultiBondCon MultiBondCon4(n=n) annotation (extent=[-10,188; 10,208]);
      MultiBondCon MultiBondCon5(n=n) annotation (extent=[-110,90; -90,110]);
      MultiBondCon MultiBondCon6(n=n) annotation (extent=[90,90; 110,110]);
      MultiBondCon MultiBondCon7(n=n) annotation (extent=[-110,-110; -90,-90]);
      MultiBondCon MultiBondCon8(n=n) annotation (extent=[92,-110; 112,-90]);
    protected
      outer Defaults MBG_defaults;
    equation

      //assign bondgraphic variables to optional connectors
      e1 = MultiBondCon1.d*MultiBondCon1.e;
      f1 = MultiBondCon1.f;
      e2 = MultiBondCon2.d*MultiBondCon2.e;
      f2 = MultiBondCon2.f;
      e3 = MultiBondCon3.d*MultiBondCon3.e;
      f3 = MultiBondCon3.f;
      e4 = MultiBondCon4.d*MultiBondCon4.e;
      f4 = MultiBondCon4.f;
      e5 = MultiBondCon5.d*MultiBondCon5.e;
      f5 = MultiBondCon5.f;
      e6 = MultiBondCon6.d*MultiBondCon6.e;
      f6 = MultiBondCon6.f;
      e7 = MultiBondCon7.d*MultiBondCon7.e;
      f7 = MultiBondCon7.f;
      e8 = MultiBondCon8.d*MultiBondCon8.e;
      f8 = MultiBondCon8.f;
      if cardinality(MultiBondCon1) == 0 then
        MultiBondCon1.d = 1;
        e1 = zeros(n);
      end if;
      if cardinality(MultiBondCon2) == 0 then
        MultiBondCon2.d = 1;
        e2 = zeros(n);
      end if;
      if cardinality(MultiBondCon3) == 0 then
        MultiBondCon3.d = 1;
        e3 = zeros(n);
      end if;
      if cardinality(MultiBondCon4) == 0 then
        MultiBondCon4.d = 1;
        e4 = zeros(n);
      end if;
      if cardinality(MultiBondCon5) == 0 then
        MultiBondCon5.d = 1;
        e5 = zeros(n);
      end if;
      if cardinality(MultiBondCon6) == 0 then
        MultiBondCon6.d = 1;
        e6 = zeros(n);
      end if;
      if cardinality(MultiBondCon7) == 0 then
        MultiBondCon7.d = 1;
        e7 = zeros(n);
      end if;
      if cardinality(MultiBondCon8) == 0 then
        MultiBondCon8.d = 1;
        e8 = zeros(n);
      end if;

    end EightPortOne;

    partial model FourPortZero
      "partial model invoking 8 optional bondgraphic connectors"
      final parameter Integer N = MBG_defaults.n;
      parameter Integer n = N "Cardinality of Bond connections";

      //define bondgraphic variables
      Real e1[n];
      Real f1[n];
      Real e2[n];
      Real f2[n];
      Real e3[n];
      Real f3[n];
      Real e4[n];
      Real f4[n];
      annotation (Coordsys(
          extent=[-100, -100; 100, 100],
          grid=[2, 2],
          component=[20, 20]), Documentation(info="<html>
This is the template for a 1-junction with up to four ports.
Unused ports (connectors) are automatically deactivated.
<p>
The multibondgraphic effort and flow vectors can be accessed through the variables e1-e4 and f1-f4.
</html>
"),     Diagram);
      MultiBondCon MultiBondCon1(n=n)     annotation (extent=[-110, -10; -90,
            10]);
      MultiBondCon MultiBondCon2(n=n)     annotation (extent=[90, -10; 110, 10]);
      MultiBondCon MultiBondCon3(n=n) annotation (extent=[-10,-110; 10,-90]);
      MultiBondCon MultiBondCon4(n=n) annotation (extent=[-10,90; 10,110]);
    protected
      outer Defaults MBG_defaults;
    equation

      //assign bondgraphic variables to optional connectors
      e1 = MultiBondCon1.e;
      f1 = MultiBondCon1.d*MultiBondCon1.f;
      e2 = MultiBondCon2.e;
      f2 = MultiBondCon2.d*MultiBondCon2.f;
      e3 = MultiBondCon3.e;
      f3 = MultiBondCon3.d*MultiBondCon3.f;
      e4 = MultiBondCon4.e;
      f4 = MultiBondCon4.d*MultiBondCon4.f;
      if cardinality(MultiBondCon1) == 0 then
        MultiBondCon1.d = 1;
        f1 = zeros(n);
      end if;
      if cardinality(MultiBondCon2) == 0 then
        MultiBondCon2.d = 1;
        f2 = zeros(n);
      end if;
      if cardinality(MultiBondCon3) == 0 then
        MultiBondCon3.d = 1;
        f3 = zeros(n);
      end if;
      if cardinality(MultiBondCon4) == 0 then
        MultiBondCon4.d = 1;
        f4 = zeros(n);
      end if;

    end FourPortZero;

    partial model FourPortOne
      "partial model invoking 4 optional bondgraphic connectors"
      final parameter Integer N = MBG_defaults.n;
      parameter Integer n = N "Cardinality of Bond connections";

      //define bondgraphic variables
      Real e1[n];
      Real f1[n];
      Real e2[n];
      Real f2[n];
      Real e3[n];
      Real f3[n];
      Real e4[n];
      Real f4[n];
      annotation (Coordsys(
          extent=[-100, -100; 100, 100],
          grid=[2, 2],
          component=[20, 20]), Documentation(info="<html>
This is the template for a 0-junction with up to four ports.
Unused ports (connectors) are automatically deactivated.
<p>
The multibondgraphic effort and flow vectors can be accessed through the variables e1-e4 and f1-f4.
</html>
"),     Diagram);
      MultiBondCon MultiBondCon1(n=n)     annotation (extent=[-110, -10; -90,
            10]);
      MultiBondCon MultiBondCon2(n=n)     annotation (extent=[90, -10; 110, 10]);
      MultiBondCon MultiBondCon3(n=n) annotation (extent=[-10,-110; 10,-90]);
      MultiBondCon MultiBondCon4(n=n) annotation (extent=[-10,90; 10,110]);
    protected
      outer Defaults MBG_defaults;
    equation

      //assign bondgraphic variables to optional connectors
      e1 = MultiBondCon1.d*MultiBondCon1.e;
      f1 = MultiBondCon1.f;
      e2 = MultiBondCon2.d*MultiBondCon2.e;
      f2 = MultiBondCon2.f;
      e3 = MultiBondCon3.d*MultiBondCon3.e;
      f3 = MultiBondCon3.f;
      e4 = MultiBondCon4.d*MultiBondCon4.e;
      f4 = MultiBondCon4.f;
      if cardinality(MultiBondCon1) == 0 then
        MultiBondCon1.d = 1;
        e1 = zeros(n);
      end if;
      if cardinality(MultiBondCon2) == 0 then
        MultiBondCon2.d = 1;
        e2 = zeros(n);
      end if;
      if cardinality(MultiBondCon3) == 0 then
        MultiBondCon3.d = 1;
        e3 = zeros(n);
      end if;
      if cardinality(MultiBondCon4) == 0 then
        MultiBondCon4.d = 1;
        e4 = zeros(n);
      end if;

    end FourPortOne;

    partial model PassiveOnePort
      "partial model invoking one bondgraphic connector"
    annotation(Documentation(info="<html>
This is the template for passive one-port elements (e.g.: resistors).
</html>
"));
      final parameter Integer N = MBG_defaults.n;
      parameter Integer n = N "Cardinality of Bond connection";
      MultiBondCon MultiBondCon1(n=n) annotation (extent=[-110,-10; -90,10]);
      Real e[n] "Bondgraphic effort variable";
      Real f[n] "Bondgraphic flow variable";
      annotation (Diagram, Icon);
    protected
      outer Defaults MBG_defaults;
    equation
      e = MultiBondCon1.e;
      f = MultiBondCon1.d*MultiBondCon1.f;
    end PassiveOnePort;

    partial model TwoDiffPort
      "partial model invoking two bondgraphic conncetors of different cardinality"
      final parameter Integer N = MBG_defaults.n;
      parameter Integer nA = N "Cardinality of Bond connection A";
      parameter Integer nB = N "Cardinality of Bond connection B";
      Real eA[nA] "Bondgraphic primary effort";
      Real fA[nA] "Bondgraphic primary flow";
      Real eB[nB] "Bondgraphic secondary effort";
      Real fB[nB] "Bondgraphic secondary flow";
      annotation (Coordsys(
          extent=[-100, -100; 100, 100],
          grid=[2, 2],
          component=[20, 20]), Documentation(info="<html>
This is a partial model invoking two bondgraphic connectors of different cardinality.   It is a template for transformer elements.  <p>
<pre>
Potential variables:
 e1:  Bondgraphic effort variable of first connector
 f1:  Bondgraphic flow variable of first connector, normalized positive for flows into the model
 e2:  Bondgraphic effort variable of second connector
 f2:  Bondgraphic flow variable of second connector, normalized positive for flows out of this model
</pre>
</html>
"),     Diagram,
        Icon(
          Line(points=[-60,-48; 60,-48], style(color=0, rgbcolor={0,0,0})),
          Line(points=[48,-40; 60,-48], style(color=0, rgbcolor={0,0,0})),
          Line(points=[60,-48; 48,-56], style(color=0, rgbcolor={0,0,0})),
          Text(
            extent=[-162,-30; -32,-2],
            style(color=0, rgbcolor={0,0,0}),
            string="a"),
          Text(
            extent=[0,-30; 202,-4],
            style(color=0, rgbcolor={0,0,0}),
            string="b")));
      MultiBondCon MultiBondConA(n=nA)    annotation (extent=[-110, -10; -90,
            10]);
      MultiBondCon MultiBondConB(n=nB)    annotation (extent=[90, -10; 110, 10]);
    protected
      outer Defaults MBG_defaults;
    equation
      eA = MultiBondConA.e;
      fA = MultiBondConA.d*MultiBondConA.f;
      eB = MultiBondConB.e;
      fB = -MultiBondConB.d*MultiBondConB.f;
    end TwoDiffPort;

    partial model TwoPort "partial model invoking two bondgraphic connectors"
      final parameter Integer N = MBG_defaults.n;
      parameter Integer n = N "Cardinality of Bond connections";
      Real e1[n] "Bondgraphic primary effort";
      Real f1[n] "Bondgraphic primary flow";
      Real e2[n] "Bondgraphic secondary effort";
      Real f2[n] "Bondgraphic secondary flow";
      annotation (Coordsys(
          extent=[-100, -100; 100, 100],
          grid=[2, 2],
          component=[20, 20]), Documentation(info="<html>
This is a partial model invoking two bondgraphic connectors.  It is a template for transformer elements. <p>
<pre>
Potential variables:
 e1:  Bondgraphic effort variable of first connector
 f1:  Bondgraphic flow variable of first connector, normalized positive for flows into the model
 e2:  Bondgraphic effort variable of second connector
 f2:  Bondgraphic flow variable of second connector, normalized positive for flows out of this model
</pre>
</html>
"),     Diagram,
        Icon(
          Line(points=[-60,-48; 60,-48], style(color=0, rgbcolor={0,0,0})),
          Line(points=[48,-40; 60,-48], style(color=0, rgbcolor={0,0,0})),
          Line(points=[60,-48; 48,-56], style(color=0, rgbcolor={0,0,0}))));
      MultiBondCon MultiBondCon1(n=n)     annotation (extent=[-110, -10; -90,
            10]);
      MultiBondCon MultiBondCon2(n=n)     annotation (extent=[90, -10; 110, 10]);
    protected
      outer Defaults MBG_defaults;
    equation
      e1 = MultiBondCon1.e;
      f1 = MultiBondCon1.d*MultiBondCon1.f;
      e2 = MultiBondCon2.e;
      f2 = -MultiBondCon2.d*MultiBondCon2.f;
    end TwoPort;

    partial model TwoPortOne
      "partial model invoking two bondgraphic connectors"
      final parameter Integer N = MBG_defaults.n;
      parameter Integer n = N "Cardinality of Bond connections";
      Real e1[n] "Bondgraphic primary effort";
      Real f1[n] "Bondgraphic primary flow";
      Real e2[n] "Bondgraphic secondary effort";
      Real f2[n] "Bondgraphic secondary flow";
      annotation (Coordsys(
          extent=[-100, -100; 100, 100],
          grid=[2, 2],
          component=[20, 20]), Documentation(info="<html>
This is a partial model invoking two bondgraphic connectors.  It is used only for the description of the two-port 1-junction. <p>
<pre>
Potential variables:
 e1:  Bondgraphic effort variable of first connector, normalized positive for flows into the model
 f1:  Bondgraphic flow variable of first connector
 e2:  Bondgraphic effort variable of second connector, normalized positive for flows into the model
 f2:  Bondgraphic flow variable of second connector
</pre>
</html>
"));
      MultiBondCon MultiBondCon1(n=n)     annotation (extent=[-110, -10; -90,
            10]);
      MultiBondCon MultiBondCon2(n=n)     annotation (extent=[90, -10; 110, 10]);
    protected
      outer Defaults MBG_defaults;
    equation
      e1 = MultiBondCon1.d*MultiBondCon1.e;
      f1 = MultiBondCon1.f;
      e2 = MultiBondCon2.d*MultiBondCon2.e;
      f2 = MultiBondCon2.f;
    end TwoPortOne;

    partial model TwoPortZero
      "partial model invoking two bondgraphic connectors"
      final parameter Integer N = MBG_defaults.n;
      parameter Integer n = N "Cardinality of Bond connections";
      Real e1[n] "Bondgraphic primary effort";
      Real f1[n] "Bondgraphic primary flow";
      Real e2[n] "Bondgraphic secondary effort";
      Real f2[n] "Bondgraphic secondary flow";
      annotation (Coordsys(
          extent=[-100, -100; 100, 100],
          grid=[2, 2],
          component=[20, 20]), Documentation(info="<html>
This is a partial model invoking two bondgraphic connectors.  It is used only for the description of the two-port 0-junction. <p>
<pre>
Potential variables:
 e1:  Bondgraphic effort variable of first connector
 f1:  Bondgraphic flow variable of first connector, normalized positive for flows into the model
 e2:  Bondgraphic effort variable of second connector
 f2:  Bondgraphic flow variable of second connector, normalized positive for flows into the model
</pre>
</html>
"));
      MultiBondCon MultiBondCon1(n=n)     annotation (extent=[-110, -10; -90,
            10]);
      MultiBondCon MultiBondCon2(n=n)     annotation (extent=[90, -10; 110, 10]);
    protected
      outer Defaults MBG_defaults;
    equation
      e1 = MultiBondCon1.e;
      f1 = MultiBondCon1.d*MultiBondCon1.f;
      e2 = MultiBondCon2.e;
      f2 = MultiBondCon2.d*MultiBondCon2.f;
    end TwoPortZero;
  end Interfaces;

  package Bonds "causal and acausal MultiBonds"
    extends Modelica.Icons.Library;
  annotation(preferedView="info",Documentation(info="<html>
This package contains models of the three multibonds.
The <b>MultiBond</b> represents the classic acausal multibond.
<b>eMultiBond</b> and <b>fMultiBond</b> are causal multibonds, where
the flow variable is computed at the side marked by a stroke. The
effort variable is computed at the other side of the bond.
<p>
The cardinality of the multibond is shown in the middle of the multibond. A large N denotes the default cardinality.
Pay attention that the cardinality of the multibond matches the cardinality of the connected bondgraphic elements
<p>
A multibond has to be connected to a multibondgraphic vertex element.
It is not possible to connect two multibonds directly with each other.
</html>
"),   Icon);
    model MultiBond "the acausal multibond"
    annotation(Documentation(info="<html>
This is the model for a non-causal bond.
<p>
The cardinality of the multibond can be set through an parameter and
is shown in the middle of the multibond icon.
<p>
The model invokes two multibondgraphic connectors determines their cardinality
and assigns the values for the directional variable d: d is -1 at the tail and +1 at the head connector.
</html>
"));
      final parameter Integer N = MBG_defaults.n;
      parameter Integer n = N "Cardinality of Bond";
      Interfaces.MultiBondCon MultiBondCon1(n=n)
        annotation (extent=[-110,-10; -90,10]);
      Interfaces.MultiBondCon MultiBondCon2(n=n)
        annotation (extent=[90,-10; 110,10]);
      annotation (Icon(
          Line(points=[-80,-20; 80,-20], style(
              color=3,
              rgbcolor={0,0,255},
              thickness=2,
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1)),
          Line(points=[-80,20; 40,20], style(
              color=3,
              rgbcolor={0,0,255},
              thickness=2,
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1)),
          Line(points=[80,-20; 20,40], style(
              color=3,
              rgbcolor={0,0,255},
              thickness=2,
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1)),
          Text(
            extent=[-78,20; 64,-20],
            style(color=0),
            string="%n")), Diagram);
    protected
      outer Defaults MBG_defaults;
    equation
      MultiBondCon1.e =   MultiBondCon2.e;
      MultiBondCon1.f =   MultiBondCon2.f;
      MultiBondCon1.d =   -1;
      MultiBondCon2.d =  +1;
    end MultiBond;
  annotation (Diagram);
    block eMultiBond "a causal multibond (flow computed at the tail)"
    annotation(Documentation(info="<html>
This is the model for a causal bond. The multibondgraphic flow variable is computed at the tail.
<p>
The cardinality of the multibond can be set through an parameter and
is shown in the middle of the multibond icon.
<p>
The model invokes the two causal multibondgraphic connectors determines their cardinality
and assigns the values for the directional variable d: d is -1 at the tail and +1 at the head connector.
</html>
"));
      final parameter Integer N = MBG_defaults.n;
      parameter Integer n = N "Cardinality of Bond";
      Interfaces.fMultiBondCon fMultiBondCon1(n=n)
        annotation (extent=[-110,-10; -90,10]);
      Interfaces.eMultiBondCon eMultiBondCon2(n=n)
        annotation (extent=[90,-10; 110,10]);
      annotation (Icon(
          Line(points=[-80,-20; 90,-20], style(
              color=3,
              rgbcolor={0,0,255},
              thickness=2,
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1)),
          Line(points=[-80,20; 50,20], style(
              color=3,
              rgbcolor={0,0,255},
              thickness=2,
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1)),
          Line(points=[90,-20; 30,40], style(
              color=3,
              rgbcolor={0,0,255},
              thickness=2,
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1)),
          Line(points=[-80,52; -80,-52], style(
              color=3,
              rgbcolor={0,0,255},
              thickness=2,
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1)),
          Text(
            extent=[-78,20; 62,-20],
            style(color=0),
            string="%n")), Diagram);

    protected
      outer Defaults MBG_defaults;
    equation
      fMultiBondCon1.e =   eMultiBondCon2.e;
      fMultiBondCon1.f =   eMultiBondCon2.f;
      fMultiBondCon1.d =   -1;
      eMultiBondCon2.d =  +1;
    end eMultiBond;

    block fMultiBond "a causal multibond (flow computed at the head)"
    annotation(Documentation(info="<html>
This is the model for a causal bond. The multibondgraphic flow variable is computed at the head.
<p>
The cardinality of the multibond can be set through an parameter and
is shown in the middle of the multibond icon.
<p>
The model invokes the two causal multibondgraphic connectors determines their cardinality
and assigns the values for the directional variable d: d is -1 at the tail and +1 at the head connector.
</html>
"));
      final parameter Integer N = MBG_defaults.n;
      parameter Integer n = N "Cardinality of Bond";
      Interfaces.eMultiBondCon eMultiBondCon1(n=n)
        annotation (extent=[-110,-10; -90,10]);
      Interfaces.fMultiBondCon fMultiBondCon2(n=n)
        annotation (extent=[90,-10; 110,10]);
      annotation (Icon(
          Line(points=[-80,-20; 86,-20], style(
              color=3,
              rgbcolor={0,0,255},
              thickness=2,
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1)),
          Line(points=[-80,20; 46,20], style(
              color=3,
              rgbcolor={0,0,255},
              thickness=2,
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1)),
          Line(points=[86,-20; 26,40], style(
              color=3,
              rgbcolor={0,0,255},
              thickness=2,
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1)),
          Line(points=[-80,20; -80,-20], style(
              color=3,
              rgbcolor={0,0,255},
              thickness=2,
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1)),
          Text(
            extent=[-80,20; 60,-20],
            style(color=0),
            string="%n"),
          Line(points=[86,50; 86,-54],   style(
              color=3,
              rgbcolor={0,0,255},
              thickness=2,
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1))),
                           Diagram);
    protected
      outer Defaults MBG_defaults;
    equation
      eMultiBondCon1.e =   fMultiBondCon2.e;
      eMultiBondCon1.f =   fMultiBondCon2.f;
      eMultiBondCon1.d =   -1;
      fMultiBondCon2.d =  +1;
    end fMultiBond;

    package Utilities "make-up tools for multibonds"
    annotation(preferedView="info",Documentation(info="<html>
The utility package contains a dummy element to create nice tails for long multibonds.
</html>
"));
      annotation (Icon(
          Text(
            extent=[-122,120; 118,71],
            string="%name",
            style(color=42, rgbcolor={127,0,0})),
          Polygon(points=[-102,48; -82,68; 98,68; 78,48; -102,48], style(
              color=42,
              rgbcolor={127,0,0},
              fillColor=30,
              rgbfillColor={235,235,235},
              fillPattern=1)),
          Polygon(points=[98,68; 98,-82; 78,-102; 78,48; 98,68], style(
              color=42,
              rgbcolor={127,0,0},
              fillColor=30,
              rgbfillColor={235,235,235},
              fillPattern=1)),
          Rectangle(extent=[-102,-102; 78,48], style(
              color=42,
              rgbcolor={127,0,0},
              fillColor=30,
              rgbfillColor={235,235,235},
              fillPattern=1)),
          Text(
            extent=[-87,33; 63,-87],
            string="Library",
            style(color=42, rgbcolor={127,0,0}))));
      model MultiBondTail
        "a dummy model to enhance the visualizazion of stretched mutlibonds"
      annotation(Documentation(info="<html>
This model serves as an extra icon, that can be used to give multibonds a tail in the modeling window.
This is useful for long multibonds or for multibonds that go around corners.
<p>
Besides, this model is a dummy modell. It doesn't do anything. It's just a visual gimmick.
</html>
"));
        annotation (Icon(
            Line(points=[20,-20; 100,-20], style(
                color=3,
                rgbcolor={0,0,255},
                thickness=2,
                fillColor=71,
                rgbfillColor={85,170,255},
                fillPattern=1)),
            Line(points=[20,20; 100,20], style(
                color=3,
                rgbcolor={0,0,255},
                thickness=2,
                fillColor=71,
                rgbfillColor={85,170,255},
                fillPattern=1)),
            Line(points=[-40,-20; 20,-20], style(
                color=69,
                rgbcolor={0,128,255},
                thickness=2,
                fillColor=71,
                rgbfillColor={85,170,255},
                fillPattern=1)),
            Line(points=[-40,20; 20,20], style(
                color=69,
                rgbcolor={0,128,255},
                thickness=2,
                fillColor=71,
                rgbfillColor={85,170,255},
                fillPattern=1)),
            Line(points=[-80,-20; -40,-20], style(
                color=71,
                rgbcolor={85,170,255},
                thickness=2,
                fillColor=71,
                rgbfillColor={85,170,255},
                fillPattern=1)),
            Line(points=[-80,20; -40,20], style(
                color=71,
                rgbcolor={85,170,255},
                thickness=2,
                fillColor=71,
                rgbfillColor={85,170,255},
                fillPattern=1)),
            Line(points=[-100,-20; -80,-20], style(
                color=71,
                rgbcolor={85,170,255},
                pattern=3,
                thickness=2,
                fillColor=71,
                rgbfillColor={85,170,255},
                fillPattern=1)),
            Line(points=[-100,20; -80,20], style(
                color=71,
                rgbcolor={85,170,255},
                pattern=3,
                thickness=2,
                fillColor=71,
                rgbfillColor={85,170,255},
                fillPattern=1))));
      equation

      end MultiBondTail;
    end Utilities;
  end Bonds;

  package Junctions "Junctions"
    extends Modelica.Icons.Library;
  annotation(preferedView="info",Documentation(info="<html>
This package contains models for multibondgraphic junctions.
<p>
The classic 0- and 1-junctions are offered in two variants with eight or four connectors.
Unused connectors are ignored and do not corrupt the model.
Giant junctions can be constructed by connecting two junctions of the same sex via a multibond.
<p>
All connectors of the classic junctions do have the same cardinality, which can be set by a parameter.
<p>
There are also partial 0- or 1-junctions. Such a junction allows a multibond to intrude into a path of multibonds
with higher cardinality.
</html>
"),   Icon);

    model J0 "Model of a standard 0-junction with up to 4 ports"
    annotation(Documentation(info="<html>
This is the model for a four port 0-junction. Unused connectors are ignored.
<p>
All connectors of the junction do have the same cardinality, which can be set by an parameter.
</html>
"));
      extends Interfaces.FourPortZero;
      annotation (
        Coordsys(
          extent=[-100, -100; 100, 100],
          grid=[2, 2],
          component=[20, 20]),
        Diagram(Text(
            extent=[-60, 80; 60, -80],
            string="0",
            style(color=0))),
        Icon(Text(
            extent=[-60, 80; 60, -80],
            string="0",
            style(color=0))),
        Documentation(info="<html>
This is the model of the TwoPort 0-junction.  It has one causality stroke.
</html>
"));
    equation
      e2 = e1;
      e3 = e1;
      e4 = e1;
      f1 + f2 + f3 +f4 = zeros(n);
    end J0;

    model J0large "Model of a large 0-junction with up to 8 ports"
    annotation(Documentation(info="<html>
This is the model for a eight port 0-junction. Unused connectors are ignored.
<p>
All connectors of the junction do have the same cardinality, which can be set by an parameter.
</html>
"));

      extends Interfaces.EightPortZero;
      annotation (
        Coordsys(
          extent=[-200,-200; 200,200],
          grid=[2, 2],
          component=[20, 20]),
        Diagram(
             Text(
            extent=[-152,156; 166,-160],
            string="0",
            style(color=0))),
        Icon(
          Line(points=[-102,0; -194,0], style(color=69, rgbcolor={0,128,255})),
          Line(points=[0,100; 0,194], style(color=69, rgbcolor={0,128,255})),
          Line(points=[100,0; 190,0], style(color=69, rgbcolor={0,128,255})),
          Line(points=[0,-102; 0,-192], style(color=69, rgbcolor={0,128,255})),
          Line(points=[-70,70; -96,96], style(color=69, rgbcolor={0,128,255})),
          Line(points=[70,70; 96,96], style(color=69, rgbcolor={0,128,255})),
          Line(points=[70,-70; 96,-96], style(color=69, rgbcolor={0,128,255})),
          Line(points=[-70,-70; -96,-96], style(color=69, rgbcolor={0,128,255})),
          Ellipse(extent=[120,120; -122,-120], style(
              color=69,
              rgbcolor={0,128,255},
              fillColor=7,
              rgbfillColor={255,255,255},
              fillPattern=1)),
             Text(
            extent=[-134,136; 144,-142],
            string="0",
            style(color=0))),
        Documentation(info="<html>
This is the model of the TwoPort 0-junction.  It has one causality stroke.
</html>
"));
    equation
      e2 = e1;
      e3 = e1;
      e4 = e1;
      e5 = e1;
      e6 = e1;
      e7 = e1;
      e8 = e1;
      f1 + f2 + f3 +f4 + f5 + f6 + f7 + f8= zeros(n);
    end J0large;

    model J0Partial "Model of a partial 3-Port 0-junction"
    annotation(Documentation(info="<html>
This is the model for a 3 port partial 0-junction. All connectors have to be connected.
<p>
A small multibond with cardinality nPartial is intruding a path of multibonds
of cardinality n. The bonds of the small multibond are then connected to some of
the other bonds by a 0-junction.
<p>
The exact junction behaviour can be specified by the parameter \"order\". This has to be a permutation vector of size n.
The single bonds of the small multibond are then connected to the first nPartial bonds,
denoted by the permutation vector.
<p>
The functionality of this junction can be emulated by the usage of compositon,
permutation and junction elements. The figure below shows the equivalent graph.
<p>
<img src=\"../wheelOnBump.png\">
</p>
</html>
"));

      final parameter Integer N = MBG_defaults.n;
      parameter Integer n = N "Cardinality throughgoing Bond connections";
      parameter Integer nPartial = 1
        "Cardinality of intruding Bond connection (<=n)";

      Interfaces.MultiBondCon MultiBondCon1(n=n)
        annotation (extent=[-110,-10; -90,10]);
      Interfaces.MultiBondCon MultiBondCon2(n=n)
        annotation (extent=[90,-10; 110,12]);
      Interfaces.MultiBondCon MultiBondCon3(n=nPartial) annotation (extent=[-10,90;
            10,110], style(color=71, rgbcolor={85,170,255}));
      parameter Integer order[n] = {1};
      annotation (Diagram, Icon(
          Text(
            extent=[-98,-80; 100,-48],
            style(color=3, rgbcolor={0,0,255}),
            string="%order"),
          Line(points=[-80,-16; 90,-16], style(
              color=71,
              rgbcolor={85,170,255},
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1)),
          Line(points=[-80,24; -32,24], style(
              color=71,
              rgbcolor={85,170,255},
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1)),
          Line(points=[90,-16; 30,44], style(
              color=71,
              rgbcolor={85,170,255},
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1)),
          Line(points=[16,24; 50,24], style(
              color=71,
              rgbcolor={85,170,255},
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1)),
          Line(points=[16,10; 64,10], style(
              color=71,
              rgbcolor={85,170,255},
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1)),
          Line(points=[-80,10; -18,10], style(
              color=71,
              rgbcolor={85,170,255},
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1)),
          Line(points=[-80,0; 74,0], style(
              color=71,
              rgbcolor={85,170,255},
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1)),
          Line(points=[-40,32; -18,10], style(
              color=71,
              rgbcolor={85,170,255},
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1)),
          Text(
            extent=[-100,-16; 100,-50],
            string="partial",
            style(color=0, rgbcolor={0,0,0})),
          Text(
            extent=[-70,100; 70,-16],
            string="0",
            style(color=0, rgbcolor={0,0,0}))));
    protected
      outer Defaults MBG_defaults;
    equation
      //equations for complete junction part
      for i in 1:nPartial loop
          MultiBondCon2.e[order[i]] = MultiBondCon1.e[order[i]];
          MultiBondCon3.e[i] = MultiBondCon1.e[order[i]];
          MultiBondCon1.d*MultiBondCon1.f[order[i]]+MultiBondCon2.d*MultiBondCon2.f[order[i]]+MultiBondCon3.d*MultiBondCon3.f[i]=0;
      end for;
      //equations for incomplete junction part
      for i2 in (nPartial+1):n loop
          MultiBondCon2.e[order[i2]] = MultiBondCon1.e[order[i2]];
          MultiBondCon1.d*MultiBondCon1.f[order[i2]]+MultiBondCon2.d*MultiBondCon2.f[order[i2]]=0;
      end for;
    end J0Partial;

    model J1 "Model of a standard 1-junction with up to 4 ports"
    annotation(Documentation(info="<html>
This is the model for a four port 1-junction. Unused connectors are ignored.
<p>
All connectors of the junction do have the same cardinality, which can be set by an parameter.
</html>
"));

      extends Interfaces.FourPortOne;
      annotation (
        Coordsys(
          extent=[-100, -100; 100, 100],
          grid=[2, 2],
          component=[20, 20]),
        Diagram(Text(
            extent=[-60, 80; 60, -80],
            style(color=0),
            string="1")),
        Icon(Text(
            extent=[-60, 80; 60, -80],
            style(color=0),
            string="1")),
        Documentation(info="<html>
This is the model of the TwoPort 0-junction.  It has one causality stroke.
</html>
"));
    equation
      e1+e2+e3+e4 = zeros(n);
      f1 = f2;
      f1 = f3;
      f1 = f4;
    end J1;

    model J1large "Model of a large 1-junction with up to 8 ports"
    annotation(Documentation(info="<html>
This is the model for a eight port 1-junction. Unused connectors are ignored.
<p>
All connectors of the junction do have the same cardinality, which can be set by an parameter.
</html>
"));

      extends Interfaces.EightPortOne;
      annotation (
        Coordsys(
          extent=[-200,-200; 200,200],
          grid=[2, 2],
          component=[20, 20]),
        Diagram(
             Text(
            extent=[-152,156; 166,-160],
            style(color=0),
            string="1")),
        Icon(
          Line(points=[-102,0; -194,0], style(color=69, rgbcolor={0,128,255})),
          Line(points=[0,100; 0,194], style(color=69, rgbcolor={0,128,255})),
          Line(points=[100,0; 190,0], style(color=69, rgbcolor={0,128,255})),
          Line(points=[0,-102; 0,-192], style(color=69, rgbcolor={0,128,255})),
          Line(points=[-70,70; -96,96], style(color=69, rgbcolor={0,128,255})),
          Line(points=[70,70; 96,96], style(color=69, rgbcolor={0,128,255})),
          Line(points=[70,-70; 96,-96], style(color=69, rgbcolor={0,128,255})),
          Line(points=[-70,-70; -96,-96], style(color=69, rgbcolor={0,128,255})),
          Ellipse(extent=[120,120; -122,-120], style(
              color=69,
              rgbcolor={0,128,255},
              fillColor=7,
              rgbfillColor={255,255,255},
              fillPattern=1)),
             Text(
            extent=[-140,136; 138,-142],
            style(color=0),
            string="1")),
        Documentation(info="<html>
This is the model of the TwoPort 0-junction.  It has one causality stroke.
</html>
"));
    equation
      e1 + e2 + e3 +e4 + e5 + e6 + e7 + e8= zeros(n);
      f2 = f1;
      f3 = f1;
      f4 = f1;
      f5 = f1;
      f6 = f1;
      f7 = f1;
      f8 = f1;
    end J1large;

    model J1Partial "Model of a partial 3-Port 1-junction"
    annotation(Documentation(info="<html>
This is the model for a 3 port partial 1-junction. All connectors have to be connected.
<p>
A small multibond with cardinality nPartial is intruding a path of multibonds
of cardinality n. The bonds of the small multibond are then connected to some of
the other bonds by a 1-junction.
<p>
The exact junction behaviour can be specified by the parameter \"order\". This has to be a permutation vector of size n.
The single bonds of the small multibond are then connected to the first nPartial bonds,
denoted by the permutation vector.
<p>
The functionality of this junction is similar to the partial 0-junction.
</html>
"));
      final parameter Integer N = MBG_defaults.n;
      parameter Integer n = N "Cardinality of through going Bond connections";
      parameter Integer nPartial = N
        "Cardinality of intruding Bond connection (<=n)";

      Interfaces.MultiBondCon MultiBondCon1(n=n)
        annotation (extent=[-110,-10; -90,10]);
      Interfaces.MultiBondCon MultiBondCon2(n=n)
        annotation (extent=[90,-10; 110,12]);
      Interfaces.MultiBondCon MultiBondCon3(n=nPartial) annotation (extent=[-10,90;
            10,110], style(color=71, rgbcolor={85,170,255}));
      parameter Integer order[n] = {1};
      annotation (Diagram, Icon(
          Text(
            extent=[-98,-80; 100,-48],
            style(color=3, rgbcolor={0,0,255}),
            string="%order"),
          Line(points=[-80,-16; 90,-16], style(
              color=71,
              rgbcolor={85,170,255},
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1)),
          Line(points=[-80,24; -32,24], style(
              color=71,
              rgbcolor={85,170,255},
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1)),
          Line(points=[90,-16; 30,44], style(
              color=71,
              rgbcolor={85,170,255},
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1)),
          Line(points=[16,24; 50,24], style(
              color=71,
              rgbcolor={85,170,255},
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1)),
          Line(points=[16,10; 64,10], style(
              color=71,
              rgbcolor={85,170,255},
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1)),
          Line(points=[-80,10; -18,10], style(
              color=71,
              rgbcolor={85,170,255},
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1)),
          Line(points=[-80,0; 74,0], style(
              color=71,
              rgbcolor={85,170,255},
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1)),
          Line(points=[-40,32; -18,10], style(
              color=71,
              rgbcolor={85,170,255},
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1)),
          Text(
            extent=[-100,-16; 100,-50],
            string="partial",
            style(color=0, rgbcolor={0,0,0})),
          Text(
            extent=[-70,100; 70,-16],
            style(color=0, rgbcolor={0,0,0}),
            string="1")));
    protected
      outer Defaults MBG_defaults;
    equation
      //equations for complete junction part
      for i in 1:nPartial loop
          MultiBondCon2.f[order[i]] = MultiBondCon1.f[order[i]];
          MultiBondCon3.f[i] = MultiBondCon1.f[order[i]];
          MultiBondCon1.d*MultiBondCon1.e[order[i]]+MultiBondCon2.d*MultiBondCon2.e[order[i]]+MultiBondCon3.d*MultiBondCon3.e[i]=0;
      end for;
      //equations for incomplete junction part
      for i2 in (nPartial+1):n loop
            MultiBondCon2.f[order[i2]] = MultiBondCon1.f[order[i2]];
            MultiBondCon1.d*MultiBondCon1.e[order[i2]]+MultiBondCon2.d*MultiBondCon2.e[order[i2]]=0;
         end for;
    end J1Partial;
  end Junctions;

  package Compositions
    "MultiBond Graphic elements to join, split, reorder or convert MultiBonds"
    extends Modelica.Icons.Library;
  annotation(preferedView="info",Documentation(info="<html>
This package contains models to compose, decompose, permute or convert multibonds.
<p>
Multibonds can be joined or split by the usage of the <b>Composition</b> element.
<p>
The order of the single bonds within a multibond can be changed by the element <b>PermutMultiBond</b>.
<p>
The models <b>FromMultiBond</b> and <b>ToMultiBond</b> are an interface
to the classic <b>BondLib</b>.
</html>
"),   Icon);

    model Composition "bondgraphic element to compose / decompose multibonds"
    annotation(Documentation(info="<html>
This model enables the composition (or decomposition respectively) of multibonds.
<p>
The two multibonds at connector A and B with cardinalities nA and nB are merged to
a multibond of cardinality nA+nB, so that the first vector nA elements are equivalent
to the multibond at connector A and the other ones are equal to the multibond at connector B.
<p>
Because this is an acausal element, it can also be used to decompose multibonds.
</html>
"));
      final parameter Integer N = MBG_defaults.n;
      parameter Integer nA=N "Cardinality of upper Bond connection";
      parameter Integer nB=N "Cardinality of lower Bond connection";

      annotation (
        Coordsys(extent=[-100,-200; 100,200]),
        Diagram(Line(points=[0,180; 0,-180; 0,-178], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              fillColor=87,
              rgbfillColor={255,85,170},
              fillPattern=1)),
          Text(
            extent=[-128,98; -74,56],
            string="a",
            style(color=71, rgbcolor={85,170,255})),
          Text(
            extent=[-126,-102; -72,-144],
            style(color=71, rgbcolor={85,170,255}),
            string="b")),
        Icon(
          Line(points=[-80,-80; -60,-80], style(
              color=71,
              rgbcolor={85,170,255},
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1)),
          Line(points=[-80,120; 20,120], style(
              color=71,
              rgbcolor={85,170,255},
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1)),
          Line(points=[2,80; -80,80], style(
              color=71,
              rgbcolor={85,170,255},
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1)),
          Text(
            extent=[-80,120; -28,80],
            style(color=0, rgbcolor={0,0,0}),
            string="%nA"),
          Line(points=[-80,-120; -40,-120], style(
              color=71,
              rgbcolor={85,170,255},
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1)),
          Line(points=[-60,-80; 20,120], style(
              color=71,
              rgbcolor={85,170,255},
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1)),
          Line(points=[-40,-120; 42,80],  style(
              color=71,
              rgbcolor={85,170,255},
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1)),
          Line(points=[12,120; 80,120], style(
              color=71,
              rgbcolor={85,170,255},
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1)),
          Line(points=[-4,80; 80,80], style(
              color=71,
              rgbcolor={85,170,255},
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1)),
          Line(points=[0,182; 0,-180; 0,-178], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              fillColor=87,
              rgbfillColor={255,85,170},
              fillPattern=1)),
          Text(
            extent=[-80,-80; -30,-120],
            style(color=0, rgbcolor={0,0,0}),
            string="%nB"),
          Text(
            extent=[-124,82; -70,40],
            string="a",
            style(color=71, rgbcolor={85,170,255})),
          Text(
            extent=[-124,-106; -70,-148],
            style(color=71, rgbcolor={85,170,255}),
            string="b")));
      Interfaces.MultiBondCon MultiBondCon1(n=nA)
        annotation (extent=[-112,90; -92,110]);
      Interfaces.MultiBondCon MultiBondCon2(n=nB)
        annotation (extent=[-110,-110; -90,-90]);
      Interfaces.MultiBondCon MultiBondCon3(n=nA+nB)
        annotation (extent=[90,90; 110,110]);
    protected
      outer Defaults MBG_defaults;
    equation
      MultiBondCon3.e[1:nA] = MultiBondCon1.e;
      MultiBondCon3.f[1:nA]*MultiBondCon3.d = -MultiBondCon1.f*MultiBondCon1.d;
      MultiBondCon3.e[(nA+1):(nA+nB)] = MultiBondCon2.e;
      MultiBondCon3.f[(nA+1):(nA+nB)]*MultiBondCon3.d = -MultiBondCon2.f*MultiBondCon2.d;
    end Composition;

    model PermutMultiBond "permuts the order of a multibond"
    annotation(Documentation(info="<html>
This model permutes the vectors of effort and flow.
<p>
The permutation is fully specified by permutation vector p of size n, where
n is the cardinality of the permutation bond.
</html>
"));
      final parameter Integer N = MBG_defaults.n;
      parameter Integer n = N "Cardinality of Bond";
      parameter Integer p[n] = {1}
        "permutation vector (contains all Integers in 1:n)";
      Interfaces.MultiBondCon MultiBondCon1(n=n)
        annotation (extent=[-110,-10; -90,10]);
      Interfaces.MultiBondCon MultiBondCon2(n=n)
        annotation (extent=[90,-10; 110,10]);
      annotation (Diagram, Icon(
          Line(points=[-80,-20; -50,-20],style(
              color=3,
              rgbcolor={0,0,255},
              thickness=2,
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1)),
          Line(points=[-80,20; -50,20],style(
              color=3,
              rgbcolor={0,0,255},
              thickness=2,
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1)),
          Line(points=[80,-20; 20,40], style(
              color=3,
              rgbcolor={0,0,255},
              thickness=2,
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1)),
          Text(
            extent=[-24,20; 30,-20],
            style(color=0),
            string="%n"),
          Line(points=[-50,20; -10,-20],
                                       style(
              color=3,
              rgbcolor={0,0,255},
              thickness=2,
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1)),
          Line(points=[-50,-20; -10,20], style(
              color=3,
              rgbcolor={0,0,255},
              thickness=2,
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1)),
          Line(points=[-10,20; 40,20], style(
              color=3,
              rgbcolor={0,0,255},
              thickness=2,
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1)),
          Line(points=[-10,-20; 80,-20], style(
              color=3,
              rgbcolor={0,0,255},
              thickness=2,
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1))));
    protected
      outer Defaults MBG_defaults;
    equation
      MultiBondCon2.e =   MultiBondCon1.e[p];
      MultiBondCon2.f =   MultiBondCon1.f[p];
      MultiBondCon1.d =   -1;
      MultiBondCon2.d =  +1;
    end PermutMultiBond;

    model FromMultiBond
      "converter bond: converts a 1-multibond to a simple bond"
    annotation(Documentation(info="<html>
This bond is a multibond of cardinality 1 at the tail and a classic single bond at the head.
<p>
This bond is an interface to the classic bondgraphic connectors of the BondLib.
</html>
"));
      Interfaces.MultiBondCon MultiBondCon1(n=1)
        annotation (extent=[-110,-10; -90,10]);
      BondLib.Interfaces.BondCon BondCon1 annotation (extent=[90,-10; 110,10]);
      annotation (Icon(
          Line(points=[-80,-20; 60,-20], style(
              color=3,
              rgbcolor={0,0,255},
              thickness=2,
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1)),
          Line(points=[-80,20; 20,20], style(
              color=3,
              rgbcolor={0,0,255},
              thickness=2,
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1)),
          Line(points=[-40,0; 80,0], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1)),
          Line(points=[40,40; 80,0], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1)),
          Line(points=[0,40; 60,-20], style(
              color=3,
              rgbcolor={0,0,255},
              thickness=2,
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1))), Diagram);
    equation
      BondCon1.e =   MultiBondCon1.e[1];
      BondCon1.f =   MultiBondCon1.f[1];
      BondCon1.d =   +1;
      MultiBondCon1.d =  -1;
    end FromMultiBond;

    model ToMultiBond "converter bond: converts a simple bond to a 1-multibond"
    annotation(Documentation(info="<html>
This bond is a multibond of cardinality 1 at the head and a classic single bond at the tail.
<p>
This bond is an interface to the classic bondgraphic connectors of the BondLib.
</html>
"));
      Interfaces.MultiBondCon MultiBondCon1(n=1)
        annotation (extent=[90,-10; 110,10]);
      BondLib.Interfaces.BondCon BondCon1 annotation (extent=[-110,-10; -90,10]);
      annotation (Icon(
          Line(points=[0,-20; 80,-20], style(
              color=3,
              rgbcolor={0,0,255},
              thickness=2,
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1)),
          Line(points=[-40,20; 40,20], style(
              color=3,
              rgbcolor={0,0,255},
              thickness=2,
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1)),
          Line(points=[80,-20; 20,40], style(
              color=3,
              rgbcolor={0,0,255},
              thickness=2,
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1)),
          Line(points=[-80,0; 20,0], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1)),
          Line(points=[-20,40; 20,0], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              fillColor=71,
              rgbfillColor={85,170,255},
              fillPattern=1))));
    equation
      BondCon1.e =   MultiBondCon1.e[1];
      BondCon1.f =   MultiBondCon1.f[1];
      BondCon1.d =   -1;
      MultiBondCon1.d =  +1;
    end ToMultiBond;
  end Compositions;

  package Passive "Passive elements of the Modelica multibond library "
    extends Modelica.Icons.Library;
  annotation(preferedView="info",Documentation(info="<html>
This package contains passive bond graphic elements:
<p>
<ul>
<li> the resistors (<b>R</b>) and resistive fields (<b>RF</b>),
<li> the conductors (<b>G</b>) and conductive fields (<b>GF</b>),
<li> the capacitors (<b>C</b>) and capacitive fields (<b>CF</b>),
<li> the inductors (<b>I</b>) and inductive fields (<b>IF</b>),
<li> the transformers (<b>TF</b>), and
<li> the gyrators (<b>GY</b>).
</ul>
<p>
In contrast to the classic BondLib, passive field elements are modelled as multibondgraphic one-ports.
Transformators and Gyrators are modelled always as two-ports. This allows a most natural usage.
Even though the field elements provide the most general solution, use the non-field elements
whenever possible, because this leads to better equations.
<p>
The mnemonic code of modulated elements is preceeded by the letter 'm'.
</html>
"));
    model C "multibondgraphic capacitor"
    annotation(Documentation(info="<html>
This is the model of the multibondgraphic capacitance.
<p>
It implements the following relation between the bondgraphic effort and flow:
<p>
<b>The effort is proportional to the integrated flow </b><br>
or: <br>
<b>f</b> = <b>C</b> .* der(<b>e</b>); where <b>C</b> is a vector or a scalar and .* denotes
an elementwise multiplication.
<p>
The cardinality of the element can be set by the parameter n.<br>
The capacitance can be specified by the vector C of  length n or of length 1.
In the latter case, the capacitance C is treaten like a scalar.
</html>
"));
            extends Interfaces.PassiveOnePort;
      parameter Real[:] C={1} "Bondgraphic Capacitances";
    protected
      parameter Real[n] Cvec = if size(C,1) == n then C else ones(n)*C[1];
    equation
      assert((size(C,1) == n) or (size(C,1) == 1),"C must be of length 1 or n");

      for i in 1:n loop
        f[i] = Cvec[i]*der(e[i]);
      end for;
      annotation (Icon(
          Text(extent=[-100,108; 100,60],string="%name"),
          Text(
            extent=[-58,78; 62,-82],
            string="C",
            style(color=0, fillColor=0)),
          Text(extent=[-100,-60; 100,-106],string="C=%C")));
    end C;

    model CF "multibondgraphic capacitive field"
    annotation(Documentation(info="<html>
This is the model of the multibondgraphic capacitive field
<p>
It implements the following relation between the bondgraphic effort and flow vectors:
<p>
<b>The effort is linear dependent on the integrated flow </b><br>
or: <br>
<b>f</b> = <b>C</b> * der(<b>e</b>); where <b>C</b> is a n x n matrix.
<p>
The cardinality of the element can be set by the parameter n.<br>
The capacitve field can be specified by the matrix C of size n x n.
Please note that C should be a symmetric matrix.
</html>
"));
            extends Interfaces.PassiveOnePort;
      parameter Real[n,n] C=[1] "Bondgraphic Capacitive Field";
    equation
      f = C*der(e);
      annotation (Icon(
          Text(extent=[-100,106; 100,60],string="%name"),
          Text(
            extent=[-80,80; 80,-80],
            style(color=0, fillColor=0),
            string="CF"),
          Text(extent=[-100,-60; 100,-106],string="C=%C")));
    end CF;

    model G "multibondgraphic conductrance"
    annotation(Documentation(info="<html>
This is the model of the multibondgraphic conductance
<p>
It implements the following relation between the bondgraphic effort and flow:
<p>
<b>The flow is proportional to the effort </b><br>
or: <br>
<b>f</b> = <b>G</b> .* <b>e</b>; where <b>G</b> is a vector or a scalar and .* denotes
an elementwise multiplication.
<p>
The cardinality of the element can be set by the parameter n.<br>
The conductance can be specified by the vector G of  length n or of length 1.
In the latter case, the capacitance G is treaten like a scalar.
</html>
"));
             extends Interfaces.PassiveOnePort;
      parameter Real[:] G={1} "Bondgraphic Conductances";
    protected
      parameter Real[n] Gvec = if size(G,1) == n then G else ones(n)*G[1];
    equation
      assert((size(G,1) == n) or (size(G,1) == 1),"G must be of length 1 or n");

      for i in 1:n loop
        f[i] = Gvec[i]*e[i];
      end for;

      annotation (Icon(
          Text(extent=[-100,108; 100,60],string="%name"),
          Text(
            extent=[-58,80; 62,-80],
            style(color=0, fillColor=0),
            string="G"),
          Text(extent=[-100,-60; 100,-106],
                                         string="G=%G")));
    end G;

    model GF "multibondgraphic conductive field"
    annotation(Documentation(info="<html>
This is the model of the multibondgraphic conductive field
<p>
It implements the following relation between the bondgraphic effort and flow vectors:
<p>
<b>The flow is linear dependent on the effort </b><br>
or: <br>
<b>f</b> = <b>G</b> * <b>e</b>; where <b>G</b> is a n x n matrix.
<p>
The cardinality of the element can be set by the parameter n.<br>
The conductive field can be specified by the matrix G of size n x n.
Please note that G should be a symmetric matrix.
</html>
"));
             extends Interfaces.PassiveOnePort;
      parameter Real[n,n] G=[1] "Bondgraphic Conductive Field";
    equation
      f = G*e;

      annotation (Icon(
          Text(extent=[-102,106; 100,60],string="%name"),
          Text(
            extent=[-80,80; 80,-80],
            style(color=0, fillColor=0),
            string="GF"),
          Text(extent=[-102,-58; 98,-106],
                                         string="G=%G")));
    end GF;

    model I "multibondgraphic inductance"
    annotation(Documentation(info="<html>
This is the model of the multibondgraphic inductance.
<p>
It implements the following relation between the bondgraphic effort and flow:
<p>
<b>The flow is proportional to the integrated effort </b><br>
or: <br>
<b>e</b> = <b>I</b> .* der(<b>f</b>); where <b>I</b> is a vector or a scalar and .* denotes
an elementwise multiplication.
<p>
The cardinality of the element can be set by the parameter n.<br>
The inductance can be specified by the vector I of  length n or of length 1.
In the latter case, the capacitance I is treaten like a scalar.
</html>
"));
            extends Interfaces.PassiveOnePort;
      parameter Real[:] I={1} "Bondgraphic Inductances";
    protected
      parameter Real[n] Ivec = if size(I,1) == n then I else ones(n)*I[1];
    equation
      assert((size(I,1) == n) or (size(I,1) == 1),"I must be of length 1 or n");
      for i in 1:n loop
        e[i] = Ivec[i]*der(f[i]);
      end for;
      annotation (Icon(
          Text(extent=[-100,106; 100,60],string="%name"),
          Text(
            extent=[-58,80; 62,-80],
            style(color=0, fillColor=0),
            string="I"),
          Text(extent=[-100,-60; 100,-106],
                                         string="I=%I")));
    end I;

    model IF "multibondgraphic inductive field"
    annotation(Documentation(info="<html>
This is the model of the multibondgraphic inductive field
<p>
It implements the following relation between the bondgraphic effort and flow vectors:
<p>
<b>The flow is linear dependent on the integrated effort </b><br>
or: <br>
<b>e</b> = <b>I</b> * der(<b>f</b>); where <b>I</b> is a n x n matrix.
<p>
The cardinality of the element can be set by the parameter n.<br>
The inductive field can be specified by the matrix I of size n x n.
Please note that I should be a symmetric matrix.
</html>
"));
             extends Interfaces.PassiveOnePort;
      parameter Real[n,n] I=[1] "Inductive Field" annotation(Evaluate=true);

    equation
      e = I*der(f);

      annotation (Icon(
          Text(extent=[-102,108; 100,60],string="%name"),
          Text(
            extent=[-76,78; 84,-82],
            style(color=0, fillColor=0),
            string="IF"),
          Text(extent=[-100,-60; 100,-108],
                                         string="I=%I")));
    end IF;

    model mTF_effort "modulated multibondgraphic effort transformator"
      extends Interfaces.TwoPort;
      Interfaces.RealSignal M[n,n] "transformation matrix"
        annotation (extent=[-10,-110; 10,-90]);
    equation
      e2 = M*e1;
      f1 = transpose(M)*f2;
      annotation (Icon(
          Text(extent=[-100,108; 100,60],string="%name"),
          Text(extent=[-68,-50; 72,-90], string="effort"),
          Text(
            extent=[-88,72; 92,-68],
            style(color=0, fillColor=0),
            string="mTF")));
    end mTF_effort;

    model mTF_flow "modulated multibondgraphic flow transformator"
      extends Interfaces.TwoPort;
      Interfaces.RealSignal M[n,n] "transformation matrix"
        annotation (extent=[-10,-110; 10,-90]);
    equation
        f2 = M*f1;
        e1 = transpose(M)*e2;
      annotation (Icon(
          Text(extent=[-100,108; 100,60],string="%name"),
          Text(extent=[-68,-50; 72,-90], string="flow"),
          Text(
            extent=[-90,80; 90,-60],
            style(color=0, fillColor=0),
            string="mTF")));
    end mTF_flow;

    model R "multibondgraphic resistance"
    annotation(Documentation(info="<html>
This is the model of the multibondgraphic resistance
<p>
It implements the following relation between the bondgraphic effort and flow:
<p>
<b>The effort is proportional to the flow </b><br>
or: <br>
<b>e</b> = <b>R</b> .* <b>f</b>; where <b>R</b> is a vector or a scalar and .* denotes
an elementwise multiplication.
<p>
The cardinality of the element can be set by the parameter n.<br>
The resistance can be specified by the vector R of  length n or of length 1.
In the latter case, the capacitance R is treaten like a scalar.
</html>
"));
             extends Interfaces.PassiveOnePort;
      parameter Real[:] R={1} "Bondgraphic Resistances";
    protected
      parameter Real[n] Rvec = if size(R,1) == n then R else ones(n)*R[1];
    equation
      assert((size(R,1) == n) or (size(R,1) == 1),"R must be of length 1 or n");

      for i in 1:n loop
        e[i] = Rvec[i]*f[i];
      end for;

      annotation (Icon(
          Text(extent=[-100,110; 100,60],string="%name"),
          Text(
            extent=[-58,80; 62,-80],
            style(color=0, fillColor=0),
            string="R"),
          Text(extent=[-100,-60; 100,-102],
                                         string="R=%R")));
    end R;

    model RF "multibondgraphic resistive field"
    annotation(Documentation(info="<html>
This is the model of the multibondgraphic resistive field
<p>
It implements the following relation between the bondgraphic effort and flow vectors:
<p>
<b>The effort is linear dependent on the flow </b><br>
or: <br>
<b>e</b> = <b>R</b> * <b>f</b>; where <b>R</b> is a n x n matrix.
<p>
The cardinality of the element can be set by the parameter n.<br>
The resistive field can be specified by the matrix R of size n x n.
Please note that R should be a symmetric matrix.
</html>
"));
             extends Interfaces.PassiveOnePort;
      parameter Real[n,n] R=[1] "Bondgraphic Resistive Field";
    equation
      e = R*f;
      annotation (Icon(
          Text(extent=[-100,108; 100,60],string="%name"),
          Text(
            extent=[-78,78; 82,-82],
            style(color=0, fillColor=0),
            string="RF"),
          Text(extent=[-100,-60; 100,-108],
                                         string="R=%R")));
    end RF;

    model TF2_effort "projective multibondgraphic effort transformator"
    annotation(Documentation(info="<html>
This is the model of the projective multibondgraphic effort transformator. This is a two-port element, where
both connectors are of different cardinality. The bond on side A must be of cardinality nA
and the bond on side B of cardinality nB.
<p>
<b>The bondgraphic effort is projected by the matrix M in direction of the arrow</b><br>
or: <br>
<b>eA</b> = <b>M</b> * der(<b>eB</b>) and<br>
<b>fB</b> = transpose(<b>M</b>) * der(<b>fA</b>);<br>
where <b>M</b> is a  nB x nA matrix.
<p>
The cardinality of the two ports can be set by the parameters nA and nB. <br>
The transformation can be specified by the matrix M of size nB x nA.
</html>
"));
      extends Interfaces.TwoDiffPort;
      parameter Real[nB,nA] M = {{1}} "transformation matrix";
    equation
      eB = M*eA;
      fA = transpose(M)*fB;
      annotation (Icon(
          Text(extent=[-100,110; 100,60],string="%name"),
          Text(extent=[-68,-50; 72,-90], string="effort"),
          Text(
            extent=[-100,70; 100,-68],
            style(color=0, fillColor=0),
            string="TF")));
    end TF2_effort;

    model TF2_flow "projective multibondgraphic flow transformator"
    annotation(Documentation(info="<html>
This is the model of the projective multibondgraphic flow transformator. This is a two-port element, where
both connectors are of different cardinality. The bond on side A must be of cardinality nA
and the bond on side B of cardinality nB.
<p>
<b>The bondgraphic flow is projected by the matrix M in direction of the arrow</b><br>
or: <br>
<b>fA</b> = <b>M</b> * der(<b>fB</b>) and<br>
<b>eB</b> = transpose(<b>M</b>) * der(<b>eA</b>);<br>
where <b>M</b> is a  nB x nA matrix.
<p>
The cardinality of the two ports can be set by the parameters nA and nB. <br>
The transformation can be specified by the matrix M of size nB x nA.
</html>
"));
      extends Interfaces.TwoDiffPort;
      parameter Real[nB,nA] M = {{1}} "transformation matrix";
    equation
      fB = M*fA;
      eA = transpose(M)*eB;
      annotation (Icon(
          Text(extent=[-100,110; 100,60],string="%name"),
          Text(extent=[-68,-50; 72,-90], string="flow"),
          Text(
            extent=[-100,70; 100,-68],
            style(color=0, fillColor=0),
            string="TF")));
    end TF2_flow;

    model TF_effort "multibondgraphic effort transformator"
    annotation(Documentation(info="<html>
This is the model of the multibondgraphic effort transformator. This is a two-port element, where
both connectors are of the same cardinality.
<p>
<b>The bondgraphic effort is transformed by the matrix M in direction of the arrow</b><br>
or: <br>
<b>e2</b> = <b>M</b> * der(<b>e1</b>) and<br>
<b>f1</b> = transpose(<b>M</b>) * der(<b>f2</b>);<br>
where <b>M</b> is a n x n matrix.
<p>
The cardinality of the element can be set by the parameter n. Both connectors
have this cardinality.<br>
The transformation can be specified by the matrix M of size n x n.
Please note, that the offdiagonal part of M should be an antisymmetric matrix.
</html>
"));
      extends Interfaces.TwoPort;
      parameter Real[n,n] M = {{1}} "transformation matrix";
    equation
      e2 = M*e1;
      f1 = transpose(M)*f2;
      annotation (Icon(
          Text(extent=[-100,108; 100,60],string="%name"),
          Text(extent=[-68,-50; 72,-90], string="effort"),
          Text(
            extent=[-134,76; 130,-64],
            style(color=0, fillColor=0),
            string="TF")));
    end TF_effort;

    model TF_flow "multibondgraphic flow transformator"
    annotation(Documentation(info="<html>
This is the model of the multibondgraphic flow transformator. This is a two-port element, where
both connectors are of the same cardinality.
<p>
<b>The bondgraphic flow is transformed by the matrix M in direction of the arrow</b><br>
or: <br>
<b>f2</b> = <b>M</b> * der(<b>f1</b>) and<br>
<b>e1</b> = transpose(<b>M</b>) * der(<b>e2</b>);<br>
where <b>M</b> is a n x n matrix.
<p>
The cardinality of the element can be set by the parameter n. Both connectors
have this cardinality.<br>
The transformation can be specified by the matrix M of size n x n.
Please note, that the offdiagonal part of M should be an antisymmetric matrix.
</html>
"));

      extends Interfaces.TwoPort;
      parameter Real[n,n] M = {{1}} "transformation matrix";
      final parameter Boolean transformFlow = true "tue, if the matrix describes the transformation of the flow.
Otherwise the effort is transformed";
    equation
        f2 = M*f1;
        e1 = transpose(M)*e2;
      annotation (Icon(
          Text(extent=[-102,108; 100,60],string="%name"),
          Text(extent=[-68,-50; 72,-90], string="flow"),
          Text(
            extent=[-130,72; 134,-68],
            style(color=0, fillColor=0),
            string="TF")));
    end TF_flow;

    model SGY "symplectic gyrator"
    annotation(Documentation(info="<html>
This is the model of the symplectic gyrator.This is a two-port element, where
both connectors are of the same cardinality.
This element can be used in partially dualized bondgraphs.
<p>
<b>The bondgraphic effort and flow are switched between the ports.</b><br>
or: <br>
<b>e2</b> = <b>f1</b> and<br>
<b>f2</b> = <b>e1</b>;
<p>
The cardinality of the two ports can be set by the parameter n. <br>
</html>
"));
      extends Interfaces.TwoPort;
    equation
      f2 = e1;
      f1 = e2;
      annotation (Icon(
          Text(extent=[-100,110; 100,60],string="%name"),
          Text(
            extent=[-90,66; 96,-64],
            style(color=0, fillColor=0),
            string="SGY")));
    end SGY;

    model GY_effort "multibondgraphic effort gyrator"
    annotation(Documentation(info="<html>
This is the model of the multibondgraphic effort gyrator. This is a two-port element, where
both connectors are of the same cardinality.
<p>
<b>The bondgraphic effort is transformed by the matrix M into bondgraphic flow in direction of the arrow</b><br>
or: <br>
<b>f2</b> = <b>M</b> * der(<b>e1</b>) and<br>
<b>f1</b> = transpose(<b>M</b>) * der(<b>e2</b>);<br>
where <b>M</b> is a n x n matrix.
<p>
The cardinality of the element can be set by the parameter n. Both connectors
have this cardinality.<br>
The gyrator can be specified by the matrix M of size n x n.
Please note, that the offdiagonal part of M should be an antisymmetric matrix.
</html>
"));
      extends Interfaces.TwoPort;
      parameter Real[n,n] M = {{1}} "transformation matrix";
    equation
      f2 = M*e1;
      f1 = transpose(M)*e2;
      annotation (Icon(
          Text(extent=[-100,108; 100,60],string="%name"),
          Text(
            extent=[-90,66; 96,-64],
            style(color=0, fillColor=0),
            string="GY"),
          Text(extent=[-70,-48; 70,-88], string="effort")));
    end GY_effort;

    model GY_flow "multibondgraphic flow gyrator"
    annotation(Documentation(info="<html>
This is the model of the multibondgraphic flow gyrator. This is a two-port element, where
both connectors are of the same cardinality.
<p>
<b>The bondgraphic flow is transformed by the matrix M into bondgraphic effort in direction of the arrow</b><br>
or: <br>
<b>e2</b> = <b>M</b> * der(<b>f1</b>) and<br>
<b>e1</b> = transpose(<b>M</b>) * der(<b>f2</b>);<br>
where <b>M</b> is a n x n matrix.
<p>
The cardinality of the element can be set by the parameter n. Both connectors
have this cardinality.<br>
The gyrator can be specified by the matrix M of size n x n.
Please note, that the offdiagonal part of M should be an antisymmetric matrix.
</html>
"));
      extends Interfaces.TwoPort;
      parameter Real[n,n] M = {{1}} "transformation matrix";
    equation
      e2 = M*f1;
      e1 = transpose(M)*f2;
      annotation (Icon(
          Text(extent=[-100,108; 100,60],string="%name"),
          Text(
            extent=[-90,66; 96,-64],
            style(color=0, fillColor=0),
            string="GY"),
          Text(extent=[-70,-48; 70,-88], string="flow")));
    end GY_flow;
  end Passive;

  package Sensors "Sensor elements of the Modelica multibond library"
    extends Modelica.Icons.Library;
    annotation(preferedView="info",Documentation(info="<html>
  This package contains sensor elements. Bondgraphic variables like:
  effort, flow, momentum, position and power can be extracted by acausal signals.
<p>
Sensor elements serve for different purposes. They can be used to...
<ul>
<li> ...measure bondgraphic variables (e. g: power or the charge of an capacitor).<br>
<li> ...convert bondgraphic variables to non-bondgraphic signals.<br>
<i>This allows to couple bond graphs with other modelling tools.</i><br>
<li> ...establish algebraic relationships between bondgraphic elements. <br>
<i>(E.g: The sensor signal is modulating other bondgraphic elements)</i><br>
</ul>
<p>
In contrast to the classic BondLib, the sensor signals are acausal. Therefore
momentum and position sensors do not necessarily define integrators. If
the algebraic relations form a structural singularity, a sensor's integrator might be removed
by the pantelides algorithm.
</html>
"));
    model De "sensor of bondgraphic effort"
    annotation(Documentation(info="<html>
The effort sensor converts the bondgraphic effort vector into a real signal.
<p>
The effort sensor has to be connected to a 0-junction via a multibond.
<p>
The size of the sensor signal equals the cardinality of the element which can be specified by the parameter n
<p>
</html>
"));
      extends Interfaces.PassiveOnePort;
      annotation (Diagram, Icon(
             Text(
            extent=[-100,68; 100,-62],
            string="De",
            style(color=0, fillColor=0)), Text(extent=[-100,108; 100,60],
                                                                       string=
                "%name")));
      Interfaces.RealSignal e_out[n]
        annotation (extent=[90,-10; 110,10]);
    equation
      e_out = e;
      f = zeros(n);
    end De;

    model Df "sensor of bondgraphic flow"
    annotation(Documentation(info="<html>
The flow sensor converts the bondgraphic flow vector into a real signal.
<p>
The flow sensor has to be connected to a 1-junction via a multibond.
<p>
The size of the sensor signal equals the cardinality of the element which can be specified by the parameter n
<p>
</html>
"));
      extends Interfaces.PassiveOnePort;
      annotation (Diagram, Icon(          Text(extent=[-100,110; 100,60],
                                                                       string=
                "%name"),
             Text(
            extent=[-80,70; 80,-74],
            style(color=0, fillColor=0),
            string="Df")));
      Interfaces.RealSignal f_out[n]
        annotation (extent=[90,-10; 110,10]);
    equation
      f_out = f;
      e = zeros(n);
    end Df;

    model Dp "sensor of bondgraphic momentum"
    annotation(Documentation(info="<html>
The momentum sensor converts the bondgraphic momentum vector into a real signal.
The bondgraphic momentum is the integrated effort. You can set an inital position by the parameter p_start
The initial condition can be removed by setting the boolean parameter stateInitialCondition to false.
<p>
The momentum sensor has to be connected to a 0-junction via a multibond.
<p>
The size of the sensor signal equals the cardinality of the element which can be specified by the parameter n
<p>
</html>
"));
      extends Interfaces.PassiveOnePort;
      parameter Boolean stateInitialCondition =  true
        "state the initial bondgraphic potential p";
      parameter Real[n] p_start = {0} "initial value for p";
      Interfaces.RealSignal p[n]
        annotation (extent=[90,-10; 110,10]);
      annotation (Diagram, Icon(
             Text(
            extent=[-84,80; 80,-80],
            style(color=0, fillColor=0),
            string="Dp"),                 Text(extent=[-100,108; 100,62],
                                                                       string=
                "%name")));

    initial equation
      if stateInitialCondition then
        p = p_start;
      end if;
    equation
      f = zeros(n);
      der(p) = e;
    end Dp;

    model Dq "sensor of bondgraphic position"
    annotation(Documentation(info="<html>
The position sensor converts the bondgraphic charge vector into a real signal.
The bondgraphic position is the integrated flow. You can set an inital position by the parameter q_start
The initial condition can be removed by setting the boolean parameter stateInitialCondition to false.
<p>
The position sensor has to be connected to a 1-junction via a multibond.
<p>
The size of the sensor signal equals the cardinality of the element which can be specified by the parameter n
<p>
</html>
"));
      extends Interfaces.PassiveOnePort;
      parameter Boolean stateInitialCondition =  true
        "state the initial bondgraphic position q";
      parameter Real[n] q_start = {0} "initial value for q";
      Interfaces.RealSignal[n] q
        annotation (extent=[90,-10; 110,10]);
      annotation (Diagram, Icon(
             Text(
            extent=[-84,80; 82,-80],
            style(color=0, fillColor=0),
            string="Dq"),                 Text(extent=[-100,108; 100,60],
                                                                       string=
                "%name")));

    initial equation
      if stateInitialCondition then
        q = q_start;
      end if;
    equation
      e = zeros(n);
      der(q) = f;
    end Dq;

    model ePMultiBond "Power flow sensor"
    annotation(Documentation(info="<html>
This is the causal power sensor bond. It behaves exactly like a normal causal bond.
In addition, the throughgoing power can be measured by the outgoing singal.
<p>
</html>
"));
      extends Bonds.eMultiBond;

      annotation (Icon, Diagram);
      Interfaces.RealSignal P
        annotation (extent=[-10,50; 10,70]);
    equation
      P = eMultiBondCon2.e * fMultiBondCon1.f;

    end ePMultiBond;

    model fPMultiBond "Power flow sensor"
    annotation(Documentation(info="<html>
This is the causal power sensor bond. It behaves exactly like a normal causal bond.
In addition, the throughgoing power can be measured by the outgoing singal.
<p>
</html>
"));
      extends Bonds.fMultiBond;

      annotation (Icon, Diagram);
      Interfaces.RealSignal P
        annotation (extent=[-10,50; 10,70]);
    equation
      P = eMultiBondCon1.e * fMultiBondCon2.f;

    end fPMultiBond;

    model PMultiBond "Power flow sensor"
    annotation(Documentation(info="<html>
This is the acausal power sensor bond. It behaves exactly like a normal bond.
In addition, the throughgoing power can be measured by the outgoing singal.
<p>
</html>
"));
      extends Bonds.MultiBond;

      annotation (Icon, Diagram);
      Interfaces.RealSignal P
        annotation (extent=[-10,50; 10,70]);
    equation
      P = MultiBondCon1.e * MultiBondCon1.f;

    end PMultiBond;
  end Sensors;

  package Sources "Sources of the Modelica multibond library"
    extends Modelica.Icons.Library;
  annotation(preferedView="info",Documentation(info="<html>
This package contains the active bondgraphic elements: sources.
<p>
The sources are either constant or modulated.
Other source types like sinusoidal sources can easily be created by coupling
Modelica.Blocks with the modulated sources.
</html>
"));
    model mSe "Modulated source of effort"
    annotation(Documentation(info="<html>
This is the model of a modulated source of effort.
The input signal is converted into bondgraphic effort.
<p>
The cardinality of the element can be specified by the parameter n.
The size of the input signal has to match with the cardinality of the outgoing bond.
<p>
Use Modelica.Blocks.Sources as input signal to get all kinds of effort sources.
</html>
"));
      extends Interfaces.ActiveOnePort;
    public
      Interfaces.RealSignal s[n] "Bondgraphic effort"
                                                annotation (extent=[108,-10; 88,10]);
    equation
      e = s;
      annotation (Icon(
          Text(extent=[-100,108; 100,60],string="%name"),
          Text(
            extent=[-94,80; 94,-80],
            style(color=0, fillColor=0),
            string="mSe")));
    end mSe;

    model mSf "Modulated source of flow"
    annotation(Documentation(info="<html>
This is the model of a modulated source of flow.
The input signal is converted into bondgraphic flow.
<p>
The cardinality of the element can be specified by the parameter n.
The size of the input signal has to match with the cardinality of the outgoing bond.
<p>
Use Modelica.Blocks.Sources as input signal to get all kinds of flow sources.
</html>
"));
      extends Interfaces.ActiveOnePort;
    public
      Interfaces.RealSignal s[n] "Bondgraphic flow"
                                                annotation (extent=[106,-10; 86,10]);
    equation
      f = s;
      annotation (Icon(
          Text(extent=[-100,108; 100,60],string="%name"),
          Text(
            extent=[-94,80; 92,-80],
            style(color=0, fillColor=0),
            string="mSf")));
    end mSf;

    model Se "source of effort"
    annotation(Documentation(info="<html>
This is the model of a constant source of effort.
<p>
The cardinality of the element can be specified by the parameter n.
<p>
The constant effort can be specified by the vector e0 of size n or 1.
If the size of e0 is 1, the single value is used for all effort vector elements.
</html>
"));
      extends Interfaces.ActiveOnePort;
      parameter Real[:] e0 = {1} "Bondgraphic effort";
    protected
      parameter Real[n] e0vec = if size(e0,1) == n then e0 else ones(n)*e0[1];
    equation
      assert((size(e0,1) == n) or (size(e0,1) == 1),"e0 must be of length 1 or n");
      e = e0vec;
      annotation (Icon(
          Text(extent=[-100,108; 100,60],string="%name"),
          Text(
            extent=[-100,80; 100,-80],
            style(color=0, fillColor=0),
            string="Se"),
          Text(extent=[-68,-50; 72,-90], string="e0=%e0")));
    end Se;

    model Sf "source of flow"
    annotation(Documentation(info="<html>
This is the model of a constant source of flow.
<p>
The cardinality of the element can be specified by the parameter n.
<p>
The constant flow can be specified by the vector f0 of size n or 1.
If the size of f0 is 1, the single value is used for all flow vector elements.
</html>
"));
      extends Interfaces.ActiveOnePort;
      parameter Real[:] f0 = {1} "Bondgraphic flow";
    protected
      parameter Real[n] f0vec = if size(f0,1) == n then f0 else ones(n)*f0[1];
    equation
      assert((size(f0,1) == n) or (size(f0,1) == 1),"f0 must be of length 1 or n");
      f = f0vec;
      annotation (Icon(
          Text(extent=[-100,108; 100,60],string="%name"),
          Text(
            extent=[-100,80; 100,-80],
            style(color=0, fillColor=0),
            string="Sf"),
          Text(extent=[-68,-50; 72,-90], string="f0=%f0")));
    end Sf;
  end Sources;

  package Switches "Bond graphic switches of the Modelica multibond library"
    extends Modelica.Icons.Library;
    model Sw "ideal bondgraphic switch"
             extends Interfaces.PassiveOnePort;

      Modelica.Blocks.Interfaces.BooleanInput BooleanInPort1  annotation (
          extent=[100,-10; 80,10]);
      annotation (Diagram(
          Line(points=[-80,0; 80,0],   style(color=10)),
          Polygon(points=[70,4; 80,0; 70,-4; 70,4],     style(color=10,
                fillColor=10)),
          Line(points=[0,80; 0,-80],   style(
              color=10,
              fillColor=10,
              fillPattern=1)),
          Polygon(points=[-4,70; 0,80; 4,70; -4,70],     style(
              color=10,
              fillColor=10,
              fillPattern=1)),
          Text(
            extent=[6,80; 16,70],
            style(
              color=10,
              fillColor=10,
              fillPattern=1),
            string="f"),
          Text(
            extent=[70,-4; 80,-14],
            style(
              color=10,
              fillColor=10,
              fillPattern=1),
            string="e"),
          Line(points=[-76,0; -20,0; 22,0; 66,0],           style(
              color=0,
              thickness=2,
              fillColor=10,
              fillPattern=1)),
          Ellipse(extent=[-2,2; 2,-2],  style(
              color=0,
              rgbcolor={0,0,0},
              pattern=3,
              fillColor=0,
              rgbfillColor={0,0,0},
              fillPattern=1)),
          Text(
            extent=[0,-44; 22,-52],
            style(
              color=10,
              pattern=3,
              fillColor=10,
              fillPattern=1),
            string="closed"),
          Text(
            extent=[26,10; 48,2],
            style(
              color=10,
              pattern=3,
              fillColor=10,
              fillPattern=1),
            string="open"),
          Text(
            extent=[0,0; 20,-10],
            style(
              color=10,
              pattern=3,
              fillColor=10,
              fillPattern=1),
            string="s=0"),
          Line(points=[0,-74; 0,-18; 0,16; 0,62],           style(
              color=0,
              thickness=2,
              fillColor=10,
              fillPattern=1)),
          Text(
            extent=[0,38; 22,30],
            style(
              color=10,
              pattern=3,
              fillColor=10,
              fillPattern=1),
            string="closed"),
          Text(
            extent=[-54,10; -32,2],
            style(
              color=10,
              pattern=3,
              fillColor=10,
              fillPattern=1),
            string="open")), Icon(
             Text(
            extent=[-74,100; 74,-100],
            string="Sw",
            style(color=0)), Text(extent=[-100,104; 100,60],string="%name")),
        Documentation(info="<html>
The generic switch element is a passive one-port element.  It inherits the effort and flow variables from the passive OnePort.  The switch has an additional modulating boolean input signal modeling the switch position.  If the modulating input signal has a value of <b>true</b>, the switch is considered <b>open</b>.
<p>
All elements of the effort and flow vector are switched synchronously.
<p>
The causality of the switch element must be free, i.e., the switch element must be placed inside an algebraic loop. <p>
</html>"));
      Boolean open "Switch position";
    equation
      open =BooleanInPort1;
      zeros(n) = if open then f else e;

    end Sw;

    model Sw2 "leaking bondgraphic switch"
             extends Interfaces.PassiveOnePort;
      parameter Real[:] Ron(final min=0) = {1.E-5} "Closed switch resistance";
      parameter Real[:] Goff(final min=0) = {1.E-5} "Opened switch conductance";

      Modelica.Blocks.Interfaces.BooleanInput BooleanInPort1  annotation (
          extent=[100,-10; 80,10]);
      annotation (Diagram(
          Polygon(points=[70,4; 80,0; 70,-4; 70,4],     style(color=10,
                fillColor=10)),
          Text(
            extent=[70,-4; 80,-14],
            style(
              color=10,
              fillColor=10,
              fillPattern=1),
            string="e"),
          Line(points=[-80,0; 80,0],   style(color=10)),
          Polygon(points=[70,4; 80,0; 70,-4; 70,4],     style(color=10,
                fillColor=10)),
          Line(points=[0,80; 0,-80],   style(
              color=10,
              fillColor=10,
              fillPattern=1)),
          Polygon(points=[-4,70; 0,80; 4,70; -4,70],     style(
              color=10,
              fillColor=10,
              fillPattern=1)),
          Text(
            extent=[6,80; 16,70],
            style(
              color=10,
              fillColor=10,
              fillPattern=1),
            string="f"),
          Text(
            extent=[70,-4; 80,-14],
            style(
              color=10,
              fillColor=10,
              fillPattern=1),
            string="e"),
          Line(points=[-74,-38; -20,-10; 20,10; 70,36],     style(
              color=0,
              thickness=2,
              fillColor=10,
              fillPattern=1)),
          Text(
            extent=[22,68; 42,58],
            style(
              color=10,
              pattern=3,
              fillColor=10,
              fillPattern=1),
      string="Ron"),
          Text(
            extent=[-46,-6; -26,-16],
            style(
              color=10,
              pattern=3,
              fillColor=10,
              fillPattern=1),
      string="Goff"),
          Ellipse(extent=[-2,2; 2,-2],  style(
              color=0,
              rgbcolor={0,0,0},
              pattern=3,
              fillColor=0,
              rgbfillColor={0,0,0},
              fillPattern=1)),
          Text(
            extent=[-22,-50; 0,-58],
            style(
              color=10,
              pattern=3,
              fillColor=10,
              fillPattern=1),
            string="closed"),
          Text(
            extent=[34,18; 56,10],
            style(
              color=10,
              pattern=3,
              fillColor=10,
              fillPattern=1),
            string="open"),
          Text(
            extent=[0,0; 20,-10],
            style(
              color=10,
              pattern=3,
              fillColor=10,
              fillPattern=1),
            string="s=0"),
          Line(points=[-30,-74; -6,-16; 6,16; 26,76],       style(
              color=0,
              thickness=2,
              fillColor=10,
              fillPattern=1)),
          Text(
            extent=[12,38; 34,30],
            style(
              color=10,
              pattern=3,
              fillColor=10,
              fillPattern=1),
            string="closed"),
          Text(
            extent=[-48,-22; -26,-30],
            style(
              color=10,
              pattern=3,
              fillColor=10,
              fillPattern=1),
            string="open")), Icon(
             Text(
            extent=[-80,100; 40,-100],
            string="Sw",
            style(color=0)), Text(extent=[-100,104; 100,60],string="%name"),
          Text(
            extent=[28,-10; 80,-52],
            string="Leak",
            style(color=0, rgbcolor={0,0,0}))),
        Documentation(info="<html>
The leaking switch element is a passive one-port element with modulation.  It inherits the effort and flow variables from the passive OnePort.  If the modulating signal has a value of <b>true</b>, the switch is considered <b>open</b>.
<p>
All elements of the effort and flow vector are switched synchronously.
<p>
The causality of the leaking switch element is free.
</html>"));
    protected
      parameter Real RonVec[n] = if size(Ron,1) == n then Ron else ones(n)*Ron[1];
      parameter Real GoffVec[n] = if size(Goff,1) == n then Goff else ones(n)*Goff[1];

      Real s[n] "Curve parameter";
      Boolean open "Switch position";
    equation
      assert((size(Ron,1) == n) or (size(Ron,1) == 1),"Ron must be of length 1 or n");
      assert((size(Goff,1) == n) or (size(Goff,1) == 1),"Goff must be of length 1 or n");

      open =BooleanInPort1;

      for i in 1:n loop
        f[i] = s[i]*(if open then GoffVec[i] else 1);
        e[i] = s[i]*(if open then 1 else RonVec[i]);
      end for;
    end Sw2;

    model D "ideal bondgraphic diode"
            extends Interfaces.PassiveOnePort;
      annotation (Diagram(
          Line(points=[-80,0; 80,0],   style(color=10)),
          Polygon(points=[70,4; 80,0; 70,-4; 70,4],     style(color=10,
                fillColor=10)),
          Line(points=[0,80; 0,-80],   style(
              color=10,
              fillColor=10,
              fillPattern=1)),
          Polygon(points=[-4,70; 0,80; 4,70; -4,70],     style(
              color=10,
              fillColor=10,
              fillPattern=1)),
          Text(
            extent=[6,80; 16,70],
            style(
              color=10,
              fillColor=10,
              fillPattern=1),
            string="f"),
          Text(
            extent=[70,-4; 80,-14],
            style(
              color=10,
              fillColor=10,
              fillPattern=1),
            string="e"),
          Line(points=[-80,0; -20,0; 0,0; 0,66],            style(
              color=0,
              thickness=2,
              fillColor=10,
              fillPattern=1)),
          Line(points=[20,9; 20,0],   style(
              color=10,
              pattern=3,
              fillColor=10,
              fillPattern=1)),
          Ellipse(extent=[-2,2; 2,-2],  style(
              color=0,
              rgbcolor={0,0,0},
              pattern=3,
              fillColor=0,
              rgbfillColor={0,0,0},
              fillPattern=1)),
          Text(
            extent=[2,48; 36,38],
            style(
              color=10,
              pattern=3,
              fillColor=10,
              fillPattern=1),
            string="conducting"),
          Text(
            extent=[-54,-2; -24,-10],
            style(
              color=10,
              pattern=3,
              fillColor=10,
              fillPattern=1),
            string="blocking"),
          Text(
            extent=[0,10; 20,0],
            style(
              color=10,
              pattern=3,
              fillColor=10,
              fillPattern=1),
            string="s=0")), Icon(
             Text(
            extent=[-80,80; 82,-80],
            style(color=0),
            string="D"),     Text(extent=[-100,104; 100,60],string="%name")),
        Documentation(info="<html>
The ideal diode element is a passive OnePort element.  It inherits the effort and flow variables from the passive OnePort.  The ideal diode is a switch element with internal modulation.  If the modulating signal has a value of <b>true</b>, the diode is considered <b>blocking</b>.
<p>
In a the multibondgraphic extension of the classic diode, the flow vector is restricted to one side
of a n-1 dimensional hyperplane. This hyperplane is specified by its normal vector d.
The parameter vector d specifies the direction of the potentially arising effort.
<p>
The causality of the ideal diode element must be free, i.e., the ideal diode element must be placed inside an algebraic loop.  If the causality of the diode is not free, use the leaking diode model, <b>D2</b>, instead.
</html>"));
      parameter Real d[n] = ones(n) "direction of effort";
      final parameter Real eD[n] = d/sqrt(d*d);

    protected
      Real s "Curve parameter";
      Boolean blocking "Switch position";
      Real f_d;
      Real e_d;

    equation
      f_d = f*eD;
      e = e_d*eD;

      blocking = s > 0;
      f_d = if blocking then 0 else s;
      e_d = if blocking then s else 0;
    end D;

    model D2 "leaking bondgraphic diode"
            extends Interfaces.PassiveOnePort;
      annotation (Diagram(
          Line(points=[-80,0; 80,0],   style(color=10)),
          Polygon(points=[70,4; 80,0; 70,-4; 70,4],     style(color=10,
                fillColor=10)),
          Line(points=[0,80; 0,-80],   style(
              color=10,
              fillColor=10,
              fillPattern=1)),
          Polygon(points=[-4,70; 0,80; 4,70; -4,70],     style(
              color=10,
              fillColor=10,
              fillPattern=1)),
          Text(
            extent=[6,80; 16,70],
            style(
              color=10,
              fillColor=10,
              fillPattern=1),
            string="f"),
          Text(
            extent=[70,-4; 80,-14],
            style(
              color=10,
              fillColor=10,
              fillPattern=1),
            string="e"),
          Line(points=[-80,-40; -20,-10; 20,10; 40,70],     style(
              color=0,
              thickness=2,
              fillColor=10,
              fillPattern=1)),
          Line(points=[20,9; 20,0],   style(
              color=10,
              pattern=3,
              fillColor=10,
              fillPattern=1)),
          Text(
            extent=[12,-2; 32,-12],
            style(
              color=10,
              pattern=3,
              fillColor=10,
              fillPattern=1),
            string="e0"),
          Text(
            extent=[20,70; 40,60],
            style(
              color=10,
              pattern=3,
              fillColor=10,
              fillPattern=1),
      string="Ron"),
          Text(
            extent=[-20,10; 0,0],
            style(
              color=10,
              pattern=3,
              fillColor=10,
              fillPattern=1),
      string="Goff"),
          Ellipse(extent=[18,12; 22,8], style(
              color=0,
              rgbcolor={0,0,0},
              pattern=3,
              fillColor=0,
              rgbfillColor={0,0,0},
              fillPattern=1)),
          Text(
            extent=[32,38; 66,28],
            style(
              color=10,
              pattern=3,
              fillColor=10,
              fillPattern=1),
            string="conducting"),
          Text(
            extent=[-52,-28; -22,-36],
            style(
              color=10,
              pattern=3,
              fillColor=10,
              fillPattern=1),
            string="blocking"),
          Text(
            extent=[20,14; 40,4],
            style(
              color=10,
              pattern=3,
              fillColor=10,
              fillPattern=1),
            string="s=0")), Icon(
             Text(
            extent=[-108,80; 54,-80],
            style(color=0),
            string="D"),     Text(extent=[-100,104; 100,60],string="%name"),
             Text(
            extent=[10,-12; 80,-74],
            style(color=0),
            string="leak")),
        Documentation(info="<html>
The ideal diode element is a passive OnePort element.  It inherits the effort and flow variables from the passive OnePort.  The ideal diode is a switch element with internal modulation.  If the modulating signal has a value of <b>true</b>, the diode is considered <b>blocking</b>.
<p>
In a the multibondgraphic extension of the classic diode, the flow vector is restricted to one side
of a n-1 dimensional hyperplane. This hyperplane is specified by its normal vector d.
The parameter vector d specifies the direction of the potentially arising effort.
<p>
The causality of the leaking diode element is free.
</html>"));

      parameter Real d[n] = ones(n) "direction of effort";
      final parameter Real eD[n] = d/sqrt(d*d);

      parameter Real Ron(final min=0) = 1.E-5 "Closed switch resistance";
      parameter Real Goff(final min=0) = 1.E-5 "Opened switch conductance";
      parameter Real e0=0 "Avalanche breakdown effort";

    protected
      Real s "Curve parameter";
      Boolean blocking "Switch position";
      Real f_d;
      Real e_d;

    equation
        f_d = f*eD;
        e = e_d*eD;

        blocking = s > 0;
        f_d = s*(if blocking then Goff else 1)+ Goff*e0;
        e_d = s*(if blocking then 1 else Ron)+ e0;

    end D2;

    annotation (preferedView="info", Documentation(info="<html>
This package contains a collection of switching elements for the MultiBondLib.
<p>
Switches change their computational causality as a function of the switch position.  For this reason, switches must always be attached to acausal bonds.
<p>
The application of multiibondgraphic switches is barely meaningful.
One usually wishes to switch certain variables, not vectors of them.
Try to use the single bond variants if possible.
<hr> <p>
<b>References:</b> <p>
<ol>
<li> Cellier, F.E., M. Otter, and H. Elmqvist (1995), \"<a href=\"http://www.inf.ethz.ch/~fcellier/Publikationen/VarStruc.pdf\">Bond
     Graph Modeling of Variable Structure Systems</a>,\" <i>Proc. ICBGM'95, 2<sup>nd</sup> SCS Intl. Conf. on Bond Graph
     Modeling and Simulation</i>, Las Vegas, Nevada, pp. 49-55.
<li> Krebs, M. (1997), <i><a href=\"http://www.inf.ethz.ch/~fcellier/Publikationen/krebs_ms.pdf\">Modeling of Conditional
     Index Changes</a></i>, MS Thesis, Dept. of Electr. & Comp. Engr., University of Arizona, Tucson, AZ.
</ol>
</html>"));
  end Switches;

  package PlanarMechanics
    "A library for planar mechanics based upon MultiBond graphs"
    annotation(preferedView="info",Documentation(info="<html>
  This is the package for planar mechanical models. It is similar in its structure
  and way of usage to the <a href=\"Modelica://Modelica.Mechanics.MultiBody\">MultiBody</a> library.
<p>
<img src=\"../Images/PlanarLoop2.png\">
<img src=\"../Images/CraneCrab.png\">
</p>
<p>
This library offers an object-oriented solution for the modeling of planar mechanical systems.
Mechanical systems can be composed out of single ideal elements. They are separated according to their nature
into subpackages. These packages contain:
<ul>
<li> basic parts: like bodies or massless rods<br>
<li> joint elements <br>
<li> force elements <br>
</ul>
<p>
All the basic elements consist of multibond graphs.
<h3>Tutorial</h3>
The <a href=\"Modelica://Modelica.Mechanics.MultiBody\">MultiBody</a> library offers an excelent  <a href=\"Modelica://Modelica.Mechanics.MultiBody.UsersGuide\">tutorial</a>.
The models of this library can be treated essentially the same way.
<h3>Wrapped MultiBond Graphs</h3>
A look into the mechanical models reveals the corresponding multibond graphs.
The standard multibond for planar mechanical systems is of cardinality 3 and summarizes the translational and rotational domain. The first two bonds belong to the translational domain
whereas the third one is of the rotational domain. A multibond's effort vector is then {fx, fy, t}
and the corresponding flow vector: {vx,vy,w}. The composition is illustrated in the next figure.
<p>
<img src=\"../Images/PlanarMechBond.png\">
</p>
<p>
The processing of the positional variables is done by acausal signals.
All bondgraphic variables and the positional signals are resolved in the inertial system.
<p>
Two converter elements convert the bondgraphic variables to the variables of the main connectors and vice-versa. These elements create a shell for the multibond graph.
The figure below presents such a typical shell. The multibond graph is indicated by 1-junctions.
<p>
<img src=\"../Images/PlanarShell.png\">
</p>
<h3>Kinematic Loops</h3>
Kinematic loops are not problematic and can be modeled in a fully object-oriented way.
The appearing redundant statements are removed automatically.
Whenever loop structures occur, non-linear algebraic equations are present on \"position level\", but
usually they are solved fast and robustly and cause no further problems.
Also an element for the manual closure of kinematic loops is provided.
The application of this element is meaningful, if you want to \"cut\" the loop at a specific point.
(This might lead to better equations)
<h3>Efficency</h3>
The PlanarMechanics library offers a comprehensive set of ideal elements for planar mechanics.
Planar systems can be comfortably modeled and efficiently simulated.
<p>
The selection of the state variables is of major importance for the efficiency of the resulting simulation.
This selection is automatically done by Dymola. The resulting state variables are then always the states of a joint's relative position and motion. So each joint is declaring state variables, unless there is a kinematic loop.
<p>
The state selection can be improved or fully determined by the advanced parameter \"enforceStates\"
that is part of all joints. This helpful to avoid sets of dynamic state selection as they occur in kinematic loops.
<p>
The resulting systems of linear equations are usually small and can be solved
fast and accurately. Kinematic loops usually lead to a system of 2 non-linear equations.
<h3>Examples</h3>
A small set of examples demonstrate the usage of the PlanarMechanics library.
They are easy to understand and offer a good starting point to make yourself familiar with this
library.
</html>
"));
    model PlanarWorld
      "world model for planar mechanics.World coordinate system + gravity field + default animation definition"

      import SI = Modelica.SIunits;

      annotation (defaultComponentName="planarWorld",
        defaultComponentPrefixes="inner",
        Coordsys(
          extent=[-100, -100; 100, 100],
          grid=[2, 2],
          component=[20, 20]),
        Window(
          x=0.13,
          y=0.1,
          width=0.81,
          height=0.83),
        Icon(
          Rectangle(extent=[-100, 100; 100, -100], style(color=0, fillColor=7)),
          Line(points=[-100, -118; -100, 61], style(color=0, thickness=2)),
          Polygon(points=[-100, 100; -120, 60; -80, 60; -100, 100; -100, 100],
              style(
              color=0,
              fillColor=0,
              fillPattern=1)),
          Line(points=[-119, -100; 59, -100], style(color=0, thickness=2)),
          Polygon(points=[99, -100; 59, -80; 59, -120; 99, -100], style(
              color=0,
              fillColor=0,
              fillPattern=1)),
          Text(extent=[-140, 165; 140, 103], string="%name"),
          Text(
            extent=[95, -113; 144, -162],
            string="%label1",
            style(color=0)),
          Text(
            extent=[-170, 127; -119, 77],
            string="%label2",
            style(color=0)),
          Line(points=[-56, 78; -56, -26]),
          Polygon(points=[-68, -26; -56, -66; -44, -26; -68, -26], style(fillColor=
                  3)),
          Line(points=[2, 78; 2, -26]),
          Polygon(points=[-10, -26; 2, -66; 14, -26; -10, -26], style(fillColor=3)),
          Line(points=[66, 80; 66, -26]),
          Polygon(points=[54, -26; 66, -66; 78, -26; 54, -26], style(fillColor=3))),
        Diagram, preferedView="info",
        Documentation(info="<html>
This is the PlanarWorld model.
This model is a modified copy of the Modelica.Mechanics.MultiBody.World model.
<p>
This world model serves several purposes:
<ul>
<li>It visualizes the origin of the inertial system in the animation window.
<li>It sets the default parameters for the animation of all basic elements.
<li>It models a global gravity field. (either uniform gravity or point gravity)
</ul>
<p>
Since the gravity field function is required from all bodies with mass
and the default settings of animation properties are required
from nearly every component, exactly one instance of model PlanarWorld needs
to be present in every model on the top level. The basic declaration
needs to be:
</p>
<pre>
    <b>inner</b> PlanarMechanics.PlanarWorld planarWorld
</pre>
<p>
Note, it must be an <b>inner</b> declaration with instance name <b>planarWorld</b>
in order that this world object can be accessed from all objects in the
model. When dragging the \"PlanarWorld\" object from the package browser into
the diagram layer, this declaration is automatically generated
(this is defined via annotations in model PlanarWorld).
</p>
</html>"));

      parameter Boolean enableAnimation=true
        "= true, if animation of all components is enabled";
      parameter Boolean animateWorld=true
        "= true, if world coordinate system shall be visualized";
      parameter Boolean animateGravity=true
        "= true, if gravity field shall be visualized (acceleration vector or field center)";
      parameter Modelica.Mechanics.MultiBody.Types.AxisLabel label1="x"
        "Label of horizontal axis in icon";
      parameter Modelica.Mechanics.MultiBody.Types.AxisLabel label2="y"
        "Label of vertical axis in icon";
      parameter Modelica.Mechanics.MultiBody.Types.GravityTypes.Temp
        gravityType=
          Modelica.Mechanics.MultiBody.Types.GravityTypes.UniformGravity
        "Type of gravity field"                                                                                                     annotation (Evaluate=true);
      parameter SI.Acceleration g=9.81 " Constant gravity acceleration"
        annotation (Dialog(enable=gravityType==Modelica.Mechanics.MultiBody.Types.GravityTypes.UniformGravity));
      parameter Modelica.Mechanics.MultiBody.Types.Axis n={0,-1,0}
        " Direction of gravity resolved in world frame (gravity = g*n/length(n))"
        annotation (Evaluate=true, Dialog(enable=gravityType==Modelica.Mechanics.MultiBody.Types.GravityTypes.UniformGravity));
      parameter Real mue(
        unit="m3/s2",
        min=0) = 3.986e14
        " Gravity field constant (default = field constant of earth)"
        annotation (Dialog(enable=gravityType==Modelica.Mechanics.MultiBody.Types.GravityTypes.PointGravity));
      parameter SI.Distance axisLength=nominalLength/2
        "|Animation|if animateWorld = true| Length of world axes arrows";
      parameter SI.Distance axisDiameter=axisLength/defaultFrameDiameterFraction
        "|Animation|if animateWorld = true| Diameter of world axes arrows";
      parameter Boolean axisShowLabels=true
        "|Animation|if animateWorld = true| = true, if labels shall be shown";
      parameter Modelica.Mechanics.MultiBody.Types.Color axisColor_x=Modelica.Mechanics.MultiBody.Types.Defaults.
          FrameColor "|Animation|if animateWorld = true| Color of x-arrow";
      parameter Modelica.Mechanics.MultiBody.Types.Color axisColor_y=axisColor_x
        "|Animation|if animateWorld = true| Color of y-arrow";
      parameter Modelica.Mechanics.MultiBody.Types.Color axisColor_z=axisColor_x
        "|Animation|if animateWorld = true| Color of z-arrow";

      parameter SI.Position gravityArrowTail[3]={0,0,0}
        "|Animation|if animateGravity = true and gravityType = UniformGravity| Position vector from origin of world frame to arrow tail, resolved in world frame";
      parameter SI.Length gravityArrowLength=axisLength/2
        "|Animation|if animateGravity = true and gravityType = UniformGravity| Length of gravity arrow";
      parameter SI.Diameter gravityArrowDiameter=gravityArrowLength/
          defaultWidthFraction
        "|Animation|if animateGravity = true and gravityType = UniformGravity| Diameter of gravity arrow";
      parameter Modelica.Mechanics.MultiBody.Types.Color gravityArrowColor={0,230,0}
        "|Animation|if animateGravity = true and gravityType = UniformGravity| Color of gravity arrow";
      parameter SI.Diameter gravitySphereDiameter=12742000
        "|Animation|if animateGravity = true and gravityType = PointGravity| Diameter of sphere representing gravity center (default = mean diameter of earth)";
      parameter Modelica.Mechanics.MultiBody.Types.Color gravitySphereColor={0,230,0}
        "|Animation|if animateGravity = true and gravityType = PointGravity| Color of gravity sphere";

      parameter SI.Length nominalLength=1
        "|Defaults|| \"Nominal\" length of multi-body system";
      parameter SI.Length defaultAxisLength=nominalLength/5
        "|Defaults|| Default for length of a frame axis (but not world frame)";
      parameter SI.Length defaultJointLength=nominalLength/10
        "|Defaults|| Default for the fixed length of a shape representing a joint";
      parameter SI.Length defaultJointWidth=nominalLength/20
        "|Defaults|| Default for the fixed width of a shape representing a joint";
      parameter SI.Length defaultForceLength=nominalLength/10
        "|Defaults|| Default for the fixed length of a shape representing a force (e.g. damper)";
      parameter SI.Length defaultForceWidth=nominalLength/20
        "|Defaults|| Default for the fixed width of a shape represening a force (e.g. spring, bushing)";
      parameter SI.Length defaultBodyDiameter=nominalLength/9
        "|Defaults|| Default for diameter of sphere representing the center of mass of a body";
      parameter Real defaultWidthFraction=20
        "|Defaults|| Default for shape width as a fraction of shape length (e.g., for Parts.FixedTranslation)";
      parameter SI.Length defaultArrowDiameter=nominalLength/40
        "|Defaults|| Default for arrow diameter (e.g., of forces, torques, sensors)";
      parameter Real defaultFrameDiameterFraction=40
        "|Defaults|| Default for arrow diameter of a coordinate system as a fraction of axis length";

      parameter Modelica.Mechanics.MultiBody.Types.Color defaultJointColor={255,0,255}
        "|Defaults|| Default color of a joint element";
      parameter Modelica.Mechanics.MultiBody.Types.Color defaultBodyColor={0,64,255}
        "|Defaults|| Default color of a body element";
      parameter Modelica.Mechanics.MultiBody.Types.Color defaultRodColor={96,128,128}
        "|Defaults|| Default color of a rod element";
      parameter Modelica.Mechanics.MultiBody.Types.Color
        defaultForceElementColor =                                                {0,64,255}
        "|Defaults|| Default color of a rod element";

      /* The World object can only use the Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape model, but no
     other models in package Modelica.Mechanics.MultiBody.Visualizers, since the other models access
     data of the "outer Modelica.Mechanics.MultiBody.World world" object, i.e., there are
     mutually dependent classes. For this reason, the higher level visualization
     objects cannot be used.
  */
    protected
      parameter Integer ndim=if enableAnimation and animateWorld then 1 else 0;
      parameter Integer ndim2=if enableAnimation and animateWorld and
          axisShowLabels then 1 else 0;

      // Parameters to define axes
      parameter SI.Length headLength=min(axisLength, axisDiameter*Modelica.
          Mechanics.MultiBody.Types.Defaults.FrameHeadLengthFraction);
      parameter SI.Length headWidth=axisDiameter*Modelica.Mechanics.MultiBody.Types.
          Defaults.FrameHeadWidthFraction;
      parameter SI.Length lineLength=max(0, axisLength - headLength);
      parameter SI.Length lineWidth=axisDiameter;

      // Parameters to define axes labels
      parameter SI.Length scaledLabel=Modelica.Mechanics.MultiBody.Types.Defaults.
          FrameLabelHeightFraction                                           *
          axisDiameter;
      parameter SI.Length labelStart=1.05*axisLength;

      // x-axis
      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape x_arrowLine[ndim](
        each shapeType="cylinder",
        each length=lineLength,
        each width=lineWidth,
        each height=lineWidth,
        each lengthDirection={1,0,0},
        each widthDirection={0,1,0},
        each color=axisColor_x,
        each specularCoefficient=0);
      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape x_arrowHead[ndim](
        each shapeType="cone",
        each length=headLength,
        each width=headWidth,
        each height=headWidth,
        each lengthDirection={1,0,0},
        each widthDirection={0,1,0},
        each color=axisColor_x,
        each r={lineLength,0,0},
        each specularCoefficient=0);
      Modelica.Mechanics.MultiBody.Visualizers.Internal.Lines x_label[ndim2](
        each lines=scaledLabel*{[0, 0; 1, 1],[0, 1; 1, 0]},
        each diameter=axisDiameter,
        each color=axisColor_x,
        each r_lines={labelStart,0,0},
        each n_x={1,0,0},
        each n_y={0,1,0},
        each specularCoefficient=0);

      // y-axis
      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape y_arrowLine[ndim](
        each shapeType="cylinder",
        each length=lineLength,
        each width=lineWidth,
        each height=lineWidth,
        each lengthDirection={0,1,0},
        each widthDirection={1,0,0},
        each color=axisColor_y,
        each specularCoefficient=0);
      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape y_arrowHead[ndim](
        each shapeType="cone",
        each length=headLength,
        each width=headWidth,
        each height=headWidth,
        each lengthDirection={0,1,0},
        each widthDirection={1,0,0},
        each color=axisColor_y,
        each r={0,lineLength,0},
        each specularCoefficient=0);
      Modelica.Mechanics.MultiBody.Visualizers.Internal.Lines y_label[ndim2](
        each lines=scaledLabel*{[0, 0; 1, 1.5],[0, 1.5; 0.5, 0.75]},
        each diameter=axisDiameter,
        each color=axisColor_y,
        each r_lines={0,labelStart,0},
        each n_x={0,1,0},
        each n_y={-1,0,0},
        each specularCoefficient=0);

      // z-axis
      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape z_arrowLine[ndim](
        each shapeType="cylinder",
        each length=lineLength,
        each width=lineWidth,
        each height=lineWidth,
        each lengthDirection={0,0,1},
        each widthDirection={0,1,0},
        each color=axisColor_z,
        each specularCoefficient=0);
      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape z_arrowHead[ndim](
        each shapeType="cone",
        each length=headLength,
        each width=headWidth,
        each height=headWidth,
        each lengthDirection={0,0,1},
        each widthDirection={0,1,0},
        each color=axisColor_z,
        each r={0,0,lineLength},
        each specularCoefficient=0);
      Modelica.Mechanics.MultiBody.Visualizers.Internal.Lines z_label[ndim2](
        each lines=scaledLabel*{[0, 0; 1, 0],[0, 1; 1, 1],[0, 1; 1, 0]},
        each diameter=axisDiameter,
        each color=axisColor_z,
        each r_lines={0,0,labelStart},
        each n_x={0,0,1},
        each n_y={0,1,0},
        each specularCoefficient=0);

      // Uniform gravity visualization
      parameter Integer ndim_uniformGravity=if enableAnimation and animateGravity
           and gravityType == 1 then 1 else 0;
      parameter SI.Length gravityHeadLength=min(gravityArrowLength,
          gravityArrowDiameter*Modelica.Mechanics.MultiBody.Types.Defaults.
          ArrowHeadLengthFraction);
      parameter SI.Length gravityHeadWidth=gravityArrowDiameter*Modelica.Mechanics.
          MultiBody.Types.Defaults.ArrowHeadWidthFraction;
      parameter SI.Length gravityLineLength=max(0, gravityArrowLength -
          gravityHeadLength);
      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape gravityArrowLine[ndim_uniformGravity](
        each shapeType="cylinder",
        each length=gravityLineLength,
        each width=gravityArrowDiameter,
        each height=gravityArrowDiameter,
        each lengthDirection=n,
        each widthDirection={0,1,0},
        each color=gravityArrowColor,
        each r_shape=gravityArrowTail,
        each specularCoefficient=0);
      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape gravityArrowHead[ndim_uniformGravity](
        each shapeType="cone",
        each length=gravityHeadLength,
        each width=gravityHeadWidth,
        each height=gravityHeadWidth,
        each lengthDirection=n,
        each widthDirection={0,1,0},
        each color=gravityArrowColor,
        each r_shape=gravityArrowTail + Modelica.Mechanics.MultiBody.Frames.normalize(
                                                         n)*gravityLineLength,
        each specularCoefficient=0);

      // Point gravity visualization
      parameter Integer ndim_pointGravity=if enableAnimation and animateGravity
           and gravityType == 2 then 1 else 0;
      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape gravitySphere[ndim_pointGravity](
        each shapeType="sphere",
        each r_shape={-gravitySphereDiameter/2,0,0},
        each lengthDirection={1,0,0},
        each length=gravitySphereDiameter,
        each width=gravitySphereDiameter,
        each height=gravitySphereDiameter,
        each color=gravitySphereColor,
        each specularCoefficient=0);

      function gravityAcceleration = gravityAccelerationTypes (
          gravityType=gravityType,
          g=g*Modelica.Mechanics.MultiBody.Frames.normalize(
                                         n),
          mue=mue);

    protected
      function gravityAccelerationTypes
        "Gravity field acceleration depending on field type and position"

        extends Modelica.Icons.Function;
        input SI.Position r[3]
          "Position vector from world frame to actual point, resolved in world frame";
        input Integer gravityType "Type of gravity field";
        input SI.Acceleration g[3]
          "Constant gravity acceleration, resolved in world frame, if gravityType=1";
        input Real mue(unit="m3/s2")
          "Field constant of point gravity field, if gravityType=2";
        output SI.Acceleration gravity[3]
          "Gravity acceleration at point r, resolved in world frame";
      algorithm
        gravity := if gravityType == 1 then g else if gravityType == 2 then -(mue/(
          r*r))*(r/Modelica.Mechanics.MultiBody.Frames.length(r)) else zeros(3);
      end gravityAccelerationTypes;
    equation

      assert(Modelica.Mechanics.MultiBody.Frames.length(n) > 1.e-10,
        "Parameter n of World object is wrong (lenght(n) > 0 required)");
    end PlanarWorld;

    package Interfaces
      "connectors of the planar mechanic objects and converters to wrap the bond graphs"
    annotation (Icon(
          Text(
            extent=[-120,122; 120,73],
            style(color=1),
          string="%name"),
          Polygon(points=[-100,50; -80,70; 100,70; 80,50; -100,50],      style(
              color=58,
              fillColor=30,
              fillPattern=1)),
          Polygon(points=[100,70; 100,-80; 80,-100; 80,50; 100,70],      style(
              color=58,
              fillColor=30,
              fillPattern=1)),
          Rectangle(extent=[-100,-100; 80,50],   style(
              color=58,
              fillColor=30,
              fillPattern=1)),
          Text(
            extent=[-85,35; 65,-85],
            string="Library",
            style(color=58))), preferedView="info", Documentation(info="<html>
This package contains the basic connectors of the planar mechanical elements.
There are two connector types \"Frame_a\" and \"Frame_b\", but their only difference is the symbol and the name.
They both contain exactly the same variables and are therefore semantically identical.
<p>
The package contains two converter elements, that enable the comfortable wrapping of bondgraphic models.
</html>"));

      connector Frame_a "connector for the planar objects"
        extends Frame;

        annotation (defaultComponentName="frame_a",
                Diagram(Rectangle(extent=[100,100; 0,-100], style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=8,
                rgbfillColor={202,214,220})), Text(
              extent=[-100,-92; 100,-136],
              style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1),
              string="%name")),                Icon(Rectangle(extent=[100,100; 0,-100],
                style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=8,
                rgbfillColor={202,214,220})), Text(
              extent=[-100,-94; 100,-138],
              style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1),
              string="%name")),
          Documentation(info="<html>
This is a connector for planar mechanical components. It inherits all its variables
from the basic connector type 'Frame'.
</html>"));
      end Frame_a;

      connector Frame_b "connector for the planar objects"
        extends Frame;

        annotation (defaultComponentName="frame_b",
                Diagram(Rectangle(extent=[0,100; -100,-100], style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=7,
                rgbfillColor={255,255,255})), Text(
              extent=[-100,-92; 100,-136],
              style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1),
              string="%name")),                Icon(Rectangle(extent=[0,100; -100,
                  -100], style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=7,
                rgbfillColor={255,255,255})), Text(
              extent=[-100,-90; 100,-134],
              style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1),
              string="%name")),
          Documentation(info="<html>
This is a connector for planar mechanical components. It inherits all its variables
from the basic connector type 'Frame'.
</html>"));
      end Frame_b;

      connector Frame "connector for the planar objects"
        import SI = Modelica.SIunits;

          Potentials P;

          flow SI.Force fx "Cut-force";
          flow SI.Force fy "Cut-force";
          flow SI.Torque t "Cut-torque";
        annotation (Documentation(info="<html>
This is the basic planar mechanical connector type.
<p>
The connector defines the following potential variables:
<ul>
<li>translational positions:  real x, y;
<li>translational velocity: real vx, vy;
<li>orientation: real phi;
<li>angular velocity: real w;
</ul>
<p>
The connector defines the following flow variables:
<ul>
<li>force: real fx, fy;
<li>torque: real t;
</ul>
<p>
The potential variables are summarized in a record P.
So the variable name has to be preceeded by a P.
(I. e.: the gain access to the position: Type frame.P.x.)
<p>
All variables are resolved in the inertial system.
<p>
Do not use this connector directly! Use its two inheritors \"Frame_a\" and \"Frame_b\".
</html>"));
      end Frame;

      record Potentials
        "redundant part of the connector for the planar objects"
                        extends Modelica.Icons.Record;
        import SI = Modelica.SIunits;

          SI.Position x "Position";
          SI.Position y "Position";
          SI.Angle phi;

          SI.Velocity vx "Velocity";
          SI.Velocity vy "Velocity";
          SI.AngularVelocity w;

        encapsulated function equalityConstraint
          "Returns the constraint residues to express that two frames have the same orientation"

          import Modelica;
          import MultiBondLib.PlanarMechanics.Interfaces;
          extends Modelica.Icons.Function;
          input Interfaces.Potentials P1;
          input Interfaces.Potentials P2;
          output Real residue[3];
        algorithm
          residue := {P1.x-P2.x,P1.y-P2.y,P1.phi-P2.phi};
          annotation (Documentation(info="<html>
This function connects the two redundant sets of two planar mechanical connectors
in a non-redundant way. Instead of 6 equations only 3 equations are generated.
</html>"));
        end equalityConstraint;

        annotation (Documentation(info="<html>
This record contains all potential variables of the planar mechanical connector.
<p>
These potential variables form a redundant set of information. This is causing problems
by the closure of kinematic loops. To overcome these problems this record also contains
the function 'equalityConstraint'.
</html>"));
      end Potentials;

      model MBG2Mech "links the bond graph with the mechanic connector"
        import MultiBondLib;
        annotation (Icon(
            Line(points=[94,0; 80,0], style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[-80,-80; -80,80; 80,80; -80,-80], style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[-80,0; -94,0], style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[-80,-60; -100,-60], style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Text(
              extent=[-60,20; 20,60],
              style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1),
              string="MBG"),
            Line(points=[-60,0; 60,0; 40,20; 60,0; 40,-20], style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[-80,-80; 80,-80; 80,80; -80,-80], style(
                color=10,
                rgbcolor={135,135,135},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Text(
              extent=[-18,-72; 62,-18],
              style(
                color=10,
                rgbcolor={135,135,135},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1),
              string="M 2D")),    Diagram(
            Line(points=[-80,-80; -80,80; 80,80; -80,-80], style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[-80,0; -94,0], style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[-80,-60; -100,-60], style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Text(
              extent=[-60,20; 20,60],
              style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1),
              string="MBG"),
            Text(
              extent=[-20,-74; 60,-20],
              style(
                color=10,
                rgbcolor={135,135,135},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1),
              string="M 2D"),
            Line(points=[-60,0; 60,0; 40,20; 60,0; 40,-20], style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[-80,-80; 80,-80; 80,80; -80,-80], style(
                color=10,
                rgbcolor={135,135,135},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1))),
          Documentation(info="<html>
This is a converter element. The signals and bond connections of a bondgraphic model
are converted into variables of the mechanical connector. This element enables the wrapping of bondgraphic
models and is acausal.
</html>"));
        MultiBondLib.Interfaces.MultiBondCon MultiBondCon1(n=3)
          annotation (extent=[-110,-10; -90,10]);
        Frame_b frame_b annotation (extent=[80,-20; 100,20]);
        MultiBondLib.Interfaces.RealSignal q[3]
          annotation (extent=[-110,-70; -90,-50]);
      equation
        MultiBondCon1.e[1]*MultiBondCon1.d = frame_b.fx;
        MultiBondCon1.e[2]*MultiBondCon1.d = frame_b.fy;
        MultiBondCon1.e[3]*MultiBondCon1.d = frame_b.t;

        MultiBondCon1.f[1] = frame_b.P.vx;
        MultiBondCon1.f[2] = frame_b.P.vy;
        MultiBondCon1.f[3] = frame_b.P.w;

        q[1] = frame_b.P.x;
        q[2] = frame_b.P.y;
        q[3] = frame_b.P.phi;

      end MBG2Mech;

      model Mech2MBG "links the mechanic connector with the bond graph"
        import MultiBondLib;
        annotation (Icon(
            Line(points=[-80,-80; -80,80; 80,80; -80,-80], style(
                color=10,
                rgbcolor={135,135,135},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[-80,-80; 80,-80; 80,80; -80,-80], style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[94,0; 80,0], style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[94,-60; 80,-60], style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Text(
              extent=[-10,-60; 70,-20],
              style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1),
              string="MBG"),
            Line(points=[-60,0; 60,0; 40,20; 60,0; 40,-20], style(
                color=10,
                rgbcolor={135,135,135},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Text(
              extent=[-64,4; 18,76],
              style(
                color=10,
                rgbcolor={135,135,135},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1),
              string="M 2D")),    Diagram(
            Line(points=[-80,-80; -80,80; 80,80; -80,-80], style(
                color=10,
                rgbcolor={135,135,135},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[-80,-80; 80,-80; 80,80; -80,-80], style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[94,0; 80,0], style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[100,-60; 80,-60], style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Text(
              extent=[-10,-60; 70,-20],
              style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1),
              string="MBG"),
            Text(
              extent=[-70,0; 12,72],
              style(
                color=10,
                rgbcolor={135,135,135},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1),
              string="M 2D"),
            Line(points=[-60,0; 60,0; 40,20; 60,0; 40,-20], style(
                color=10,
                rgbcolor={135,135,135},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1))),
          Documentation(info="<html>
This is a converter element. The signals and bond connections of a bondgraphic model
are converted into variables of the mechanical connector. This element enables the wrapping of bondgraphic
models and is acausal.
</html>"));
        Frame_a frame_a annotation (extent=[-100,-20; -80,20]);
        MultiBondLib.Interfaces.MultiBondCon MultiBondCon1(n=3)
          annotation (extent=[90,-10; 110,10]);
        MultiBondLib.Interfaces.RealSignal q[3] annotation (extent=[90,-70; 110,-50]);
      equation
        MultiBondCon1.e[1]*MultiBondCon1.d = frame_a.fx;
        MultiBondCon1.e[2]*MultiBondCon1.d = frame_a.fy;
        MultiBondCon1.e[3]*MultiBondCon1.d = frame_a.t;

        MultiBondCon1.f[1] = frame_a.P.vx;
        MultiBondCon1.f[2] = frame_a.P.vy;
        MultiBondCon1.f[3] = frame_a.P.w;

        q[1] = frame_a.P.x;
        q[2] = frame_a.P.y;
        q[3] = frame_a.P.phi;

      end Mech2MBG;

    end Interfaces;
  annotation (Icon(
        Text(
          extent=[-120,122; 120,73],
          style(color=1),
        string="%name"),
        Polygon(points=[-100,50; -80,70; 100,70; 80,50; -100,50],      style(
            color=42,
            fillColor=30,
            fillPattern=1)),
        Polygon(points=[100,70; 100,-80; 80,-100; 80,50; 100,70],      style(
            color=42,
            fillColor=30,
            fillPattern=1)),
        Rectangle(extent=[-100,-100; 80,50],   style(
            color=42,
            fillColor=30,
            fillPattern=1)),
        Text(
          extent=[-85,35; 65,-85],
          string="Library",
          style(color=42))));
    package AdditionalMBG
      "Additional multibondgraphic elements specific for planar mechanics"
      extends Modelica.Icons.Library;
      model prismaticTF "modulated transformer for a prismatic joint"
        extends MultiBondLib.Interfaces.TwoDiffPort(final nA=1,final nB=2);
        parameter Real d[2] =  {1,0}
                                    annotation(Evaluate=true);
        annotation (
          extent=[-10,-114; 10,-94],
          rotation=90,
          Diagram,
          Documentation(info="<html>
This is a modulated projective translational transformer.
<p>
This element is used to model a prismatic joint.
</html>"));
      public
        MultiBondLib.Interfaces.RealSignal phi
          annotation (extent=[-10,-110; 10,-90], rotation=90);
      equation
        fB[1] =  (cos(phi)*d[1] + sin(phi)*d[2])*fA[1];
        fB[2] = (-sin(phi)*d[1] + cos(phi)*d[2])*fA[1];
        eA[1] = (cos(phi)*d[1] + sin(phi)*d[2])*eB[1] + (-sin(phi)*d[1] + cos(phi)*d[2])*eB[2];

        annotation (Icon(
            Text(extent=[-74,92; 66,52], string="%name"),
            Text(extent=[-70,-50; 68,-84], string="prismatic"),
            Text(
              extent=[-86,80; 92,-74],
              style(color=0, fillColor=0),
              string="mTF")));
      end prismaticTF;

      model translationalTF
        "optionally modulated transformer for a translation"
        extends MultiBondLib.Interfaces.TwoPort(final n=3);
        parameter Real d[2] = {1,0} annotation(Evaluate=true);
        annotation (
          extent=[-10,-114; 10,-94],
          rotation=90,
          Diagram,
          Icon(
            Text(extent=[-74,90; 66,50], string="%name"),
            Text(
              extent=[-88,78; 92,-76],
              style(color=0, fillColor=0),
              string="mTF"),
            Text(extent=[-70,-48; 70,-88], string="translational")),
          Documentation(info="<html>
This is a modulated translational transformer. It couples the rotational domain with the translational domain. It is of fixed cardinality 3.
<p>
The vector <b>d</b> can be amplified by an optional real signal \"ampl\".
<p>
The angular velocity is then transformed along a vector <b>d</b>*ampl.
<b>d</b> can be set by a parameter and is resolved in the body system, which is specified by the
signal phi.
<p>
This element is used to model a fixed translation or a prismatic joint
</html>"));
        MultiBondLib.Interfaces.RealSignal phi
          annotation (extent=[-50,-110; -30,-90],rotation=90);
        MultiBondLib.Interfaces.RealSignal ampl
          annotation (extent=[30,-110; 50,-90],  rotation=90);
      equation
        if cardinality(ampl) == 0 then
          ampl = 1;
        end if;
        f2[1] = f1[1] + (-sin(phi)*d[1] + cos(phi)*d[2])*ampl*f1[3];
        f2[2] = f1[2] + (-cos(phi)*d[1] - sin(phi)*d[2])*ampl*f1[3];
        f2[3] = f1[3];

        e1[1] = e2[1];
        e1[2] = e2[2];
        e1[3] = e2[3]+ (-sin(phi)*d[1]+cos(phi)*d[2])*ampl*e2[1]+ (-cos(phi)*d[1]-sin(phi)*d[2])*ampl*e2[2];
        annotation (Icon(
            Text(extent=[-74,92; 66,52], string="%name"),
            Text(extent=[-70,-50; 70,-90], string="translational"),
            Text(
              extent=[-86,78; 92,-76],
              style(color=0, fillColor=0),
              string="mTF")));
      end translationalTF;

      model Translation "translates the position"

        annotation (Icon(
            Rectangle(extent=[-80,80; 80,-80], style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
                         Text(
              extent=[-80,-80; 80,80],
              style(color=3, rgbcolor={0,0,255}),
              string="Translation"),
            Line(points=[-40,92; -40,80], style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[40,92; 40,80], style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[-92,0; -80,0], style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[92,0; 80,0], style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1))),     Diagram,
          Documentation(info="<html>
This model implements a translation between the two positional signals q1 and q2.
<p>
The translation is specified by the parameter d, which is resolved in the body system specified by the signal
q1[3].
<p>
The translation can optionally be amplified by the signal ampl
<p>
The positonal signal can optionally be rotated by the angle phi of the corresponding signal.
</html>"));
        MultiBondLib.Interfaces.RealSignal q1[3]
          annotation (extent=[-110,-10; -90,10]);
        MultiBondLib.Interfaces.RealSignal ampl
          annotation (extent=[30,90; 50,110],    rotation=90);
        MultiBondLib.Interfaces.RealSignal q2[3]
          annotation (extent=[90,-10; 110,10]);
        MultiBondLib.Interfaces.RealSignal phi annotation (extent=[-50,90; -30,110]);

        parameter Real d[2] = {1,0} annotation(Evaluate=true);

      equation
        if cardinality(ampl) == 0 then
          ampl = 1;
        end if;
        if cardinality(phi) == 0 then
          phi = 0;
        end if;
        q2[1] = q1[1] + (cos(q1[3])*d[1] + sin(q1[3])*d[2])*ampl;
        q2[2] = q1[2] + (-sin(q1[3])*d[1] + cos(q1[3])*d[2])*ampl;
        q2[3] = q1[3]+phi;

      end Translation;

      annotation (preferedView="info",Documentation(info="<html>
This package contains additional multibondgraphic elements.
These elements are specific for planar mechanical bondgraphic models. This is why they are found here and not in the MultiBondLib.
<p>
Not all the elements are purely bondgraphic elements. One of them cares about the processing of the signals in the bondgraphic model.
</html>"));
    end AdditionalMBG;

    package Forces "force elements"
      extends Modelica.Icons.Library;
      model Damping "a linear damper element"
        Interfaces.Frame_a frame_a annotation (extent=[-120,-20; -100,20]);
        Interfaces.Frame_b frame_b annotation (extent=[100,-20; 120,20]);
        parameter Real d(
          final unit="N.s/m",
          final min=0) = 0 "Damping constant";

      protected
        inner Defaults MBG_defaults(n=3) annotation (extent=[-80,30; -60,50]);

        Interfaces.MBG2Mech MBG2Mech1 annotation (extent=[60,0; 80,20]);
        Interfaces.Mech2MBG Mech2MBG1 annotation (extent=[-80,0; -60,20]);
        annotation (Diagram, Icon(
            Text(
              extent=[-102,100; 98,48],
              string="%name",
              style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1)),
            Rectangle(extent=[-40,40; 20,-40], style(
                pattern=0,
                fillColor=30,
                rgbfillColor={215,215,215})),
            Line(points=[100,0; 0,0; 0,32; 0,-32], style(color=0, rgbcolor={0,0,0})),
            Line(points=[-100,0; -40,0; -40,40; 40,40], style(color=0, rgbcolor={0,0,
                    0})),
            Line(points=[-40,0; -40,-40; 42,-40], style(color=0, rgbcolor={0,0,0})),
            Text(
              extent=[-68,-50; -100,-20],
              string="a",
              style(
                color=9,
                rgbcolor={175,175,175},
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1)),
            Text(
              extent=[100,-50; 68,-20],
              style(
                color=9,
                rgbcolor={175,175,175},
                pattern=0,
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1),
              string="b"),
            Text(
              extent=[-100,-54; 100,-100],
              style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1),
              string="d=%d")),
          Documentation(info="<html>
This is the model of a linear damper element.
<p>
The damper generates a counteracting force that is proportional to the
relative velocity.
<p>
The damping coefficient can be set by the parameter d.
</html>"));

        Junctions.J0 J0_1(n=3) annotation (extent=[20,0; 40,20]);
        Bonds.MultiBond MultiBond1      annotation (extent=[0,0; 20,20]);
        Bonds.Utilities.MultiBondTail MultiBondTail1
                                           annotation (extent=[-60,0; 2,20]);
        Bonds.MultiBond MultiBond2      annotation (extent=[40,0; 60,20]);
        Bonds.MultiBond MultiBond3
          annotation (extent=[20,20; 40,40], rotation=90);
        Passive.R R1(n=3, R={d,d,0}) annotation (extent=[20,40; 40,60], rotation=90);

      equation
        connect(Mech2MBG1.frame_a, frame_a) annotation (points=[-79,10; -89.5,10;
              -89.5,0; -110,0], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(MBG2Mech1.frame_b, frame_b) annotation (points=[79,10; 91.5,10; 91.5,
              0; 110,0], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Mech2MBG1.MultiBondCon1, MultiBond1.MultiBondCon1)
          annotation (points=[-60,10; 0,10], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond1.MultiBondCon2, J0_1.MultiBondCon1)
          annotation (points=[20,10; 20,10], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond2.MultiBondCon1, J0_1.MultiBondCon2)
          annotation (points=[40,10; 40,10], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond2.MultiBondCon2, MBG2Mech1.MultiBondCon1)
          annotation (points=[60,10; 60,10], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond3.MultiBondCon1, J0_1.MultiBondCon4)
          annotation (points=[30,20; 30,20], style(color=71, rgbcolor={85,170,255}));
        connect(R1.MultiBondCon1, MultiBond3.MultiBondCon2)
          annotation (points=[30,40; 30,40], style(color=71, rgbcolor={85,170,255}));
      end Damping;

      model Spring "a linear spring element"
        import SI = Modelica.SIunits;
        import MB = Modelica.Mechanics.MultiBody;

        Interfaces.Frame_a frame_a annotation (extent=[-120,-20; -100,20]);
        Interfaces.Frame_b frame_b annotation (extent=[100,-20; 120,20]);

        parameter Boolean animation = true "animate spring";

        parameter Real c(
          final unit="N/m",
          final min=0) = 0 "Spring constant";

        parameter SI.Position s0 = 0 "rest length of spring";
        parameter SI.Position s_small = 1e-4
          "|Advanced||critical Spring length";

        parameter SI.Distance width=planarWorld.defaultForceWidth
          "|Animation|if animation = true| Width of spring";
        parameter SI.Distance coilWidth=width/5
          "|Animation|if animation = true| Width of spring coil";
        parameter Integer numberOfWindings=5
          "|Animation|if animation = true| Number of spring windings";
        parameter MB.Types.Color color=planarWorld.defaultForceElementColor
          "|Animation|if animation = true| Color of spring";

        SI.Position s;
        SI.Position sx;
        SI.Position sy;
        SI.Force fx;
        SI.Force fy;

      protected
        outer PlanarWorld planarWorld;

        inner Defaults MBG_defaults(n=3) annotation (extent=[-80,60; -60,80]);
        Interfaces.MBG2Mech MBG2Mech1 annotation (extent=[60,0; 80,20]);
        Interfaces.Mech2MBG Mech2MBG1 annotation (extent=[-80,0; -60,20]);
        annotation (Diagram(
            Rectangle(extent=[-40,-20; -20,-40], style(color=10, rgbcolor={135,
                    135,135})),
            Polygon(points=[-20,80; -20,60; 0,70; -20,80], style(
                color=10,
                rgbcolor={135,135,135},
                pattern=0)),
            Line(points=[-54,4; -44,4; -44,-26; -40,-26], style(color=10,
                  rgbcolor={135,135,135})),
            Line(points=[56,4; 52,4; 48,4; 48,-52; -44,-52; -44,-34; -40,-34], style(
                  color=10, rgbcolor={135,135,135})),
            Line(points=[-20,-30; -12,-30; -10,-30; -10,28; -32,28; -32,70; -20,70], style(
                  color=10, rgbcolor={135,135,135})),
            Line(points=[2,70; 26,70; 26,62], style(color=10, rgbcolor={135,135,
                    135})),
            Text(
              extent=[-20,60; 0,50],
              string="Gain=c",
              style(color=10, rgbcolor={135,135,135})),
            Text(
              extent=[-40,-26; -20,-36],
              string="Distance",
              style(color=10, rgbcolor={135,135,135}))),
                                   Icon(
            Line(points=[-100,0; -80,0; -40,40; 40,-40], style(color=0, rgbcolor={0,0,
                    0})),
            Line(points=[40,-40; 80,0; 100,0], style(color=0, rgbcolor={0,0,0})),
            Text(
              extent=[-68,-50; -100,-20],
              string="a",
              style(
                color=9,
                rgbcolor={175,175,175},
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1)),
            Text(
              extent=[100,-50; 68,-20],
              style(
                color=9,
                rgbcolor={175,175,175},
                pattern=0,
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1),
              string="b"),
            Text(
              extent=[-100,100; 100,48],
              string="%name",
              style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1)),
            Text(
              extent=[-100,-46; 100,-92],
              style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1),
              string="c=%c"),
            Ellipse(extent=[-10,10; 10,-10], style(
                pattern=0,
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1))),
          Documentation(info="<html>
This is the model of a linear spring.
<p>
<img src=\"../Images/Spring.png\">
</p>
<p>
The spring generates a counteracting force that is linear dependent on the positional shift.
<p>
The spring coefficient can be set by the parameter c. The rest lenght can be specified by the parameter s0.
<p>
A spring with a rest length s0 unequal to zero, has a stiff behavior if its length is approaching zero.
The parameter s_small in the advanced menu reduces this stiffness for spring lengths ranging from zero up to s_small.
<h3>Visualization</h3>
This element is visualized by a coil. Further specifications can be made by the parameters in the animation group.
</html>"));
        Junctions.J0 J0_1(n=3) annotation (extent=[20,0; 40,20]);
        Bonds.MultiBond MultiBond1      annotation (extent=[0,0; 20,20]);
        Bonds.Utilities.MultiBondTail MultiBondTail1
                                           annotation (extent=[-60,0; 2,20]);
        Bonds.MultiBond MultiBond2      annotation (extent=[40,0; 60,20]);
        Modelica.Blocks.Sources.Constant noTorque(k=0)
          annotation (extent=[80,60; 60,80]);
        Sources.mSe mSe1(n=3) annotation (extent=[20,40; 40,60], rotation=90);
        Bonds.MultiBond MultiBond3
          annotation (extent=[20,20; 40,40], rotation=270);

        parameter Integer ndim=if planarWorld.enableAnimation and animation then 1 else 0;
        MB.Visualizers.Advanced.Shape springShape[ndim](
          each shapeType="spring",
          each color=color,
          each length=s,
          each width=width,
          each height=coilWidth,
          each lengthDirection={-sx,-sy,0},
          each widthDirection={0,0,1},
          each r_shape={0,0,0},
          each r={Mech2MBG1.q[1],Mech2MBG1.q[2],0},
          each extra=numberOfWindings,
          each R=MB.Frames.planarRotation({0,0,-1},0,0));

      equation
        {sx,sy} = Mech2MBG1.q[1:2] - MBG2Mech1.q[1:2];
        s = sqrt((sx^2) + (sy^2));
        fx = if s >= s_small then c*sx - s0*c*(sx/s) else c*sx - s0*c*(sx/s_small);
        fy = if s >= s_small then c*sy - s0*c*(sy/s) else c*sy - s0*c*(sy/s_small);
        mSe1.s[1] = fx;
        mSe1.s[2] = fy;

        connect(Mech2MBG1.frame_a, frame_a) annotation (points=[-79,10; -89.5,10;
              -89.5,0; -110,0], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(MBG2Mech1.frame_b, frame_b) annotation (points=[79,10; 91.5,10; 91.5,
              0; 110,0], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Mech2MBG1.MultiBondCon1, MultiBond1.MultiBondCon1)
          annotation (points=[-60,10; 0,10], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond1.MultiBondCon2, J0_1.MultiBondCon1)
          annotation (points=[20,10; 20,10], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond2.MultiBondCon1, J0_1.MultiBondCon2)
          annotation (points=[40,10; 40,10], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond2.MultiBondCon2, MBG2Mech1.MultiBondCon1)
          annotation (points=[60,10; 60,10], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond3.MultiBondCon2, J0_1.MultiBondCon4) annotation (points=[30,20;
              30,20],     style(
            color=71,
            rgbcolor={85,170,255},
            pattern=0,
            fillColor=30,
            rgbfillColor={215,215,215},
            fillPattern=1));
        connect(mSe1.MultiBondCon1, MultiBond3.MultiBondCon1) annotation (points=[30,40;
              30,40],     style(
            color=71,
            rgbcolor={85,170,255},
            pattern=0,
            fillColor=30,
            rgbfillColor={215,215,215},
            fillPattern=1));
        connect(mSe1.s[3], noTorque.y)  annotation (points=[29.3333,59.8;
              29.3333,70; 59,70],
                      style(
            color=74,
            rgbcolor={0,0,127},
            pattern=0,
            fillColor=30,
            rgbfillColor={215,215,215},
            fillPattern=1));
      end Spring;
      annotation (preferedView="info",Documentation(info="<html>
This package contains force elements.
These elements cause a force to act on or between mechanical elements.
<p>
Elements of this package do not create rigid connections and therefore do not close
kinematic loops.
</html>"));
      model WorldForce "a linear damper element"
        Interfaces.Frame_b frame_b annotation (extent=[100,-20; 120,20]);
        parameter Real d(
          final unit="N.s/m",
          final min=0) = 0 "Damping constant";

        annotation (Diagram, Icon(
            Text(
              extent=[-102,100; 98,48],
              string="%name",
              style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1)),
            Polygon(points=[100,0; 22,60; 22,20; -66,20; -66,-20; 22,-20; 22,
                  -60; 100,0],
                style(
                color=58,
                rgbcolor={0,127,0},
                fillColor=2,
                rgbfillColor={0,255,0}))),
          Documentation(info="<html>
This element applies an artificially generated force on the connector.
<p>
The force vector has to be given by an 2-dim input signal and is resolved in the inertial system.
</html>"));

      public
        Modelica.Blocks.Interfaces.RealInput force[2]
          annotation (extent=[-112,-10; -92,10]);
      protected
        Interfaces.MBG2Mech MBG2Mech1 annotation (extent=[60,-10; 80,10]);
        Bonds.MultiBond MultiBond2      annotation (extent=[40,-10; 60,10]);
      public
        Sources.mSe mSe annotation (extent=[20,-10; 40,10], rotation=180);
      protected
        inner Defaults MBG_defaults(n=3) annotation (extent=[-68,-54; -48,-34]);
      public
        Modelica.Blocks.Sources.Constant Constant(k=0)
          annotation (extent=[-20,-40; 0,-20]);
      equation
        connect(MultiBond2.MultiBondCon2,MBG2Mech1. MultiBondCon1)
          annotation (points=[60,0; 60,0],   style(color=71, rgbcolor={85,170,255}));
        connect(MBG2Mech1.frame_b, frame_b) annotation (points=[79,0; 90,0; 90,
              0; 110,0], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(mSe.MultiBondCon1, MultiBond2.MultiBondCon1) annotation (points=[40,
              -1.22461e-015; 40,0],    style(color=71, rgbcolor={85,170,255}));
        connect(force, mSe.s[1:2]) annotation (points=[-102,0; -40.9,0; -40.9,
              1.22125e-015; 20.2,1.22125e-015], style(color=74, rgbcolor={0,0,
                127}));
        connect(Constant.y, mSe.s[3]) annotation (points=[1,-30; 10,-30; 10,
              1.22125e-015; 20.2,1.22125e-015], style(color=74, rgbcolor={0,0,
                127}));
      end WorldForce;

      model WorldTorque "a linear damper element"
        Interfaces.Frame_b frame_b annotation (extent=[100,-20; 120,20]);
        parameter Real d(
          final unit="N.s/m",
          final min=0) = 0 "Damping constant";

        annotation (Diagram, Icon(
            Text(
              extent=[-100,102; 100,50],
              string="%name",
              style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1)),
            Polygon(points=[100,0; 22,60; 22,20; -66,20; -66,-20; 22,-20; 22,
                  -60; 100,0],
                         style(
                color=58,
                rgbcolor={0,127,0},
                fillColor=60,
                rgbfillColor={170,255,170})),
            Polygon(points=[70,0; -8,60; -8,20; -66,20; -66,-20; -8,-20; -8,-60;
                  70,0],
                style(
                color=58,
                rgbcolor={0,127,0},
                fillColor=2,
                rgbfillColor={0,255,0}))),
          Documentation(info="<html>
This element applies an artificially generated torque on the connector.
<p>
The torque vector has to be given by a scalar input signal and is resolved in the inertial system.
</html>"));

      public
        Modelica.Blocks.Interfaces.RealInput torque
          annotation (extent=[-112,-10; -92,10]);
      protected
        Interfaces.MBG2Mech MBG2Mech1 annotation (extent=[60,-10; 80,10]);
        Bonds.MultiBond MultiBond2      annotation (extent=[40,-10; 60,10]);
      public
        Sources.mSe mSe annotation (extent=[20,-10; 40,10], rotation=180);
      protected
        inner Defaults MBG_defaults(n=3) annotation (extent=[-68,-34; -48,-14]);
      public
        Modelica.Blocks.Sources.Constant Constant[2](k={0,0})
          annotation (extent=[-40,20; -20,40]);
      equation
        connect(MultiBond2.MultiBondCon2,MBG2Mech1. MultiBondCon1)
          annotation (points=[60,0; 60,0],   style(color=71, rgbcolor={85,170,255}));
        connect(MBG2Mech1.frame_b, frame_b) annotation (points=[79,0; 90,0; 90,
              0; 110,0], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(mSe.MultiBondCon1, MultiBond2.MultiBondCon1) annotation (points=[40,
              -1.22461e-015; 40,0],    style(color=71, rgbcolor={85,170,255}));
        connect(torque, mSe.s[3]) annotation (points=[-102,0; -40.9,0; -40.9,
              1.22125e-015; 20.2,1.22125e-015], style(color=74, rgbcolor={0,0,
                127}));
        connect(Constant.y, mSe.s[1:2]) annotation (points=[-19,30; 0,30; 0,
              1.22125e-015; 20.2,1.22125e-015], style(color=74, rgbcolor={0,0,
                127}));
      end WorldTorque;

    end Forces;

    package Joints "joint elements"
        extends Modelica.Icons.Library;
      model Prismatic "prismatic joint (1 degree of freedom)"
        annotation (Icon(
               Text(
              extent=[-142,66; 147,105],
              style(color=0),
              string="n=%n"),  Text(extent=[-135,-107; 141,-50],   string="%name"),
            Rectangle(extent=[-100,-40; -30,51], style(
                pattern=0,
                fillColor=83,
                rgbfillColor={255,170,255})),
            Rectangle(extent=[-30,-20; 100,30], style(
                pattern=0,
                fillColor=83,
                rgbfillColor={255,170,255})),
            Text(
              extent=[60,22; 96,-3],
              string="b",
              style(color=10)),
            Rectangle(extent=[-30,30; 100,40],   style(
                pattern=0,
                fillColor=0,
                fillPattern=1)),
            Rectangle(extent=[-100,50; -30,60],   style(
                pattern=0,
                fillColor=0,
                fillPattern=1)),
            Text(
              extent=[-95,23; -60,1],
              string="a",
              style(color=10))), Diagram,
          Documentation(info="<html>
This is a prismatic joint. The two connected frames are allowed to shift in direction of the joint axis.
This joint defines one degree of freedom.
<p>
<img src=\"../Images/Prismatic.png\">
</p>
<h3>General parameter</h3>
The joint axis can be defined by the parameter n. n can be of arbitrary length, but it must not be zero.
<p>
The parameter s_offset defines an offset value for the joint length s.
<p>
The parameter animation toggles the visualization of the element.
<h3>Initialization</h3>
In general, you can specify...
<ul>
<li>...the initial joint length.
<li>...the initial joint velocity.
<li>...the initial joint acceleration.
</ul>
Which of these variables do effectively appear in the inital equations can be defined by the parameter initType.
<h3>Visualization</h3>
This element is visualized by box. The settings for width, height and color can be specified by the animation parameters.
<h3>Advanced settings</h3>
The activation of enforceStates enforces the joint to explicitely define integrators.
This parameter is useful to choose the state variables in a kinematic loop.
</html>"));
        import SI = Modelica.SIunits;
        import MB = Modelica.Mechanics.MultiBody;

        parameter Boolean animation = true "animate prismatic joint as box";

        parameter SI.Position n[2] = {1,0} "direction of the joint axis" annotation(Evaluate=true);
        parameter SI.Position s_offset=0
          "Relative distance offset (distance between frame_a and frame_b = s_offset + s)"
          annotation (Evaluate=false);
        final parameter SI.Position eD[2] = n/sqrt(n*n);

        parameter MB.Types.Init.Temp initType=MB.Types.Init.Free
          "|Initialization| Type of initialization (defines usage of start values below)";
        parameter Real s_start = 0 "|Initialization|initial length";
        parameter Real v_start = 0 "|Initialization|initial velocity";
        parameter Real a_start = 0 "|Initialization|initial acceleration";

        parameter SI.Distance boxWidth=planarWorld.defaultJointWidth
          "|Animation|if animation = true| Width of prismatic joint box";
        parameter SI.Distance boxHeight=boxWidth
          "|Animation|if animation = true| Height of prismatic joint box";
        parameter Modelica.Mechanics.MultiBody.Types.Color boxColor=planarWorld.defaultJointColor
          "|Animation|if animation = true| Color of prismatic joint box";

        parameter Boolean enforceStates =  false
          "|Advanced||enforce s and v as states";

        SI.Position s(stateSelect=if enforceStates then StateSelect.always else StateSelect.prefer)
          "length of prismatic joint";
        SI.Velocity v(stateSelect=if enforceStates then StateSelect.always else StateSelect.prefer)
          "velocity of prismatic joint";
        SI.Acceleration a "acceleration of prismatic joint";

        Interfaces.Frame_a frame_a annotation (extent=[-120,-20; -100,20]);
        Interfaces.Frame_b frame_b annotation (extent=[100,-20; 120,20]);

      protected
        outer PlanarWorld planarWorld;

        inner Defaults MBG_defaults(n=3) annotation (extent=[-80,60; -60,80]);

        Interfaces.Mech2MBG Mech2MBG1 annotation (extent=[-80,-20; -60,0]);
        Interfaces.MBG2Mech MBG2Mech1 annotation (extent=[60,-20; 80,0]);
        Junctions.J0Partial J0Partial1(
          n=3,
          nPartial=2,
          order={1,2,3}) annotation (extent=[20,-20; 40,0]);
        Bonds.MultiBond MultiBond1      annotation (extent=[40,-20; 60,0]);
        Bonds.MultiBond MultiBond2      annotation (extent=[0,-20; 20,0]);
        AdditionalMBG.Translation Translation1(d=eD)
                                       annotation (extent=[-40,-60; -20,-40]);
        Junctions.J1 J1_1(n=1)
                          annotation (extent=[20,60; 40,80]);
        Sources.Se Se1(e0={0}, n=1)
                       annotation (extent=[60,60; 80,80]);
        AdditionalMBG.prismaticTF prismaticTF1(d=eD)
          annotation (extent=[20,20; 40,40], rotation=-90);
        AdditionalMBG.translationalTF translationalTF1(d=eD)
                                               annotation (extent=[-20,0; 0,-20]);
        Bonds.MultiBond MultiBond3      annotation (extent=[-40,-20; -20,0]);
        Bonds.Utilities.MultiBondTail MultiBondTail1
                                           annotation (extent=[-60,-20; -38,0]);
        Bonds.MultiBond MultiBond4(n=1)
                                   annotation (extent=[60,60; 40,80]);
        Bonds.MultiBond MultiBond5(n=1)
                                   annotation (extent=[20,40; 40,60], rotation=270);
        Bonds.MultiBond MultiBond6(n=2)
          annotation (extent=[20,0; 40,20], rotation=-90);
        Bonds.MultiBond MultiBond7(n=1)
                                   annotation (extent=[20,60; 0,80]);
        Sensors.Dq Dq1(stateInitialCondition=false,q(stateSelect = StateSelect.never),
          n=1)         annotation (extent=[0,60; -20,80]);

        parameter Integer ndim=if planarWorld.enableAnimation and animation then 1 else
                  0;
        MB.Visualizers.Advanced.Shape sphere[ndim](
          each shapeType="box",
          each color=boxColor,
          each length=Dq1.q[1],
          each width=boxWidth,
          each height=boxHeight,
          each lengthDirection={eD[1],eD[2],0},
          each widthDirection={0,0,1},
          each r_shape={0,0,0},
          each r={Mech2MBG1.q[1],Mech2MBG1.q[2],0},
          each R=MB.Frames.planarRotation({0,0,-1},Mech2MBG1.q[3],0));

      initial equation
        if initType == MB.Types.Init.Position or initType == MB.Types.Init.
            PositionVelocity or initType == MB.Types.Init.PositionVelocityAcceleration then
          // Initialize positional variables
          s = s_start;
        end if;

        if initType == MB.Types.Init.PositionVelocity or initType == MB.Types.Init.
            PositionVelocityAcceleration or initType == MB.Types.Init.Velocity or
            initType == MB.Types.Init.VelocityAcceleration then
          // Initialize velocity variables
          v = v_start;
        end if;

        if initType == MB.Types.Init.VelocityAcceleration or initType == MB.Types.Init.
            PositionVelocityAcceleration then
          // Initialize acceleration variables
          a = a_start;
        end if;

        if initType == MB.Types.Init.SteadyState then
          v = 0;
          a = 0;
        end if;

      equation
        defineBranch(frame_a.P, frame_b.P);
        s = Dq1.q[1]-s_offset;
        v = J1_1.MultiBondCon1.f[1];
        a = der(v);
        connect(Mech2MBG1.frame_a, frame_a) annotation (points=[-79,-10; -90,-10; -90,
              0; -110,0], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=83,
            rgbfillColor={255,170,255},
            fillPattern=1));
        connect(MBG2Mech1.frame_b, frame_b) annotation (points=[79,-10; 90,-10; 90,0;
              110,0], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=83,
            rgbfillColor={255,170,255},
            fillPattern=1));
        connect(MultiBond2.MultiBondCon2, J0Partial1.MultiBondCon1) annotation (
            points=[20,-10; 20,-10], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=83,
            rgbfillColor={255,170,255},
            fillPattern=1));
        connect(MultiBond1.MultiBondCon1, J0Partial1.MultiBondCon2) annotation (
            points=[40,-10; 40,-9.9], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=83,
            rgbfillColor={255,170,255},
            fillPattern=1));
        connect(MultiBond1.MultiBondCon2, MBG2Mech1.MultiBondCon1) annotation (points=
             [60,-10; 60,-10], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=83,
            rgbfillColor={255,170,255},
            fillPattern=1));
        connect(translationalTF1.MultiBondCon2, MultiBond2.MultiBondCon1) annotation (
           points=[0,-10; 0,-10], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=83,
            rgbfillColor={255,170,255},
            fillPattern=1));
        connect(MultiBond3.MultiBondCon2, translationalTF1.MultiBondCon1) annotation (
           points=[-20,-10; -20,-10], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=83,
            rgbfillColor={255,170,255},
            fillPattern=1));
        connect(MultiBond3.MultiBondCon1, Mech2MBG1.MultiBondCon1) annotation (points=
             [-40,-10; -60,-10], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=83,
            rgbfillColor={255,170,255},
            fillPattern=1));
        connect(MultiBond6.MultiBondCon1, prismaticTF1.MultiBondConB) annotation (
            points=[30,20; 30,20], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=83,
            rgbfillColor={255,170,255},
            fillPattern=1));
        connect(MultiBond6.MultiBondCon2, J0Partial1.MultiBondCon3) annotation (
            points=[30,0; 30,0], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=83,
            rgbfillColor={255,170,255},
            fillPattern=1));
        connect(MultiBond4.MultiBondCon1, Se1.MultiBondCon1) annotation (points=[60,
              70; 60,70], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=83,
            rgbfillColor={255,170,255},
            fillPattern=1));
        connect(MultiBond4.MultiBondCon2, J1_1.MultiBondCon2) annotation (points=[40,
              70; 40,70], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=83,
            rgbfillColor={255,170,255},
            fillPattern=1));
        connect(MultiBond5.MultiBondCon1, J1_1.MultiBondCon3) annotation (points=[30,60;
              30,60],     style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=83,
            rgbfillColor={255,170,255},
            fillPattern=1));
        connect(MultiBond5.MultiBondCon2, prismaticTF1.MultiBondConA) annotation (
            points=[30,40; 30,40], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=83,
            rgbfillColor={255,170,255},
            fillPattern=1));
        connect(Dq1.q[1], translationalTF1.ampl) annotation (points=[-20,70; -34,70;
              -34,36; -6,36; -6,0],
                  style(
            color=3,
            rgbcolor={0,0,255},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(Dq1.q[1], Translation1.ampl) annotation (points=[-20,70; -34,70; -34,
              -30; -26,-30; -26,-40], style(
            color=3,
            rgbcolor={0,0,255},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(Mech2MBG1.q, Translation1.q1) annotation (points=[-60,-16; -52,-16;
              -52,-50; -40,-50], style(
            color=3,
            rgbcolor={0,0,255},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(Translation1.q2, MBG2Mech1.q) annotation (points=[-20,-50; 48,-50; 48,
              -16; 60,-16], style(
            color=3,
            rgbcolor={0,0,255},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(translationalTF1.phi, Mech2MBG1.q[3]) annotation (points=[-14,0;
              -14,10; -52,10; -52,-15.3333; -60,-15.3333],
                                                       style(
            color=3,
            rgbcolor={0,0,255},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(prismaticTF1.phi, Mech2MBG1.q[3]) annotation (points=[20,30;
              -52,30; -52,-15.3333; -60,-15.3333],
                                           style(
            color=3,
            rgbcolor={0,0,255},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(MultiBond7.MultiBondCon1, J1_1.MultiBondCon1)
          annotation (points=[20,70; 20,70], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond7.MultiBondCon2, Dq1.MultiBondCon1)
          annotation (points=[0,70; 0,70], style(color=71, rgbcolor={85,170,255}));
      end Prismatic;

      model ActuatedPrismatic "prismatic joint (1 degree of freedom)"
        annotation (Icon(
               Text(
              extent=[-142,-74; 147,-35],
              style(color=0),
              string="n=%n"),  Text(extent=[-135,-117; 141,-60],   string="%name"),
            Rectangle(extent=[-100,-40; -30,51], style(
                pattern=0,
                fillColor=83,
                rgbfillColor={255,170,255})),
            Rectangle(extent=[-30,-20; 100,30], style(
                pattern=0,
                fillColor=83,
                rgbfillColor={255,170,255})),
            Text(
              extent=[60,22; 96,-3],
              string="b",
              style(color=10)),
            Rectangle(extent=[-30,30; 100,40],   style(
                pattern=0,
                fillColor=0,
                fillPattern=1)),
            Rectangle(extent=[-100,50; -30,60],   style(
                pattern=0,
                fillColor=0,
                fillPattern=1)),
            Text(
              extent=[-95,23; -60,1],
              string="a",
              style(color=10)),
            Rectangle(extent=[80,40; 100,80],   style(
                pattern=0,
                fillColor=83,
                rgbfillColor={255,170,255}))),
                                 Diagram,
          Documentation(info="<html>
This is a prismatic joint. The two connected frames are allowed to shift in direction of the joint axis.
This joint defines one degree of freedom. <br>
This prismatic joint has two additional 1-dimensional mechanical flanges (flange \"axis\" represents the driving flange and
flange \"bearing\" represents the bearing) where it can be driven with elements of the
<a href=\"Modelica://BondLib.Mechanical.Translational\">BondLib.Mechanical.Translational</a> library.

<p>
<img src=\"../Images/Prismatic.png\">
</p>
<h3>General parameter</h3>
The joint axis can be defined by the parameter n. n can be of arbitrary length, but it must not be zero.
<p>
The parameter s_offset defines an offset value for the joint length s.
<p>
The parameter animation toggles the visualization of the element.
<h3>Initialization</h3>
In general, you can specify...
<ul>
<li>...the initial joint length.
<li>...the initial joint velocity.
<li>...the initial joint acceleration.
</ul>
Which of these variables do effectively appear in the inital equations can be defined by the parameter initType.
<h3>Visualization</h3>
This element is visualized by box. The settings for width, height and color can be specified by the animation parameters.
<h3>Advanced settings</h3>
The activation of enforceStates enforces the joint to explicitely define integrators.
This parameter is useful to choose the state variables in a kinematic loop.
</html>"));
        import SI = Modelica.SIunits;
        import MB = Modelica.Mechanics.MultiBody;

        parameter Boolean animation = true "animate prismatic joint as box";

        parameter SI.Position n[2] = {1,0} "direction of the joint axis" annotation(Evaluate=true);
        parameter SI.Position s_offset=0
          "Relative distance offset (distance between frame_a and frame_b = s_offset + s)"
          annotation (Evaluate=false);
        final parameter SI.Position eD[2] = n/sqrt(n*n);

        parameter MB.Types.Init.Temp initType=MB.Types.Init.Free
          "|Initialization| Type of initialization (defines usage of start values below)";
        parameter Real s_start = 0 "|Initialization|initial length";
        parameter Real v_start = 0 "|Initialization|initial velocity";
        parameter Real a_start = 0 "|Initialization|initial acceleration";

        parameter SI.Distance boxWidth=planarWorld.defaultJointWidth
          "|Animation|if animation = true| Width of prismatic joint box";
        parameter SI.Distance boxHeight=boxWidth
          "|Animation|if animation = true| Height of prismatic joint box";
        parameter Modelica.Mechanics.MultiBody.Types.Color boxColor=planarWorld.defaultJointColor
          "|Animation|if animation = true| Color of prismatic joint box";

        parameter Boolean enforceStates =  false
          "|Advanced||enforce s and v as states";

        SI.Position s(stateSelect=if enforceStates then StateSelect.always else StateSelect.prefer)
          "length of prismatic joint";
        SI.Velocity v(stateSelect=if enforceStates then StateSelect.always else StateSelect.prefer)
          "velocity of prismatic joint";
        SI.Acceleration a "acceleration of prismatic joint";

        Interfaces.Frame_a frame_a annotation (extent=[-120,-20; -100,20]);
        Interfaces.Frame_b frame_b annotation (extent=[100,-20; 120,20]);

      protected
        outer PlanarWorld planarWorld;

        inner Defaults MBG_defaults(n=3) annotation (extent=[-80,-100; -60,-80]);

        Interfaces.Mech2MBG Mech2MBG1 annotation (extent=[-80,-40; -60,-20]);
        Interfaces.MBG2Mech MBG2Mech1 annotation (extent=[60,-40; 80,-20]);
        Junctions.J0Partial J0Partial1(
          n=3,
          nPartial=2,
          order={1,2,3}) annotation (extent=[20,-40; 40,-20]);
        Bonds.MultiBond MultiBond1      annotation (extent=[40,-40; 60,-20]);
        Bonds.MultiBond MultiBond2      annotation (extent=[0,-40; 20,-20]);
        AdditionalMBG.Translation Translation1(d=eD)
                                       annotation (extent=[-30,-82; -10,-62]);
        Junctions.J1 J1_1(n=1)
                          annotation (extent=[20,30; 40,50]);
        AdditionalMBG.prismaticTF prismaticTF1(d=eD)
          annotation (extent=[20,0; 40,20],  rotation=-90);
        AdditionalMBG.translationalTF translationalTF1(d=eD)
                                               annotation (extent=[-40,-20; -20,
              -40]);
        Bonds.MultiBond MultiBond3      annotation (extent=[-60,-40; -40,-20]);
        Bonds.MultiBond MultiBond5(n=1)
                                   annotation (extent=[20,20; 40,30], rotation=270);
        Bonds.MultiBond MultiBond6(n=2)
          annotation (extent=[20,-20; 40,0],rotation=-90);
        Bonds.MultiBond MultiBond7(n=1)
                                   annotation (extent=[20,30; 0,50]);
        Sensors.Dq Dq1(stateInitialCondition=false,q(stateSelect = StateSelect.never),
          n=1)         annotation (extent=[0,30; -20,50]);

        parameter Integer ndim=if planarWorld.enableAnimation and animation then 1 else
                  0;
        MB.Visualizers.Advanced.Shape sphere[ndim](
          each shapeType="box",
          each color=boxColor,
          each length=Dq1.q[1],
          each width=boxWidth,
          each height=boxHeight,
          each lengthDirection={eD[1],eD[2],0},
          each widthDirection={0,0,1},
          each r_shape={0,0,0},
          each r={Mech2MBG1.q[1],Mech2MBG1.q[2],0},
          each R=MB.Frames.planarRotation({0,0,-1},Mech2MBG1.q[3],0));

      public
        BondLib.Mechanical.Translational.Interfaces.Tr2BG tr2BG
          annotation (extent=[-50,60; -30,80]);
        BondLib.Mechanical.Translational.Interfaces.BG2Tr bG2Tr
          annotation (extent=[48,76; 60,64]);
        BondLib.Bonds.Bond bond annotation (extent=[-10,60; -30,80], rotation=0);
        Modelica.Blocks.Sources.Constant Constant(k=0)
          annotation (extent=[-66,46; -56,56]);
        BondLib.Mechanical.Translational.Interfaces.Flange_a axis
          annotation (extent=[60,60; 80,80]);
        BondLib.Mechanical.Translational.Interfaces.Flange_b bearing
          annotation (extent=[-70,60; -50,80]);
      protected
        Bonds.Utilities.MultiBondTail MultiBondTail2
                                           annotation (extent=[-18,-40; 2,-20]);
        Bonds.Utilities.MultiBondTail MultiBondTail3
                                           annotation (extent=[20,50; 40,68],
            rotation=270);
        Bonds.Utilities.MultiBondTail MultiBondTail4
                                           annotation (extent=[30,60; 30,80]);
      public
        Compositions.FromMultiBond fromMultiBond
          annotation (extent=[30,60; 48,80]);
        BondLib.Sources.Sf sf(f0=0)
          annotation (extent=[-10,60; 10,80], rotation=0);
      initial equation
        if initType == MB.Types.Init.Position or initType == MB.Types.Init.
            PositionVelocity or initType == MB.Types.Init.PositionVelocityAcceleration then
          // Initialize positional variables
          s = s_start;
        end if;

        if initType == MB.Types.Init.PositionVelocity or initType == MB.Types.Init.
            PositionVelocityAcceleration or initType == MB.Types.Init.Velocity or
            initType == MB.Types.Init.VelocityAcceleration then
          // Initialize velocity variables
          v = v_start;
        end if;

        if initType == MB.Types.Init.VelocityAcceleration or initType == MB.Types.Init.
            PositionVelocityAcceleration then
          // Initialize acceleration variables
          a = a_start;
        end if;

        if initType == MB.Types.Init.SteadyState then
          v = 0;
          a = 0;
        end if;

      equation
        defineBranch(frame_a.P, frame_b.P);
        s = Dq1.q[1]-s_offset;
        v = J1_1.MultiBondCon1.f[1];
        a = der(v);
        connect(Mech2MBG1.frame_a, frame_a) annotation (points=[-79,-30; -90,
              -30; -90,0; -110,0],
                          style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=83,
            rgbfillColor={255,170,255},
            fillPattern=1));
        connect(MBG2Mech1.frame_b, frame_b) annotation (points=[79,-30; 90,-30;
              90,0; 110,0],
                      style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=83,
            rgbfillColor={255,170,255},
            fillPattern=1));
        connect(MultiBond2.MultiBondCon2, J0Partial1.MultiBondCon1) annotation (
            points=[20,-30; 20,-30], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=83,
            rgbfillColor={255,170,255},
            fillPattern=1));
        connect(MultiBond1.MultiBondCon1, J0Partial1.MultiBondCon2) annotation (
            points=[40,-30; 40,-29.9],style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=83,
            rgbfillColor={255,170,255},
            fillPattern=1));
        connect(MultiBond1.MultiBondCon2, MBG2Mech1.MultiBondCon1) annotation (points=[60,-30;
              60,-30],         style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=83,
            rgbfillColor={255,170,255},
            fillPattern=1));
        connect(translationalTF1.MultiBondCon2, MultiBond2.MultiBondCon1) annotation (
           points=[-20,-30; 0,-30],
                                  style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=83,
            rgbfillColor={255,170,255},
            fillPattern=1));
        connect(MultiBond3.MultiBondCon2, translationalTF1.MultiBondCon1) annotation (
           points=[-40,-30; -40,-30], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=83,
            rgbfillColor={255,170,255},
            fillPattern=1));
        connect(MultiBond3.MultiBondCon1, Mech2MBG1.MultiBondCon1) annotation (points=[-60,-30;
              -60,-30],          style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=83,
            rgbfillColor={255,170,255},
            fillPattern=1));
        connect(MultiBond6.MultiBondCon1, prismaticTF1.MultiBondConB) annotation (
            points=[30,0; 30,0],   style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=83,
            rgbfillColor={255,170,255},
            fillPattern=1));
        connect(MultiBond6.MultiBondCon2, J0Partial1.MultiBondCon3) annotation (
            points=[30,-20; 30,-20],
                                 style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=83,
            rgbfillColor={255,170,255},
            fillPattern=1));
        connect(MultiBond5.MultiBondCon2, prismaticTF1.MultiBondConA) annotation (
            points=[30,20; 30,20], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=83,
            rgbfillColor={255,170,255},
            fillPattern=1));
        connect(Dq1.q[1], translationalTF1.ampl) annotation (points=[-20,40;
              -20,20; -26,20; -26,-20],
                  style(
            color=3,
            rgbcolor={0,0,255},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(Dq1.q[1], Translation1.ampl) annotation (points=[-20,40; -20,20;
              -16,20; -16,-62],       style(
            color=3,
            rgbcolor={0,0,255},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(Mech2MBG1.q, Translation1.q1) annotation (points=[-60,-36; -52,
              -36; -52,-72; -30,-72],
                                 style(
            color=3,
            rgbcolor={0,0,255},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(Translation1.q2, MBG2Mech1.q) annotation (points=[-10,-72; 48,
              -72; 48,-36; 60,-36],
                            style(
            color=3,
            rgbcolor={0,0,255},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(translationalTF1.phi, Mech2MBG1.q[3]) annotation (points=[-34,-20;
              -34,-10; -52,-10; -52,-35.3333; -60,-35.3333],
                                                       style(
            color=3,
            rgbcolor={0,0,255},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(prismaticTF1.phi, Mech2MBG1.q[3]) annotation (points=[20,10;
              -52,10; -52,-35.3333; -60,-35.3333],
                                           style(
            color=3,
            rgbcolor={0,0,255},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(MultiBond7.MultiBondCon1, J1_1.MultiBondCon1)
          annotation (points=[20,40; 20,40], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond7.MultiBondCon2, Dq1.MultiBondCon1)
          annotation (points=[0,40; 0,40], style(color=71, rgbcolor={85,170,255}));
        connect(tr2BG.Tr, bearing) annotation (points=[-50.1,69.9; -55.05,69.9; -55.05,70;
              -60,70], style(color=58, rgbcolor={0,127,0}));
        connect(bG2Tr.Tr, axis) annotation (points=[59.94,70.06; 59.95,70.06;
              59.95,70; 70,70], style(color=58, rgbcolor={0,127,0}));
        connect(Constant.y, tr2BG.s) annotation (points=[-55.5,51; -40,51; -40,
              60], style(color=74, rgbcolor={0,0,127}));
        connect(Dq1.q[1], bG2Tr.s) annotation (points=[-20,40; -20,52; 14,52;
              14,80; 54,80; 54,76], style(color=3, rgbcolor={0,0,255}));
        connect(bond.BondCon2, tr2BG.BondCon1) annotation (points=[-30,70; -30,
              70], style(color=8, rgbcolor={192,192,192}));
        connect(fromMultiBond.MultiBondCon1, J1_1.MultiBondCon4) annotation (
            points=[30,70; 30,50], style(color=71, rgbcolor={85,170,255}));
        connect(sf.BondCon1, bond.BondCon1) annotation (points=[-10,70; -10.2,
              70], style(color=8, rgbcolor={192,192,192}));
        connect(fromMultiBond.BondCon1, bG2Tr.BondCon1) annotation (points=[48,
              70; 48,70], style(color=8, rgbcolor={192,192,192}));
        connect(MultiBond5.MultiBondCon1, J1_1.MultiBondCon3) annotation (
            points=[30,30; 30,30], style(color=71, rgbcolor={85,170,255}));
      end ActuatedPrismatic;

      model Revolute "revolute joint (1-degree of freedom)"
        import SI = Modelica.SIunits;
        import MB = Modelica.Mechanics.MultiBody;
        import Cv = Modelica.SIunits.Conversions;

        annotation (Icon(
            Rectangle(extent=[-100,-60; -20,60], style(
                color=8,
                rgbcolor={192,192,192},
                gradient=2,
                fillColor=83,
                rgbfillColor={255,170,255})),
            Rectangle(extent=[20,-60; 100,60], style(
                color=8,
                rgbcolor={192,192,192},
                gradient=2,
                fillColor=83,
                rgbfillColor={255,170,255},
                fillPattern=1)),
            Rectangle(extent=[-20,10; 20,-10], style(
                color=0,
                rgbcolor={0,0,0},
                gradient=0,
                fillColor=83,
                rgbfillColor={255,170,255},
                fillPattern=1)),
            Text(
              extent=[-99,12; -63,-13],
              style(color=10),
              string="a"),
            Text(
              extent=[63,11; 99,-14],
              style(color=10),
              string="b"),
            Text(extent=[-112,114; 118,56], string="%name")), Diagram,
          Documentation(info="<html>
This is a revolute joint. The two connected frames are allowed to rotate around the joint axis normal to the plane. This joint defines one degree of freedom.
<p>
<img src=\"../Images/Revolute.png\">
</p>
<h3>General parameter</h3>
The parameter phi_offset defines an offset value for the revolute angle phi.
<p>
The parameter animation toggles the visualization of the element.
<h3>Initialization</h3>
In general, you can specify...
<ul>
<li>...the initial revolute angle.
<li>...the initial angular velocity.
<li>...the initial angular acceleration.
</ul>
Which of these variables do effectively appear in the inital equations can be defined by the parameter initType.
<h3>Visualization</h3>
This element is visualized by a cylinder along the rotation axis. The settings for length, diameter and color can be specified by the animation parameters.
<h3>Advanced settings</h3>
The activation of enforceStates enforces the joint to explicitely define integrators.
This parameter is useful to choose the state variables in a kinematic loop.
</html>"));

        parameter Boolean animation = true "animate revolute joint as cylinder";
        parameter Cv.NonSIunits.Angle_deg phi_offset = 0
          "phi + phi_offset = angle between frames";
        final parameter SI.Angle phi_offset_rad = Cv.from_deg(phi_offset);

        parameter MB.Types.Init.Temp initType=MB.Types.Init.Free
          "|Initialization| Type of initialization (defines usage of start values below)";
        parameter Cv.NonSIunits.Angle_deg phi_start = 0
          "|Initialization|initial angle";
        parameter Types.AngularVelocity_deg w_start = 0
          "|Initialization|initial angular velocity";
        parameter Types.AngularAcceleration_deg z_start = 0
          "|Initialization|initial angular acceleration";

        final parameter SI.Angle phi_start_rad = Cv.from_deg(phi_start)
          "initial cardan angles";
        final parameter SI.AngularVelocity w_start_rad = Cv.from_deg(w_start)
          "initial angular velocity";
        final parameter SI.AngularAcceleration z_start_rad = Cv.from_deg(z_start)
          "initial angular acceleration";

        parameter SI.Distance cylinderLength=planarWorld.defaultJointLength
          "|Animation|if animation = true| Length of cylinder representing the joint axis";
        parameter SI.Distance cylinderDiameter=planarWorld.defaultJointWidth
          "|Animation|if animation = true| Diameter of cylinder representing the joint axis";
        parameter Modelica.Mechanics.MultiBody.Types.Color cylinderColor=planarWorld.defaultJointColor
          "|Animation|if animation = true| Color of cylinder representing the joint axis";

        parameter Boolean enforceStates =  false
          "|Advanced||enforce phi and w as states";

        SI.Angle phi(stateSelect=if enforceStates then StateSelect.always else StateSelect.prefer)
          "revolute angle";
        SI.AngularVelocity w(stateSelect=if enforceStates then StateSelect.always else StateSelect.prefer)
          "revolute angular velocity";
        SI.AngularAcceleration z "revolute angular acceleration";

        Interfaces.Frame_a frame_a annotation (extent=[-120,-20; -100,20]);
        Interfaces.Frame_b frame_b annotation (extent=[100,-20; 120,20]);

      protected
        outer PlanarWorld planarWorld;

        inner Defaults MBG_defaults(n=3) annotation (extent=[-80,60; -60,80]);

        Interfaces.Mech2MBG Mech2MBG1 annotation (extent=[-80,-20; -60,0]);
        Interfaces.MBG2Mech MBG2Mech1 annotation (extent=[60,-20; 80,0]);
        Junctions.J0Partial J0Partial1(
          n=3,
          nPartial=1,
          order={3,1,2}) annotation (extent=[20,-20; 40,0]);
        Bonds.MultiBond MultiBond1      annotation (extent=[40,-20; 60,0]);
        Bonds.MultiBond MultiBond2      annotation (extent=[0,-20; 20,0]);
        Bonds.MultiBond MultiBond3(n=1)
          annotation (extent=[20,0; 40,20], rotation=-90);
        Bonds.MultiBond MultiBond5(n=1)
          annotation (extent=[20,20; 0,40],  rotation=0);
        Bonds.Utilities.MultiBondTail MultiBondTail1
                                           annotation (extent=[-60,-20; 2,0]);
        Junctions.J1 J1_1(n=1) annotation (extent=[20,20; 40,40]);
        Bonds.MultiBond MultiBond4(n=1)
          annotation (extent=[20,40; 40,60], rotation=-90);
        Sources.Se Se1(n=1, e0={0}) annotation (extent=[20,60; 40,80], rotation=90);
        Sensors.Dq Dq_phi(stateInitialCondition=false, n=1)
                          annotation (extent=[0,20; -20,40]);

        AdditionalMBG.Translation TranslationRevolute(d={0,0})
                                                 annotation (extent=[-20,-60; 0,-40]);

        parameter Integer ndim=if planarWorld.enableAnimation and animation then 1 else 0;
        MB.Visualizers.Advanced.Shape cylinder[ndim](
          each shapeType="cylinder",
          each color=cylinderColor,
          each length=cylinderLength,
          each width=cylinderDiameter,
          each height=cylinderDiameter,
          each lengthDirection={0,0,1},
          each widthDirection={0,1,0},
          each r_shape=-{0,0,1}*cylinderLength/2,
          each r={Mech2MBG1.q[1],Mech2MBG1.q[2],0},
          each R=MB.Frames.planarRotation({0,0,-1},Mech2MBG1.q[3],0));

      initial equation
        if initType == MB.Types.Init.Position or initType == MB.Types.Init.
            PositionVelocity or initType == MB.Types.Init.PositionVelocityAcceleration then
          // Initialize positional variables
          phi = phi_start_rad;
        end if;

        if initType == MB.Types.Init.PositionVelocity or initType == MB.Types.Init.
            PositionVelocityAcceleration or initType == MB.Types.Init.Velocity or
            initType == MB.Types.Init.VelocityAcceleration then
          // Initialize velocity variables
          w = w_start_rad;
        end if;

        if initType == MB.Types.Init.VelocityAcceleration or initType == MB.Types.Init.
            PositionVelocityAcceleration then
          // Initialize acceleration variables
          z = z_start_rad;
        end if;

        if initType == MB.Types.Init.SteadyState then
          w = 0;
          z = 0;
        end if;

      equation
        defineBranch(frame_a.P, frame_b.P);
        phi = Dq_phi.q[1]-phi_offset_rad;
        w = J1_1.MultiBondCon1.f[1];
        z = der(w);
        connect(MBG2Mech1.frame_b, frame_b) annotation (points=[79,-10; 90,-10; 90,0;
              110,0], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            gradient=2,
            fillColor=71,
            rgbfillColor={85,170,255}));
        connect(Mech2MBG1.frame_a, frame_a) annotation (points=[-79,-10; -90,-10; -90,
              0; -110,0], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            gradient=2,
            fillColor=71,
            rgbfillColor={85,170,255}));
        connect(MultiBond2.MultiBondCon2, J0Partial1.MultiBondCon1) annotation (
            points=[20,-10; 20,-10], style(
            color=71,
            rgbcolor={85,170,255},
            gradient=2,
            fillColor=71,
            rgbfillColor={85,170,255}));
        connect(MultiBond1.MultiBondCon2, MBG2Mech1.MultiBondCon1) annotation (points=
             [60,-10; 60,-10], style(
            color=71,
            rgbcolor={85,170,255},
            gradient=2,
            fillColor=71,
            rgbfillColor={85,170,255}));
        connect(MultiBond1.MultiBondCon1, J0Partial1.MultiBondCon2) annotation (
            points=[40,-10; 40,-9.9], style(
            color=71,
            rgbcolor={85,170,255},
            gradient=2,
            fillColor=71,
            rgbfillColor={85,170,255}));
        connect(MultiBond2.MultiBondCon1, Mech2MBG1.MultiBondCon1) annotation (points=
             [0,-10; -60,-10], style(
            color=71,
            rgbcolor={85,170,255},
            gradient=2,
            fillColor=71,
            rgbfillColor={85,170,255}));
        connect(MultiBond3.MultiBondCon2, J0Partial1.MultiBondCon3) annotation (
            points=[30,0; 30,0], style(
            color=71,
            rgbcolor={85,170,255},
            gradient=2,
            fillColor=71,
            rgbfillColor={85,170,255}));
        connect(J1_1.MultiBondCon3, MultiBond3.MultiBondCon1) annotation (points=[30,
              20; 30,20], style(
            color=71,
            rgbcolor={85,170,255},
            gradient=2,
            fillColor=71,
            rgbfillColor={85,170,255}));
        connect(MultiBond4.MultiBondCon2, J1_1.MultiBondCon4) annotation (points=[30,
              40; 30,40], style(
            color=71,
            rgbcolor={85,170,255},
            gradient=2,
            fillColor=71,
            rgbfillColor={85,170,255}));
        connect(Se1.MultiBondCon1, MultiBond4.MultiBondCon1) annotation (points=[30,
              60; 30,60], style(
            color=71,
            rgbcolor={85,170,255},
            gradient=2,
            fillColor=71,
            rgbfillColor={85,170,255}));
        connect(Dq_phi.q[1], TranslationRevolute.phi) annotation (points=[-20,30; -26,
              30; -26,-32; -14,-32; -14,-40],
                            style(
            color=3,
            rgbcolor={0,0,255},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(Mech2MBG1.q, TranslationRevolute.q1) annotation (points=[-60,-16; -32,
              -16; -32,-50; -20,-50], style(
            color=3,
            rgbcolor={0,0,255},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(TranslationRevolute.q2, MBG2Mech1.q) annotation (points=[0,-50; 50,
              -50; 50,-16; 60,-16], style(
            color=3,
            rgbcolor={0,0,255},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(MultiBond5.MultiBondCon1, J1_1.MultiBondCon1)
          annotation (points=[20,30; 20,30], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond5.MultiBondCon2, Dq_phi.MultiBondCon1)
          annotation (points=[0,30; 0,30], style(color=71, rgbcolor={85,170,255}));
      end Revolute;

      model ActuatedRevolute "revolute joint (1-degree of freedom)"
        import SI = Modelica.SIunits;
        import MB = Modelica.Mechanics.MultiBody;
        import Cv = Modelica.SIunits.Conversions;

        annotation (Icon(
            Rectangle(extent=[-100,-60; -20,60], style(
                color=8,
                rgbcolor={192,192,192},
                gradient=2,
                fillColor=83,
                rgbfillColor={255,170,255})),
            Rectangle(extent=[40,-60; 100,60], style(
                color=8,
                rgbcolor={192,192,192},
                gradient=2,
                fillColor=83,
                rgbfillColor={255,170,255},
                fillPattern=1)),
            Rectangle(extent=[-20,10; 20,-10], style(
                color=0,
                rgbcolor={0,0,0},
                gradient=0,
                fillColor=83,
                rgbfillColor={255,170,255},
                fillPattern=1)),
            Text(
              extent=[-99,12; -63,-13],
              style(color=10),
              string="a"),
            Text(
              extent=[63,11; 99,-14],
              style(color=10),
              string="b"),
            Text(extent=[-112,-68; 118,-126],
                                            string="%name"),
            Rectangle(extent=[0,80; 20,40], style(
                color=8,
                rgbcolor={192,192,192},
                gradient=1,
                fillColor=83,
                rgbfillColor={255,170,255})),
            Polygon(points=[0,20; 20,20; 40,40; -20,40; 0,20], style(
                color=0,
                rgbcolor={0,0,0},
                fillColor=83,
                rgbfillColor={255,170,255})),
            Polygon(points=[20,20; 40,40; 40,-40; 20,-20; 20,20], style(
                color=0,
                rgbcolor={0,0,0},
                fillColor=83,
                rgbfillColor={255,170,255})),
            Line(points=[28,70; 60,70],   style(color=0)),
            Line(points=[28,80; 28,60],   style(color=0)),
            Line(points=[-12,80; -12,60],   style(color=0)),
            Line(points=[-12,70; -52,70],   style(color=0)),
            Line(points=[-52,60; -52,80],   style(color=0))), Diagram,
          Documentation(info="<html>
This is a revolute joint. The two connected frames are allowed to rotate around the joint axis.
This joint defines one degree of freedom. <br>
This revolute joint has two additional 1-dimensional mechanical flanges (flange \"axis\" represents the driving flange and
flange \"bearing\" represents the bearing) where it can be driven with elements of the
<a href=\"Modelica://BondLib.Mechanical.Rotational\">BondLib.Mechanical.Rotational</a> library.

<p>
<img src=\"../Images/Revolute.png\">
</p>
<h3>General parameter</h3>
The parameter phi_offset defines an offset value for the revolute angle phi.
<p>
The parameter animation toggles the visualization of the element.
<h3>Initialization</h3>
In general, you can specify...
<ul>
<li>...the initial revolute angle.
<li>...the initial angular velocity.
<li>...the initial angular acceleration.
</ul>
Which of these variables do effectively appear in the inital equations can be defined by the parameter initType.
<h3>Visualization</h3>
This element is visualized by a cylinder along the rotation axis. The settings for length, diameter and color can be specified by the animation parameters.
<h3>Advanced settings</h3>
The activation of enforceStates enforces the joint to explicitely define integrators.
This parameter is useful to choose the state variables in a kinematic loop.
</html>"));

        parameter Boolean animation = true "animate revolute joint as cylinder";
        parameter Cv.NonSIunits.Angle_deg phi_offset = 0
          "phi + phi_offset = angle between frames";
        final parameter SI.Angle phi_offset_rad = Cv.from_deg(phi_offset);

        parameter MB.Types.Init.Temp initType=MB.Types.Init.Free
          "|Initialization| Type of initialization (defines usage of start values below)";
        parameter Cv.NonSIunits.Angle_deg phi_start = 0
          "|Initialization|initial angle";
        parameter Types.AngularVelocity_deg w_start = 0
          "|Initialization|initial angular velocity";
        parameter Types.AngularAcceleration_deg z_start = 0
          "|Initialization|initial angular acceleration";

        final parameter SI.Angle phi_start_rad = Cv.from_deg(phi_start)
          "initial cardan angles";
        final parameter SI.AngularVelocity w_start_rad = Cv.from_deg(w_start)
          "initial angular velocity";
        final parameter SI.AngularAcceleration z_start_rad = Cv.from_deg(z_start)
          "initial angular acceleration";

        parameter SI.Distance cylinderLength=planarWorld.defaultJointLength
          "|Animation|if animation = true| Length of cylinder representing the joint axis";
        parameter SI.Distance cylinderDiameter=planarWorld.defaultJointWidth
          "|Animation|if animation = true| Diameter of cylinder representing the joint axis";
        parameter Modelica.Mechanics.MultiBody.Types.Color cylinderColor=planarWorld.defaultJointColor
          "|Animation|if animation = true| Color of cylinder representing the joint axis";

        parameter Boolean enforceStates =  false
          "|Advanced||enforce phi and w as states";

        SI.Angle phi(stateSelect=if enforceStates then StateSelect.always else StateSelect.prefer)
          "revolute angle";
        SI.AngularVelocity w(stateSelect=if enforceStates then StateSelect.always else StateSelect.prefer)
          "revolute angular velocity";
        SI.AngularAcceleration z "revolute angular acceleration";

        Interfaces.Frame_a frame_a annotation (extent=[-120,-20; -100,20]);
        Interfaces.Frame_b frame_b annotation (extent=[100,-20; 120,20]);

      protected
        outer PlanarWorld planarWorld;

        inner Defaults MBG_defaults(n=3) annotation (extent=[-80,-80; -60,-60]);

        Interfaces.Mech2MBG Mech2MBG1 annotation (extent=[-80,-20; -60,0]);
        Interfaces.MBG2Mech MBG2Mech1 annotation (extent=[60,-20; 80,0]);
        Junctions.J0Partial J0Partial1(
          n=3,
          nPartial=1,
          order={3,1,2}) annotation (extent=[0,-20; 20,0]);
        Bonds.MultiBond MultiBond1      annotation (extent=[40,-20; 60,0]);
        Bonds.MultiBond MultiBond2      annotation (extent=[-20,-20; 0,0]);
        Bonds.MultiBond MultiBond3(n=1)
          annotation (extent=[0,0; 20,20],  rotation=-90);
        Bonds.MultiBond MultiBond5(n=1)
          annotation (extent=[20,20; 40,40], rotation=0);
        Bonds.Utilities.MultiBondTail MultiBondTail1
                                           annotation (extent=[-60,-20; -18,0]);
        Junctions.J1 J1_1(n=1) annotation (extent=[0,20; 20,40]);
        Sensors.Dq Dq_phi(stateInitialCondition=false, n=1)
                          annotation (extent=[40,20; 60,40]);

        AdditionalMBG.Translation TranslationRevolute(d={0,0})
                                                 annotation (extent=[20,-60; 40,
              -40]);

        parameter Integer ndim=if planarWorld.enableAnimation and animation then 1 else 0;
        MB.Visualizers.Advanced.Shape cylinder[ndim](
          each shapeType="cylinder",
          each color=cylinderColor,
          each length=cylinderLength,
          each width=cylinderDiameter,
          each height=cylinderDiameter,
          each lengthDirection={0,0,1},
          each widthDirection={0,1,0},
          each r_shape=-{0,0,1}*cylinderLength/2,
          each r={Mech2MBG1.q[1],Mech2MBG1.q[2],0},
          each R=MB.Frames.planarRotation({0,0,-1},Mech2MBG1.q[3],0));

      public
        BondLib.Mechanical.Rotational.Interfaces.Rot2BG rot2BG
          annotation (extent=[-60,80; -40,60], rotation=0);
        BondLib.Mechanical.Rotational.Interfaces.BG2Rot bG2Rot
          annotation (extent=[40,60; 60,80]);
        BondLib.Bonds.Bond bond annotation (extent=[-20,60; -40,80], rotation=0);
        Modelica.Blocks.Sources.Constant Constant(k=0)
          annotation (extent=[-24,84; -36,96]);
        BondLib.Mechanical.Rotational.Interfaces.Flange_a axis
          annotation (extent=[60,60; 80,80]);
        BondLib.Mechanical.Rotational.Interfaces.Flange_b bearing
          annotation (extent=[-80,60; -60,80]);
      protected
        Bonds.Utilities.MultiBondTail MultiBondTail2
                                           annotation (extent=[20,0; 42,-20]);
      public
        BondLib.Sources.Sf sf(f0=0)
          annotation (extent=[-20,60; 0,80], rotation=0);
        Compositions.FromMultiBond fromMultiBond
          annotation (extent=[20,60; 40,80]);
      protected
        Bonds.Utilities.MultiBondTail MultiBondTail3
                                           annotation (extent=[0,40; 20,68],
            rotation=270);
        Bonds.Utilities.MultiBondTail MultiBondTail4
                                           annotation (extent=[12,60; 24,80]);
      initial equation
        if initType == MB.Types.Init.Position or initType == MB.Types.Init.
            PositionVelocity or initType == MB.Types.Init.PositionVelocityAcceleration then
          // Initialize positional variables
          phi = phi_start_rad;
        end if;

        if initType == MB.Types.Init.PositionVelocity or initType == MB.Types.Init.
            PositionVelocityAcceleration or initType == MB.Types.Init.Velocity or
            initType == MB.Types.Init.VelocityAcceleration then
          // Initialize velocity variables
          w = w_start_rad;
        end if;

        if initType == MB.Types.Init.VelocityAcceleration or initType == MB.Types.Init.
            PositionVelocityAcceleration then
          // Initialize acceleration variables
          z = z_start_rad;
        end if;

        if initType == MB.Types.Init.SteadyState then
          w = 0;
          z = 0;
        end if;

      equation
        defineBranch(frame_a.P, frame_b.P);
        phi = Dq_phi.q[1]-phi_offset_rad;
        w = J1_1.MultiBondCon1.f[1];
        z = der(w);
        connect(MBG2Mech1.frame_b, frame_b) annotation (points=[79,-10; 90,-10; 90,0;
              110,0], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            gradient=2,
            fillColor=71,
            rgbfillColor={85,170,255}));
        connect(Mech2MBG1.frame_a, frame_a) annotation (points=[-79,-10; -90,-10; -90,
              0; -110,0], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            gradient=2,
            fillColor=71,
            rgbfillColor={85,170,255}));
        connect(MultiBond2.MultiBondCon2, J0Partial1.MultiBondCon1) annotation (
            points=[0,-10; 0,-10],   style(
            color=71,
            rgbcolor={85,170,255},
            gradient=2,
            fillColor=71,
            rgbfillColor={85,170,255}));
        connect(MultiBond1.MultiBondCon2, MBG2Mech1.MultiBondCon1) annotation (points=
             [60,-10; 60,-10], style(
            color=71,
            rgbcolor={85,170,255},
            gradient=2,
            fillColor=71,
            rgbfillColor={85,170,255}));
        connect(MultiBond1.MultiBondCon1, J0Partial1.MultiBondCon2) annotation (
            points=[40,-10; 40,-9.9; 20,-9.9],
                                      style(
            color=71,
            rgbcolor={85,170,255},
            gradient=2,
            fillColor=71,
            rgbfillColor={85,170,255}));
        connect(MultiBond2.MultiBondCon1, Mech2MBG1.MultiBondCon1) annotation (points=[-20,-10;
              -60,-10],        style(
            color=71,
            rgbcolor={85,170,255},
            gradient=2,
            fillColor=71,
            rgbfillColor={85,170,255}));
        connect(MultiBond3.MultiBondCon2, J0Partial1.MultiBondCon3) annotation (
            points=[10,0; 10,0], style(
            color=71,
            rgbcolor={85,170,255},
            gradient=2,
            fillColor=71,
            rgbfillColor={85,170,255}));
        connect(J1_1.MultiBondCon3, MultiBond3.MultiBondCon1) annotation (points=[10,20;
              10,20],     style(
            color=71,
            rgbcolor={85,170,255},
            gradient=2,
            fillColor=71,
            rgbfillColor={85,170,255}));
        connect(Dq_phi.q[1], TranslationRevolute.phi) annotation (points=[60,30;
              60,8; 26,8; 26,-40],
                            style(
            color=3,
            rgbcolor={0,0,255},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(Mech2MBG1.q, TranslationRevolute.q1) annotation (points=[-60,-16;
              -50,-16; -50,-50; 20,-50],
                                      style(
            color=3,
            rgbcolor={0,0,255},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(TranslationRevolute.q2, MBG2Mech1.q) annotation (points=[40,-50;
              50,-50; 50,-16; 60,-16],
                                    style(
            color=3,
            rgbcolor={0,0,255},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(rot2BG.Rot, bearing) annotation (points=[-60,70; -70,70], style(
              color=0, rgbcolor={0,0,0}));
        connect(bG2Rot.Rot, axis)
          annotation (points=[60,70; 70,70], style(color=0, rgbcolor={0,0,0}));
        connect(Dq_phi.q[1], bG2Rot.phi) annotation (points=[60,30; 60,60; 50,
              60], style(color=3, rgbcolor={0,0,255}));
        connect(Constant.y, rot2BG.phi) annotation (points=[-36.6,90; -44,90;
              -44,80; -50,80], style(color=74, rgbcolor={0,0,127}));
        connect(MultiBond5.MultiBondCon2, Dq_phi.MultiBondCon1) annotation (
            points=[40,30; 40,30], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond5.MultiBondCon1, J1_1.MultiBondCon2) annotation (
            points=[20,30; 20,30], style(color=71, rgbcolor={85,170,255}));
        connect(fromMultiBond.BondCon1, bG2Rot.BondCon1) annotation (points=[40,
              70; 40,70], style(color=8, rgbcolor={192,192,192}));
        connect(fromMultiBond.MultiBondCon1, J1_1.MultiBondCon4) annotation (
            points=[20,70; 10,70; 10,40], style(color=71, rgbcolor={85,170,255}));
        connect(bond.BondCon2, rot2BG.BondCon1) annotation (points=[-40,70; -40,
              70], style(color=8, rgbcolor={192,192,192}));
        connect(bond.BondCon1, sf.BondCon1) annotation (points=[-20.2,70; -20,
              70], style(color=8, rgbcolor={192,192,192}));
      end ActuatedRevolute;

      model FreeBodyMovement "joint with all degrees of freedom (3)"
        annotation (Diagram, Icon(
            Text(extent=[-118,132; 112,74], string="%name"),
            Ellipse(extent=[-70,70; 70,-70], style(
                color=5,
                rgbcolor={255,0,255},
                pattern=3)),
            Text(
              extent=[-90,-68; 96,-130],
              string="free",
              style(color=3, rgbcolor={0,0,255})),
            Line(points=[98,0; 60,0], style(color=5, rgbcolor={255,0,255})),
            Ellipse(extent=[-20,20; 20,-20], style(
                color=1,
                rgbcolor={255,0,0},
                fillColor=1,
                rgbfillColor={255,0,0},
                fillPattern=1)),
            Ellipse(extent=[-60,60; 60,-60], style(color=5, rgbcolor={255,0,255})),
            Ellipse(extent=[-50,50; 50,-50], style(color=79, rgbcolor={170,85,255}))),
          Documentation(info="<html>
This is an untypical joint, that does not restrict the movement of its connected element
and defines all 3 degrees of freedom. The usage of this joint is hardly necessary, because it is potentially avaiable in each body element.
<h3>General parameter</h3>
There are no general parameters
<h3>Initialization</h3>
In general, you can specify...
<ul>
<li>...the initial position and orientation.
<li>...the initial velocity and angular velocity.
<li>...the initial acceleration and angular acceleration.
</ul>
Which of these variables do effectively appear in the inital equations can be defined by the parameter initType.
<h3>Visualization</h3>
This element isn't visualized.
<h3>Advanced settings</h3>
The activation of enforceStates enforces the joint to explicitely define integrators.
This parameter is useful to choose the state variables in a kinematic loop.
</html>"));
        import SI = Modelica.SIunits;
        import MB = Modelica.Mechanics.MultiBody;

        parameter MB.Types.Init.Temp initType=MB.Types.Init.Free
          "|Initialization| Type of initialization (defines usage of start values below)";
        parameter SI.Position x_start[2] = {0,0}
          "|Initialization|initial position (x,y)";
        parameter SI.Velocity v_start[2] = {0,0}
          "|Initialization|initial velocity (vx, vy)";
        parameter SI.Acceleration a_start[2] = {0,0}
          "|Initialization|initial acceleration (ax, ay)";

        parameter SI.Angle phi_start = 0 "|Initialization|initial angle";
        parameter SI.AngularVelocity w_start = 0
          "|Initialization|initial ang. velocity ";
        parameter SI.AngularAcceleration z_start = 0
          "|Initialization|initial ang. acc.";

        parameter Boolean enforceStates =  false
          "|Advanced||enforce x,y,phi and vx, vy, w as states";

        Interfaces.Frame_b frame_b annotation (extent=[100,-20; 120,20]);
        SI.Position x(stateSelect=if enforceStates then StateSelect.always else StateSelect.prefer);
        SI.Position y(stateSelect=if enforceStates then StateSelect.always else StateSelect.prefer);
        SI.Angle phi(stateSelect=if enforceStates then StateSelect.always else StateSelect.prefer);

        SI.Velocity vx(stateSelect=if enforceStates then StateSelect.always else StateSelect.prefer);
        SI.Velocity vy(stateSelect=if enforceStates then StateSelect.always else StateSelect.prefer);
        SI.AngularVelocity w(stateSelect=if enforceStates then StateSelect.always else StateSelect.prefer);

        SI.Acceleration ax;
        SI.Acceleration ay;
        SI.AngularAcceleration z;

      protected
        inner Defaults MBG_defaults(n=3) annotation (extent=[-80,60; -60,80]);
      protected
        Interfaces.MBG2Mech MBG2Mech1 annotation (extent=[60,0; 80,20]);
        Bonds.MultiBond MultiBond1      annotation (extent=[40,0; 60,20]);
        Bonds.MultiBond MultiBond2      annotation (extent=[0,0; 20,20]);
        Sources.Se Se1(e0={0}, n=3) annotation (extent=[0,0; -20,20]);
        Sensors.Dq Dq1(n=3, q_start={0,0,0},
          stateInitialCondition=false)
          annotation (extent=[20,-40; 40,-20],
                                             rotation=270);
        Junctions.J1 J1_1      annotation (extent=[20,0; 40,20]);

        Bonds.MultiBond MultiBond3      annotation (extent=[20,-20; 40,0], rotation=
              270);

      initial equation
        if initType == MB.Types.Init.Position or initType == MB.Types.Init.
            PositionVelocity or initType == MB.Types.Init.PositionVelocityAcceleration then
          // Initialize positional variables
          {x,y} = x_start;
          phi = phi_start;
        end if;

        if initType == MB.Types.Init.PositionVelocity or initType == MB.Types.Init.
            PositionVelocityAcceleration or initType == MB.Types.Init.Velocity or
            initType == MB.Types.Init.VelocityAcceleration then
          // Initialize velocity variables
          {vx, vy} = v_start;
          w = w_start;
        end if;

        if initType == MB.Types.Init.VelocityAcceleration or initType == MB.Types.Init.
            PositionVelocityAcceleration then
          // Initialize acceleration variables
          {ax, ay} = a_start;
          z = z_start;
        end if;

        if initType == MB.Types.Init.SteadyState then
          {vx, vy} = zeros(2);
          {ax, ay} = zeros(2);
          w = 0;
          z = 0;
        end if;

      equation
        defineRoot(frame_b.P);
        {x,y,phi} = MBG2Mech1.q;
        {vx,vy,w} = MBG2Mech1.MultiBondCon1.f;
        {ax,ay,z} = der({vx,vy,w});
        connect(MBG2Mech1.frame_b, frame_b) annotation (points=[79,10; 94.5,10; 94.5,
              0; 110,0], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(MultiBond1.MultiBondCon2, MBG2Mech1.MultiBondCon1) annotation (points=[60,10;
              60,10],        style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(Se1.MultiBondCon1, MultiBond2.MultiBondCon1)
          annotation (points=[0,10; 0,10], style(color=71, rgbcolor={85,170,255}));
        connect(Dq1.q, MBG2Mech1.q) annotation (points=[30,-40; 30,-44; 50,-44;
              50,4; 60,4],
                     style(color=3, rgbcolor={0,0,255}));
        connect(J1_1.MultiBondCon2, MultiBond1.MultiBondCon1)
          annotation (points=[40,10; 40,10], style(color=71, rgbcolor={85,170,255}));
        connect(J1_1.MultiBondCon1, MultiBond2.MultiBondCon2)
          annotation (points=[20,10; 20,10], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond3.MultiBondCon1, J1_1.MultiBondCon3)
          annotation (points=[30,0; 30,0], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond3.MultiBondCon2, Dq1.MultiBondCon1) annotation (points=[30,-20;
              30,-20],
                    style(color=71, rgbcolor={85,170,255}));
      end FreeBodyMovement;

      annotation (preferedView="info",Documentation(info="<html>
This package contains models of joints.
<p>
Joints are massles objects, that define the relative movement between two rigid elements.
The number of degrees of freedom specifies how many variables are minimally needed to describe the relative
position. An object in a planar space can have up to 3 degrees of freedom.
<p>
Joints usually define integrators and the joint variables on positional and velocity level
become state variables of the system. Anyhow the integrators might be removed by the Pantelides algorithm, if the joint is placed in a kinematic loop.<br>
The number of degrees of freedom equals the number of potential state variables.
<p>
It is possible and common to create complex joints out of simple joints.
However, one has to pay attention that no singularities occur if two or more joints are connected (directly or through massless elements).
</html>"));

      model PotentialFBM "potential free-body movement joint"

        annotation (Diagram(
            Text(
              extent=[22,-20; 40,-38],
              style(
                color=83,
                rgbcolor={255,170,255},
                pattern=4,
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=7),
              string="Dq"),
            Text(
              extent=[20,-38; -6,-20],
              style(
                color=5,
                rgbcolor={255,0,255},
                thickness=4,
                fillColor=83,
                rgbfillColor={255,170,255},
                fillPattern=1),
              string="isRoot?"),
            Line(points=[30,-40; 30,-50; 54,-50; 54,4], style(
                color=5,
                rgbcolor={255,0,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=7))),
                             Icon(
            Text(extent=[-118,132; 112,74], string="%name"),
            Text(
              extent=[-90,-68; 96,-130],
              string="free",
              style(color=3, rgbcolor={0,0,255})),
            Ellipse(extent=[-68,70; 72,-70], style(
                color=5,
                rgbcolor={255,0,255},
                pattern=3)),
            Line(points=[100,0; 62,0],style(color=5, rgbcolor={255,0,255})),
            Ellipse(extent=[-18,20; 22,-20], style(
                color=1,
                rgbcolor={255,0,0},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Ellipse(extent=[-56,56; 58,-56], style(color=5, rgbcolor={255,0,255})),
            Ellipse(extent=[-40,40; 42,-42], style(color=79, rgbcolor={170,85,255}))),
          Documentation(info="<html>
This is a potential joint. It is in principle equal to the free body movement joint, but the differential
equations are only stated if necessary (i. e.: if the body movement can't be derived out of other joints).
This joint is part of every body element. There is actually no further usage of this element elsewhere.
<h3>General parameter</h3>
There are no general parameters
<h3>Initialization</h3>
In general, you can specify...
<ul>
<li>...the initial position and orientation.
<li>...the initial velocity and angular velocity.
<li>...the initial acceleration and angular acceleration.
</ul>
Which of these variables do effectively appear in the inital equations can be defined by the parameter initType.
<h3>Visualization</h3>
This element isn't visualized.
<h3>Advanced settings</h3>
The activation of enforceStates enforces the joint to explicitely define integrators.
This parameter is useful to choose the state variables in a kinematic loop.
</html>"));
        import SI = Modelica.SIunits;
        import MB = Modelica.Mechanics.MultiBody;

        parameter MB.Types.Init.Temp initType=MB.Types.Init.Free
          "|Initialization| Type of initialization (defines usage of start values below)";
        parameter SI.Position x_start[2] = {0,0}
          "|Initialization|initial position (x,y)";
        parameter SI.Velocity v_start[2] = {0,0}
          "|Initialization|initial velocity (vx, vy)";
        parameter SI.Acceleration a_start[2] = {0,0}
          "|Initialization|initial acceleration (ax, ay)";

        parameter SI.Angle phi_start = 0 "|Initialization|initial angle";
        parameter SI.AngularVelocity w_start = 0
          "|Initialization|initial ang. velocity ";
        parameter SI.AngularAcceleration z_start = 0
          "|Initialization|initial ang. acc.";

        parameter Boolean enforceStates =  false
          "|Advanced||enforce x,y,phi and vx, vy, w as states";

        Interfaces.Frame_b frame_b annotation (extent=[100,-20; 120,20]);
        SI.Position x(stateSelect=if enforceStates then StateSelect.always else StateSelect.prefer);
        SI.Position y(stateSelect=if enforceStates then StateSelect.always else StateSelect.prefer);
        SI.Angle phi(stateSelect=if enforceStates then StateSelect.always else StateSelect.prefer);

        SI.Velocity vx(stateSelect=if enforceStates then StateSelect.always else StateSelect.prefer);
        SI.Velocity vy(stateSelect=if enforceStates then StateSelect.always else StateSelect.prefer);
        SI.AngularVelocity w(stateSelect=if enforceStates then StateSelect.always else StateSelect.prefer);

        SI.Acceleration ax;
        SI.Acceleration ay;
        SI.AngularAcceleration z;

      protected
        inner Defaults MBG_defaults(n=3) annotation (extent=[80,30; 100,50]);
      protected
        Interfaces.MBG2Mech MBG2Mech1 annotation (extent=[60,0; 80,20]);
        Bonds.MultiBond MultiBond1      annotation (extent=[40,0; 60,20]);
        Bonds.MultiBond MultiBond2      annotation (extent=[0,0; 20,20]);
        Sources.Se Se1(e0={0}, n=3) annotation (extent=[0,0; -20,20]);
        Junctions.J1 J1_1      annotation (extent=[20,0; 40,20]);

      protected
        Bonds.MultiBond MultiBond3      annotation (extent=[20,-20; 40,0], rotation=
              270);

      initial equation
        if initType == MB.Types.Init.Position or initType == MB.Types.Init.
            PositionVelocity or initType == MB.Types.Init.PositionVelocityAcceleration then
          // Initialize positional variables
          {x,y} = x_start;
          phi = phi_start;
        end if;

        if initType == MB.Types.Init.PositionVelocity or initType == MB.Types.Init.
            PositionVelocityAcceleration or initType == MB.Types.Init.Velocity or
            initType == MB.Types.Init.VelocityAcceleration then
          // Initialize velocity variables
          {vx, vy} = v_start;
          w = w_start;
        end if;

        if initType == MB.Types.Init.VelocityAcceleration or initType == MB.Types.Init.
            PositionVelocityAcceleration then
          // Initialize acceleration variables
          {ax, ay} = a_start;
          z = z_start;
        end if;

        if initType == MB.Types.Init.SteadyState then
          {vx, vy} = zeros(2);
          {ax, ay} = zeros(2);
          w = 0;
          z = 0;
        end if;

      equation
        if enforceStates then
          defineRoot(frame_b.P);
        else
          definePotentialRoot(frame_b.P);
        end if;

        //activate differential equations for the root case
        if isRoot(frame_b.P) then
          vx = der(x);
          vy = der(y);
          w = der(phi);
        end if;

        MultiBond3.MultiBondCon2.e = zeros(3);

        {x,y,phi} = MBG2Mech1.q;
        {vx,vy,w} = MBG2Mech1.MultiBondCon1.f;
        {ax,ay,z} = der({vx,vy,w});
        connect(MBG2Mech1.frame_b, frame_b) annotation (points=[79,10; 94.5,10; 94.5,
              0; 110,0], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(MultiBond1.MultiBondCon2, MBG2Mech1.MultiBondCon1) annotation (points=[60,10;
              60,10],        style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(Se1.MultiBondCon1, MultiBond2.MultiBondCon1)
          annotation (points=[0,10; 0,10], style(color=71, rgbcolor={85,170,255}));
        connect(J1_1.MultiBondCon2, MultiBond1.MultiBondCon1)
          annotation (points=[40,10; 40,10], style(color=71, rgbcolor={85,170,255}));
        connect(J1_1.MultiBondCon1, MultiBond2.MultiBondCon2)
          annotation (points=[20,10; 20,10], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond3.MultiBondCon1, J1_1.MultiBondCon3)
          annotation (points=[30,0; 30,0], style(color=71, rgbcolor={85,170,255}));

      end PotentialFBM;

      model CloseLoop "element to close kinematik loops manualy"
        Interfaces.Frame_a frame_a annotation (extent=[-120,-20; -100,20]);
        Interfaces.Frame_b frame_b annotation (extent=[100,-20; 120,20]);
        annotation (Icon(
            Rectangle(extent=[-100,100; 100,-100], style(
                color=5,
                rgbcolor={255,0,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Ellipse(extent=[-72,74; 70,-70], style(
                color=5,
                rgbcolor={255,0,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Rectangle(extent=[-8,0; 74,-90], style(
                pattern=0,
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Text(
              extent=[-56,46; 54,-34],
              string="%name",
              style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Polygon(points=[70,-16; 64,4; 78,4; 70,-16],
                                                       style(
                color=5,
                rgbcolor={255,0,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1))), Documentation(info="<html>
This is the CloseLoop element.
<p>
You can cut a kinematic loop manually with this element . Just insert the element into the loop
at the point where you'd like to cut it.
<p>
This element connects its two connectors in a non-redundant way. It must not be used outside a kinematik loop.
</html>"));
      equation
        frame_a.P.x = frame_b.P.x;
        frame_a.P.y = frame_b.P.y;
        frame_a.P.phi = frame_b.P.phi;
        frame_a.fx = frame_b.fx;
        frame_a.fy = frame_b.fy;
        frame_a.t = frame_b.t;

      end CloseLoop;
    end Joints;

    package Parts "parts"
      extends Modelica.Icons.Library;
      model Body "comlete body model"

        annotation (Icon(
            Text(
              extent=[133,-101; -127,-51],
              style(color=0),
              string="m=%m"),
            Rectangle(extent=[-100,30; -3,-31], style(
                color=8,
                rgbcolor={192,192,192},
                gradient=2,
                fillColor=71,
                rgbfillColor={85,170,255})),
            Ellipse(extent=[-60,60; 60,-60], style(
                gradient=3,
                fillColor=71,
                rgbfillColor={85,170,255})),
            Text(extent=[-112,110; 118,52], string="%name")), Diagram(
            Line(points=[-56,4; -46,4; -46,-30; 0,-30], style(color=3, rgbcolor={0,0,
                    255})),
            Rectangle(extent=[0,-20; 20,-40], style(color=3, rgbcolor={0,0,255})),
            Text(
              extent=[2,-26; 18,-34],
              style(color=3, rgbcolor={0,0,255}),
              string="world"),
            Line(points=[20,-30; 32,-30; 32,10; 26,10], style(color=3, rgbcolor={0,0,
                    255}))),
          Documentation(info="<html>
This is the model of a body representing a point with given mass and inertia tensor.
<p>
If the body model is not connected to any joint, its movement is defined to be free.
Therefore this model includes a potential free-body movement joint and in consequences shares certain joint characterisitcs.
<p>
<img src=\"../Images/PlanarBody.png\">
</p>
<h3>General parameter</h3>
The mass and rotational inertia can be specified by the parameters m and J.
<p>
The parameter animation toggles the visualization
<h3>Initialization</h3>
In general, you can specify...
<ul>
<li>...the initial position and orientation.
<li>...the initial velocity and angular velocity.
<li>...the initial acceleration and angular acceleration.
</ul>
Which of these variables do effectively appear in the inital equations can be defined by the parameter initType.
<h3>Visualization</h3>
The element is visualized by a sphere. Diameter and color of the sphere can be specified by the animation parameters.
<h3>Advanced settings</h3>
The activation of enforceStates enforces the joint to explicitely define integrators.
This parameter is useful to choose the state variables in a kinematic loop.
</html>"));
        import SI = Modelica.SIunits;
        import MB = Modelica.Mechanics.MultiBody;

        parameter Boolean animation=true
          "= true, if animation shall be enabled";
        parameter SI.Mass m = 1 "Mass of body";
        parameter SI.Inertia J = 1 "Inertia of body";

        parameter MB.Types.Init.Temp initType=MB.Types.Init.Free
          "|Initialization||Type of initialization (defines usage of start values below)";
        parameter SI.Position x_start[2] = {0,0}
          "|Initialization||initial position (x,y)";
        parameter SI.Velocity v_start[2] = {0,0}
          "|Initialization||initial velocity (vx, vy)";
        parameter SI.Acceleration a_start[2] = {0,0}
          "|Initialization||initial acceleration (ax, ay)";
        parameter SI.Angle phi_start = 0 "|Initialization||initial angle";
        parameter SI.AngularVelocity w_start = 0
          "|Initialization||initial ang. velocity ";
        parameter SI.AngularAcceleration z_start = 0
          "|Initialization||initial ang. acc.";

        parameter SI.Diameter sphereDiameter=planarWorld.defaultBodyDiameter
          "|Animation|if animation = true| Diameter of sphere"
                               annotation (Dialog(
            tab="Animation",
            group="if animation = true",
            enable=animation));
        parameter MB.Types.Color sphereColor=planarWorld.defaultBodyColor
          "|Animation|if animation = true| Color of sphere"
                            annotation (Dialog(
            tab="Animation",
            group="if animation = true",
            enable=animation));

        parameter Boolean enforceStates =  false
          "|Advanced||enforce x,y,phi and vx, vy, w as states";

        Interfaces.Frame_a frame_a annotation (extent=[-120,-20; -100,20]);
      protected
        SI.Force fz "dummy force in z-direction";
        Interfaces.Mech2MBG Mech2MBG1 annotation (extent=[-80,0; -60,20]);
        Junctions.J1 J1_1      annotation (extent=[-40,0; -20,20]);
        Bonds.MultiBond MultiBond1      annotation (extent=[-60,0; -40,20]);
        Bonds.MultiBond MultiBond2
          annotation (extent=[-40,20; -20,40], rotation=90);
        Bonds.MultiBond MultiBond3      annotation (extent=[0,0; -20,20]);
        Passive.I mass(I={m,m,J})    annotation (extent=[-40,40; -20,60], rotation=90);

      protected
        outer PlanarWorld planarWorld;
      protected
        inner Defaults MBG_defaults(n=3) annotation (extent=[-80,40; -60,60]);

        parameter Integer ndim=if planarWorld.enableAnimation and animation then 1 else 0;
        MB.Visualizers.Advanced.Shape sphere[ndim](
          each shapeType="sphere",
          each color=sphereColor,
          each length=sphereDiameter,
          each width=sphereDiameter,
          each height=sphereDiameter,
          each lengthDirection={1,0,0},
          each widthDirection={0,1,0},
          each r_shape=-{1,0,0}*sphereDiameter/2,
          each r={Mech2MBG1.q[1],Mech2MBG1.q[2],0},
          each R=MB.Frames.planarRotation({0,0,-1},Mech2MBG1.q[3],0));

        Sources.mSe mSe1 annotation (extent=[0,0; 20,20]);

      public
        Joints.PotentialFBM PotFBM(
          initType=initType,
          x_start=x_start,
          v_start=v_start,
          a_start=a_start,
          phi_start=phi_start,
          w_start=w_start,
          z_start=z_start,
          enforceStates=enforceStates) annotation (extent=[-60,-40; -80,-20]);
      equation
        {mSe1.s[1],mSe1.s[2],fz} = m*planarWorld.gravityAcceleration({Mech2MBG1.q[1],Mech2MBG1.q[2],0});
        mSe1.s[3] = 0;

        connect(Mech2MBG1.frame_a, frame_a) annotation (points=[-79,10; -90,10; -90,0;
              -110,0], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(MultiBond1.MultiBondCon1, Mech2MBG1.MultiBondCon1) annotation (points=
             [-60,10; -60,10], style(
            color=71,
            rgbcolor={85,170,255},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(MultiBond1.MultiBondCon2, J1_1.MultiBondCon1) annotation (points=[-40,
              10; -40,10], style(
            color=71,
            rgbcolor={85,170,255},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(MultiBond3.MultiBondCon2, J1_1.MultiBondCon2) annotation (points=[-20,
              10; -20,10], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(MultiBond2.MultiBondCon1, J1_1.MultiBondCon4) annotation (points=[-30,
              20; -30,20], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(mass.MultiBondCon1, MultiBond2.MultiBondCon2)
                                                            annotation (points=[-30,
              40; -30,40], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(mSe1.MultiBondCon1, MultiBond3.MultiBondCon1)
          annotation (points=[0,10; 0,10], style(color=71, rgbcolor={85,170,255}));
        connect(PotFBM.frame_b, frame_a)        annotation (points=[-81,-30;
              -90,-30; -90,0; -110,0], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
      end Body;

      model SimpleBody "body element with mass and inertia"
        annotation (Icon(
            Text(
              extent=[133,-101; -127,-51],
              style(color=0),
              string="m=%m"),
            Rectangle(extent=[-100,30; -3,-31], style(
                color=8,
                rgbcolor={192,192,192},
                gradient=2,
                fillColor=71,
                rgbfillColor={85,170,255})),
            Ellipse(extent=[-60,60; 60,-60], style(
                gradient=3,
                fillColor=71,
                rgbfillColor={85,170,255})),
            Text(extent=[-112,110; 118,52], string="%name")), Diagram(
            Line(points=[-56,4; -46,4; -46,-30; 0,-30], style(color=3, rgbcolor={0,0,
                    255})),
            Rectangle(extent=[0,-20; 20,-40], style(color=3, rgbcolor={0,0,255})),
            Text(
              extent=[2,-26; 18,-34],
              style(color=3, rgbcolor={0,0,255}),
              string="world"),
            Line(points=[20,-30; 32,-30; 32,10; 26,10], style(color=3, rgbcolor={0,0,
                    255}))),
          Documentation(info="<html>
This is the model of a body representing a point with given mass and inertia .
<p>
This model does not contain a potential joint and therefore
needs to be connected to a joint or fixation element.
<p>
<img src=\"../Images/PlanarBody.png\">
</p>
<h3>General parameter</h3>
The mass and rotational inertia can be specified by the parameters m and J.
<p>
The parameter animation toggles the visualization
<h3>Visualization</h3>
The element is visualized by a sphere. Diameter and color of the sphere can be specified by the animation parameters.
</html>"));
        import SI = Modelica.SIunits;
        import MB = Modelica.Mechanics.MultiBody;

        parameter Boolean animation=true
          "= true, if animation shall be enabled";
        parameter SI.Mass m = 1 "Mass of body";
        parameter SI.Inertia J = 1 "Inertia of body";

        parameter SI.Diameter sphereDiameter=planarWorld.defaultBodyDiameter
          "|Animation|if animation = true| Diameter of sphere"
                               annotation (Dialog(
            tab="Animation",
            group="if animation = true",
            enable=animation));
        parameter MB.Types.Color sphereColor=planarWorld.defaultBodyColor
          "|Animation|if animation = true| Color of sphere"
                            annotation (Dialog(
            tab="Animation",
            group="if animation = true",
            enable=animation));

        Interfaces.Frame_a frame_a annotation (extent=[-120,-20; -100,20]);
      protected
        SI.Force fz "dummy force in z-direction";
        Interfaces.Mech2MBG Mech2MBG1 annotation (extent=[-80,0; -60,20]);
        Junctions.J1 J1_1      annotation (extent=[-40,0; -20,20]);
        Bonds.MultiBond MultiBond1      annotation (extent=[-60,0; -40,20]);
        Bonds.MultiBond MultiBond2
          annotation (extent=[-40,20; -20,40], rotation=90);
        Bonds.MultiBond MultiBond3      annotation (extent=[0,0; -20,20]);
        Passive.I I1(     I={m,m,J}) annotation (extent=[-40,40; -20,60], rotation=90);

      protected
        outer PlanarWorld planarWorld;
      protected
        inner Defaults MBG_defaults(n=3) annotation (extent=[-80,60; -60,80]);

        parameter Integer ndim=if planarWorld.enableAnimation and animation then 1 else 0;
        MB.Visualizers.Advanced.Shape sphere[ndim](
          each shapeType="sphere",
          each color=sphereColor,
          each length=sphereDiameter,
          each width=sphereDiameter,
          each height=sphereDiameter,
          each lengthDirection={1,0,0},
          each widthDirection={0,1,0},
          each r_shape=-{1,0,0}*sphereDiameter/2,
          each r={Mech2MBG1.q[1],Mech2MBG1.q[2],0},
          each R=MB.Frames.planarRotation({0,0,-1},Mech2MBG1.q[3],0));

        Sources.mSe mSe1 annotation (extent=[0,0; 20,20]);

      equation
        {mSe1.s[1],mSe1.s[2],fz} = m*planarWorld.gravityAcceleration({Mech2MBG1.q[1],Mech2MBG1.q[2],0});
        mSe1.s[3] = 0;

        connect(Mech2MBG1.frame_a, frame_a) annotation (points=[-79,10; -90,10; -90,0;
              -110,0], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(MultiBond1.MultiBondCon1, Mech2MBG1.MultiBondCon1) annotation (points=
             [-60,10; -60,10], style(
            color=71,
            rgbcolor={85,170,255},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(MultiBond1.MultiBondCon2, J1_1.MultiBondCon1) annotation (points=[-40,
              10; -40,10], style(
            color=71,
            rgbcolor={85,170,255},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(MultiBond3.MultiBondCon2, J1_1.MultiBondCon2) annotation (points=[-20,
              10; -20,10], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(MultiBond2.MultiBondCon1, J1_1.MultiBondCon4) annotation (points=[-30,
              20; -30,20], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(I1.MultiBondCon1, MultiBond2.MultiBondCon2) annotation (points=[-30,
              40; -30,40], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(mSe1.MultiBondCon1, MultiBond3.MultiBondCon1)
          annotation (points=[0,10; 0,10], style(color=71, rgbcolor={85,170,255}));
      end SimpleBody;

      model Fixed "wall element"
        annotation (Diagram, Icon(
            Line(points=[0,100; 0,-100],   style(color=0)),
            Line(points=[0,-80; -100,-20],   style(color=0)),
            Line(points=[0,-40; -100,20],   style(color=0)),
            Line(points=[0,0; -100,60],   style(color=0)),
            Line(points=[0,40; -100,100],   style(color=0)),
            Line(points=[0,0; 100,0],   style(color=0)),
            Text(extent=[-116,146; 114,88], string="%name"),
            Text(
              extent=[112,-130; -120,-90],
              style(color=0),
              string="r=%r"),
            Ellipse(extent=[-20,20; 20,-20], style(
                color=1,
                rgbcolor={255,0,0},
                fillColor=1,
                rgbfillColor={255,0,0},
                fillPattern=1))),
          Documentation(info="<html>
This is the model of a fixation point. It models a full translational and rotational fixation.
<h3>General parameter</h3>
The position and orientation of the fixation point can be specified by the parameters r and phi.
<h3>Visualization</h3>
The element isn't visualized.
</html>"));
        import SI = Modelica.SIunits;

        parameter SI.Position r[2] = {0,0} "Position";
        parameter SI.Angle phi = 0 "Angle";

      protected
        inner Defaults MBG_defaults(n=3) annotation (extent=[-80,60; -60,80]);
      protected
        Interfaces.MBG2Mech MBG2Mech1 annotation (extent=[60,0; 80,20]);
        Bonds.MultiBond MultiBond1      annotation (extent=[40,-2; 60,18]);
        Sources.Sf Sf1(n=3, f0={0}) annotation (extent=[40,0; 20,20]);
        Modelica.Blocks.Sources.Constant ConstantFixed[3](k={r[1],r[2],phi})
          annotation (extent=[20,-40; 40,-20]);
      public
        Interfaces.Frame_b frame_b annotation (extent=[100,-20; 120,20]);

      equation
        defineRoot(frame_b.P);
        connect(MBG2Mech1.frame_b, frame_b) annotation (points=[79,10; 94,10; 94,0;
              110,0], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(ConstantFixed.y, MBG2Mech1.q) annotation (points=[41,-30; 52,-30; 52,
              4; 60,4], style(color=74, rgbcolor={0,0,127}));
        connect(MultiBond1.MultiBondCon2, MBG2Mech1.MultiBondCon1)
          annotation (points=[60,8; 60,10],  style(color=71, rgbcolor={85,170,255}));
        connect(Sf1.MultiBondCon1, MultiBond1.MultiBondCon1)
          annotation (points=[40,10; 40,8],  style(color=71, rgbcolor={85,170,255}));
      end Fixed;

      model FixedTranslation "translational element"
        import SI = Modelica.SIunits;
        import MB = Modelica.Mechanics.MultiBody;
        parameter Boolean animation=true
          "= true, if animation shall be enabled";
        parameter SI.Position r[2] = {1,0}
          "translational vector from frame a to b"
                                           annotation(Evaluate=true);
        annotation (Icon(
            Rectangle(extent=[-100,10; 100,-1],  style(color=0, fillColor=0)),
            Text(
              extent=[-100,40; -60,10],
              style(color=10),
              string="a"),
            Text(
              extent=[60,40; 100,10],
              style(color=10),
              string="b"),
            Text(
              extent=[112,-70; -120,-30],
              style(color=0),
              string="r=%r"),
            Text(extent=[-114,100; 116,42], string="%name")), Diagram,
          Documentation(info="<html>
This is the model of a massless rod. It defines a fixed translation between the two connected frames.
<p>
<img src=\"../Images/PlanarTransl.png\">
</p>
<h3>General parameter</h3>
The rod can be specified by a parameter vector r.
r is resolved in the body system and points from frame a to frame b.
<h3>Visualization</h3>
The element is normally visualized as cylinder. Anyhow the visualization can be changed by the according parameters.
</html>"));

        parameter Modelica.Mechanics.MultiBody.Types.ShapeType shapeType="cylinder"
          "|Animation|if animation = true| Type of shape";
        parameter SI.Length length=sqrt(r*r)
          "|Animation|if animation = true| Length of shape";
        parameter SI.Distance width=length/planarWorld.defaultWidthFraction
          "|Animation|if animation = true| Width of shape";
        parameter SI.Distance height=width
          "|Animation|if animation = true| Height of shape.";
        parameter Real extra=0.0
          "|Animation|if animation = true| Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).";
        parameter Modelica.Mechanics.MultiBody.Types.Color color=planarWorld.defaultRodColor
          "|Animation|if animation = true| Color of shape";

        Interfaces.Frame_a frame_a annotation (extent=[-120,-20; -100,20]);
        Interfaces.Frame_b frame_b annotation (extent=[100,-20; 120,20]);
      protected
        outer PlanarWorld planarWorld;
        Interfaces.Mech2MBG Mech2MBG1 annotation (extent=[-80,0; -60,20]);
        Interfaces.MBG2Mech MBG2Mech1 annotation (extent=[60,0; 80,20]);
        Bonds.MultiBond MultiBond1      annotation (extent=[-60,0; -40,20]);
        Bonds.MultiBond MultiBond2      annotation (extent=[40,0; 60,20]);
        Bonds.Utilities.MultiBondTail MultiBondTail1
                                           annotation (extent=[-20,0; 44,20]);

        AdditionalMBG.Translation TranslationFixed(d=r)
                                          annotation (extent=[-40,-40; -20,-20]);
        AdditionalMBG.translationalTF translationalTF1(d=r)
                                              annotation (extent=[-40,0; -20,20]);

        parameter Integer ndim=if planarWorld.enableAnimation and animation then 1 else 0;
        MB.Visualizers.Advanced.Shape rod[ndim](
          each shapeType="cylinder",
          each color=color,
          each length=length,
          each width=width,
          each height=height,
          each lengthDirection={r[1],r[2],0},
          each widthDirection={0,0,1},
          each r_shape={0,0,0},
          each r={Mech2MBG1.q[1],Mech2MBG1.q[2],0},
          each R=MB.Frames.planarRotation({0,0,-1},Mech2MBG1.q[3],0));

        inner Defaults MBG_defaults(n=3) annotation (extent=[-80,60; -60,80]);
      equation
        defineBranch(frame_a.P, frame_b.P);
        connect(MBG2Mech1.frame_b, frame_b) annotation (points=[79,10; 94.5,10; 94.5,
              0; 110,0], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(Mech2MBG1.frame_a, frame_a) annotation (points=[-79,10; -89.5,10;
              -89.5,0; -110,0], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(MultiBond1.MultiBondCon1, Mech2MBG1.MultiBondCon1) annotation (points=
             [-60,10; -60,10], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(MultiBond2.MultiBondCon2, MBG2Mech1.MultiBondCon1) annotation (points=
             [60,10; 60,10], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(Mech2MBG1.q, TranslationFixed.q1) annotation (points=[-60,4; -50,4;
              -50,-30; -40,-30], style(
            color=3,
            rgbcolor={0,0,255},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(TranslationFixed.q2, MBG2Mech1.q) annotation (points=[-20,-30; 48,-30;
              48,4; 60,4], style(
            color=3,
            rgbcolor={0,0,255},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(translationalTF1.MultiBondCon1, MultiBond1.MultiBondCon2) annotation (
           points=[-40,10; -40,10], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(translationalTF1.MultiBondCon2, MultiBond2.MultiBondCon1) annotation (
           points=[-20,10; 40,10], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(translationalTF1.phi, Mech2MBG1.q[3]) annotation (points=[-34,0;
              -34,-12; -44,-12; -44,4.66667; -60,4.66667],
                                                       style(
            color=3,
            rgbcolor={0,0,255},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
      end FixedTranslation;
      annotation (preferedView="info", Documentation(info="<html>
This package contains completely rigid components.
<p>
These components either define a mass and inertia or they define a fixed relationship.
</html>"));
    end Parts;

    package Examples "examples for planar mechanics"
    annotation (Icon(
          Rectangle(extent=[-100,-100; 80,50],   style(
              color=0,
              fillColor=30,
              fillPattern=1)),
          Polygon(points=[100,70; 100,-80; 80,-100; 80,50; 100,70],      style(
              color=0,
              fillColor=30,
              fillPattern=1)),
          Text(
            extent=[-85,71; 65,-49],
            string="Sample",
            style(color=0)),
          Text(
            extent=[-97,23; 78,-98],
            string="Programs",
            style(color=0)),
          Text(
            extent=[-112,112; 128,63],
            string="%name",
            style(color=1)),
          Polygon(points=[-100,50; -80,70; 100,70; 80,50; -100,50], style(
            color=0,
            rgbcolor={0,0,0},
            fillColor=30,
            rgbfillColor={235,235,235},
            fillPattern=1))),preferedView="info", Documentation(info="<html>
This package contains various examples.
<p>
These examples demonstrate the usage of the PlanarMechanics library.
<p>
For all these examples the following simulation setup is proposed.
<ul>
<li>Start time: 0 seconds
<li>Stop time: 10 seconds
<li>Number of intervals: 2500
<li>Algorithm: DASSL
</ul>
Don't forget to open an animation window.
</html>"));
      model DoublePendulum "double pendulum"
                           extends Modelica.Icons.Example;
        PlanarMechanics.Parts.Fixed Fixed1 annotation (extent=[-100,60; -80,80]);
        PlanarMechanics.Joints.Revolute Revolute1(initType=Modelica.Mechanics.
              MultiBody.Types.Init.PositionVelocity)
                                                  annotation (extent=[-60,60; -40,80]);
        PlanarMechanics.Parts.FixedTranslation FixedTranslation1(r={2,2})
          annotation (extent=[-20,60; 0,80]);
        annotation (Diagram, preferedView="info", experiment(StopTime=10, NumberOfIntervals=2500),
      Documentation(info="<html>
This example presents a double pendulum.
<p>
<img src=\"../Images/DoublePendulum.png\">
</p>
<p>
The model is confronted with its equivalence of the Modelica.Mechanics.MultiBody library.
</html>"));
        inner Modelica.Mechanics.MultiBody.World world(nominalLength=5)
          annotation (extent=[-80,-80; -60,-60]);
        Modelica.Mechanics.MultiBody.Parts.Fixed Fixed2(r={0,0,-1})
          annotation (extent=[-100,-40; -80,-20]);
        Modelica.Mechanics.MultiBody.Parts.FixedTranslation FixedTranslation2(r={2,2,
              0}) annotation (extent=[-20,-40; 0,-20]);
        Modelica.Mechanics.MultiBody.Joints.Revolute Revolute2(initType=
              Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity)
          annotation (extent=[-60,-40; -40,-20]);
        PlanarMechanics.Joints.Revolute Revolute3(initType=Modelica.Mechanics.
              MultiBody.Types.Init.PositionVelocity)
                                                  annotation (extent=[0,20; 20,40]);
        PlanarMechanics.Parts.FixedTranslation FixedTranslation3(r={0,-1.5})
          annotation (extent=[40,20; 60,40]);
        PlanarMechanics.Parts.Body Body3(m=1, J=0) annotation (extent=[80,20; 100,40]);
        Modelica.Mechanics.MultiBody.Parts.Body Body4(
          m=1,
          I_11=0,
          I_22=0,
          I_33=0) annotation (extent=[80,-80; 100,-60]);
        Modelica.Mechanics.MultiBody.Parts.FixedTranslation FixedTranslation4(r={0,-1.5,
              0}) annotation (extent=[40,-80; 60,-60]);
        Modelica.Mechanics.MultiBody.Joints.Revolute Revolute4(initType=
              Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity)
          annotation (extent=[0,-80; 20,-60]);
        PlanarMechanics.Parts.Body Body1(     J=0, m=2)
                                                   annotation (extent=[20,60; 40,80]);
        Modelica.Mechanics.MultiBody.Parts.Body Body2(
          I_11=0,
          I_22=0,
          I_33=0,
          m=2)    annotation (extent=[20,-40; 40,-20]);
        inner PlanarMechanics.PlanarWorld planarWorld(nominalLength=5)
          annotation (extent=[-80,20; -60,40]);
      equation
        connect(Revolute1.frame_a, Fixed1.frame_b) annotation (points=[-61,70; -79,70],
            style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=83,
            rgbfillColor={255,170,255},
            fillPattern=1));
        connect(FixedTranslation1.frame_a, Revolute1.frame_b) annotation (points=[-21,
              70; -39,70], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Revolute2.frame_a, Fixed2.frame_b) annotation (points=[-61,-30; -79,
              -30], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Revolute2.frame_b, FixedTranslation2.frame_a) annotation (points=[-39,
              -30; -21,-30], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FixedTranslation3.frame_b, Body3.frame_a) annotation (points=[61,30;
              79,30], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FixedTranslation3.frame_a, Revolute3.frame_b) annotation (points=[39,
              30; 21,30], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Revolute3.frame_a, FixedTranslation1.frame_b) annotation (points=[-1,
              30; -12,30; -12,50; 6,50; 6,70; 1,70], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Revolute4.frame_b, FixedTranslation4.frame_a) annotation (points=[21,
              -70; 39,-70], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FixedTranslation4.frame_b, Body4.frame_a) annotation (points=[61,-70;
              79,-70], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Revolute4.frame_a, FixedTranslation2.frame_b) annotation (points=[-1,
              -70; -12,-70; -12,-50; 10,-50; 10,-30; 1,-30], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Body1.frame_a, FixedTranslation1.frame_b) annotation (points=[19,70;
              1,70], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(Body2.frame_a, FixedTranslation2.frame_b) annotation (points=[19,-30;
              1,-30], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
      end DoublePendulum;

      model FreeBody "free body on spring"
                     extends Modelica.Icons.Example;
        PlanarMechanics.Parts.FixedTranslation FixedTranslation1(r={1,0})
          annotation (extent=[0,-20; 20,0]);
        annotation (Diagram, preferedView="info", experiment(StopTime=10, NumberOfIntervals=2500),
      Documentation(info="<html>
This example presents a free body attached to a string via a massless rod.
<p>
<img src=\"../Images/Spring.png\">
</p>
</html>"));
        PlanarMechanics.Parts.Fixed Fixed1 annotation (extent=[-60,40; -40,60]);
        PlanarMechanics.Forces.Spring Spring1(     s0=1, c=10)
          annotation (extent=[-28,0; -8,20]);
        inner PlanarMechanics.PlanarWorld planarWorld(nominalLength=5)
          annotation (extent=[-80,-60; -60,-40]);
        Parts.Body Body1(
          initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
          m=1,
          x_start={1.2,-0.5},
          J=0.12) annotation (extent=[40,-20; 60,0]);
      equation
        connect(Spring1.frame_a, Fixed1.frame_b) annotation (points=[-29,10;
              -32,10; -32,50; -39,50],
                               style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Spring1.frame_b, FixedTranslation1.frame_a) annotation (points=[-7,10;
              -2,10; -2,-10; -1,-10], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Body1.frame_a, FixedTranslation1.frame_b) annotation (points=[
              39,-10; 21,-10], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
      end FreeBody;

      model KinematicLoop "kinematic loop with 4 revolute joints"
                          extends Modelica.Icons.Example;
        PlanarMechanics.Parts.Fixed Fixed1 annotation (extent=[-80,60; -60,80]);
        PlanarMechanics.Parts.FixedTranslation FixedTranslation1(r={0,1})
          annotation (extent=[-60,40; -40,60], rotation=90);
        PlanarMechanics.Joints.Revolute Revolute1(phi_start=
              0,
          enforceStates=true,
          initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity)
                                                  annotation (extent=[-40,60; -20,80]);
        annotation (Diagram, preferedView="info", experiment(StopTime=10, NumberOfIntervals=2500),
      Documentation(info="<html>
This example presents a planar kinematic loop.
<p>
<img src=\"../Images/PlanarLoop1.png\">
</p>
<p>
The planar loop is formed out of four revolutes.
<p>
The loop is closed automatically. The loop leads to 2 non-linear equations.
</html>"));
        PlanarMechanics.Joints.Revolute Revolute2
          annotation (extent=[-60,0; -40,20], rotation=90);
        PlanarMechanics.Parts.FixedTranslation FixedTranslation2
          annotation (extent=[-46,-60; -26,-40]);
        PlanarMechanics.Parts.FixedTranslation FixedTranslation3
          annotation (extent=[0,60; 20,80]);
        PlanarMechanics.Joints.Revolute Revolute3
          annotation (extent=[40,40; 60,60], rotation=90);
        PlanarMechanics.Parts.FixedTranslation FixedTranslation4(r={0,1})
          annotation (extent=[42,0; 62,20], rotation=90);
        PlanarMechanics.Joints.Revolute Revolute4 annotation (extent=[0,-20; 20,
              0]);
        PlanarMechanics.Parts.Body Body1(animation=false)
                                         annotation (extent=[40,80; 60,100],
            rotation=90);
        PlanarMechanics.Parts.Body Body2(animation=false)
                                         annotation (extent=[-16,-82; 4,-62],
            rotation=270);
        PlanarMechanics.Parts.Body Body3(animation=false)
                                         annotation (extent=[60,-20; 80,0]);
        PlanarMechanics.Parts.Body Body4(animation=false)
                                         annotation (extent=[0,8; 20,28]);
        inner PlanarMechanics.PlanarWorld planarWorld(nominalLength=5,
          animateWorld=false,
          animateGravity=false)
          annotation (extent=[-80,-80; -60,-60]);
      equation
        connect(Revolute1.frame_a, Fixed1.frame_b) annotation (points=[-41,70; -59,70],
            style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FixedTranslation1.frame_b, Fixed1.frame_b) annotation (points=[-50,61;
              -56,61; -56,70; -59,70], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Revolute2.frame_b, FixedTranslation1.frame_a) annotation (points=[-50,
              21; -50,39], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Revolute1.frame_b, FixedTranslation3.frame_a) annotation (points=[-19,
              70; -1,70], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Revolute2.frame_a, FixedTranslation2.frame_a) annotation (points=[-50,-1;
              -50,-50; -47,-50],     style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FixedTranslation3.frame_b, Revolute3.frame_b) annotation (points=[21,
              70; 50,70; 50,61], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Revolute3.frame_a, FixedTranslation4.frame_b) annotation (points=[50,
              39; 52,39; 52,21], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Revolute4.frame_b, FixedTranslation4.frame_a) annotation (points=[21,-10;
              52,-10; 52,-1],      style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Body1.frame_a, FixedTranslation3.frame_b) annotation (points=[50,79;
              50,70; 21,70],        style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(Body3.frame_a, FixedTranslation4.frame_a) annotation (points=[59,-10;
              52,-10; 52,-1],          style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(Body2.frame_a, FixedTranslation2.frame_b) annotation (points=[-6,-61;
              -6,-50; -25,-50],  style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(Body4.frame_a, Revolute4.frame_a) annotation (points=[-1,18; -6,
              18; -6,-10; -1,-10],
                                style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(FixedTranslation2.frame_b, Revolute4.frame_a) annotation (points=[-25,-50;
              -6,-50; -6,-10; -1,-10],      style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
      end KinematicLoop;

      model KinematicLoop2 "kinematic loop"
                           extends Modelica.Icons.Example;
        PlanarMechanics.Parts.Fixed Fixed1 annotation (extent=[-80,40; -60,60]);
        PlanarMechanics.Parts.FixedTranslation FixedTranslation1(r={0,-3})
          annotation (extent=[-60,-20; -40,0], rotation=270);
        PlanarMechanics.Parts.FixedTranslation FixedTranslation2(r={0,-3})
          annotation (extent=[20,-20; 40,0], rotation=270);
        PlanarMechanics.Joints.Revolute Revolute1(enforceStates=true)
          annotation (extent=[-60,20; -40,40], rotation=90);
        PlanarMechanics.Joints.Revolute Revolute2
          annotation (extent=[20,20; 40,40], rotation=270);
        PlanarMechanics.Joints.Revolute Revolute3 annotation (extent=[0,-40; 20,-20]);
        annotation (Diagram, preferedView="info", experiment(StopTime=10, NumberOfIntervals=2500),
      Documentation(info="<html>
This example presents another planar kinematic loop.
<p>
<img src=\"../Images/PlanarLoop2.png\">
</p>
<p>
The planar loop is formed out of three revolute and one prismatic joint. Attached to this loop is a pendulum
that is dissipating its energy through the damper.
<p>
The loop is closed automatically. The loop leads to 2 non-linear equations.
</html>"));
        PlanarMechanics.Joints.Revolute Revolute4(initType=Modelica.Mechanics.
              MultiBody.Types.Init.PositionVelocity, enforceStates=true)
          annotation (extent=[40,-40; 60,-20]);
        PlanarMechanics.Parts.Body Body2(m=2, J=0.05)
          annotation (extent=[60,20; 80,40], rotation=90);
        PlanarMechanics.Parts.FixedTranslation FixedTranslation3(r={2,0})
          annotation (extent=[60,-20; 80,0], rotation=90);
        inner PlanarMechanics.PlanarWorld planarWorld(nominalLength=5,
          enableAnimation=true,
          animateWorld=false,
          animateGravity=false)
          annotation (extent=[-80,-80; -60,-60]);
        Joints.ActuatedPrismatic actuatedPrismatic(initType=Modelica.Mechanics.
              MultiBody.Types.Init.PositionVelocity, s_start=2)
          annotation (extent=[-20,40; 0,60]);
        BondLib.Mechanical.Translational.Passive.SpringDamper springDamper(
          c=50,
          d=2,
          s_rel0=1.6) annotation (extent=[-20,70; 0,90]);
      equation
        connect(FixedTranslation2.frame_a, Revolute2.frame_b) annotation (points=[30,1; 30,
              5.5; 30,5.5; 30,10; 30,19; 30,19],       style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Revolute1.frame_b, Fixed1.frame_b) annotation (points=[-50,41; -50,50;
              -59,50], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FixedTranslation1.frame_a, Revolute1.frame_a) annotation (points=[-50,
              1; -50,19], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Revolute3.frame_b, FixedTranslation2.frame_b) annotation (points=[21,-30;
              30,-30; 30,-21],      style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Revolute4.frame_a, FixedTranslation2.frame_b) annotation (points=[39,-30;
              32,-30; 32,-21; 30,-21],      style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Revolute4.frame_b, FixedTranslation3.frame_a) annotation (points=[61,-30;
              66,-30; 66,-21; 70,-21],      style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Body2.frame_a, FixedTranslation3.frame_b) annotation (points=[70,19;
              70,1], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FixedTranslation1.frame_b, Revolute3.frame_a) annotation (points=[-50,
              -21; -50,-30; -1,-30], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(actuatedPrismatic.frame_b, Revolute2.frame_a) annotation (
            points=[1,50; 30,50; 30,41], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(actuatedPrismatic.frame_a, Revolute1.frame_b) annotation (
            points=[-21,50; -50,50; -50,41], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(springDamper.flange_a, actuatedPrismatic.bearing) annotation (
            points=[-20,80; -22,80; -22,62; -16,62; -16,57], style(color=58,
              rgbcolor={0,127,0}));
        connect(springDamper.flange_b, actuatedPrismatic.axis) annotation (
            points=[-0.1,80; 2,80; 2,62; -3,62; -3,57], style(color=58,
              rgbcolor={0,127,0}));
      end KinematicLoop2;

      model PlanarPendulum "a simple pendulum"
                            extends Modelica.Icons.Example;
        PlanarMechanics.Parts.Fixed Fixed1 annotation (extent=[-80,40; -60,60]);
        PlanarMechanics.Parts.FixedTranslation FixedTranslation1(r={1,3})
          annotation (extent=[0,40; 20,60]);
        PlanarMechanics.Parts.Body Body1(m=1, J=0) annotation (extent=[40,40;
              60,60]);
        annotation (Diagram, preferedView="info", experiment(StopTime=10, NumberOfIntervals=2500),
      Documentation(info="<html>
This example presents a planar pendulum.
<p>
<img src=\"../Images/Pendulum.png\">
</p>
<p>
The model is confronted with its equivalence of the Modelica.Mechanics.MultiBody library.
</html>"));
        inner Modelica.Mechanics.MultiBody.World world(nominalLength=5,
          animateWorld=false,
          animateGravity=false)
          annotation (extent=[-80,-80; -60,-60]);
        Modelica.Mechanics.MultiBody.Parts.Fixed Fixed2(r={0,0,-1})
          annotation (extent=[-80,-40; -60,-20]);
        Modelica.Mechanics.MultiBody.Parts.Body Body2(
          m=1,
          I_11=0,
          I_22=0,
          I_33=0) annotation (extent=[40,-40; 60,-20]);
        Modelica.Mechanics.MultiBody.Parts.FixedTranslation FixedTranslation2(r={1,3,
              0}) annotation (extent=[0,-40; 20,-20]);
        inner PlanarMechanics.PlanarWorld planarWorld(nominalLength=5,
          animateWorld=false,
          animateGravity=false)
          annotation (extent=[-80,0; -60,20]);
        Joints.ActuatedRevolute actuatedRevolute1(initType=Modelica.Mechanics.
              MultiBody.Types.Init.PositionVelocity)
          annotation (extent=[-40,40; -20,60]);
        BondLib.Mechanical.Rotational.Passive.Damper damper1(d=5)
          annotation (extent=[-40,70; -20,90]);
        Modelica.Mechanics.MultiBody.Joints.ActuatedRevolute actuatedRevolute2(
            initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity)
          annotation (extent=[-40,-40; -20,-20]);
        Modelica.Mechanics.Rotational.Damper damper2(d=5)
          annotation (extent=[-40,-10; -20,10]);
      equation
        connect(FixedTranslation1.frame_b, Body1.frame_a) annotation (points=[21,50;
              39,50], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FixedTranslation2.frame_b, Body2.frame_a) annotation (points=[21,-30;
              39,-30], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(actuatedRevolute1.frame_b, FixedTranslation1.frame_a)
          annotation (points=[-19,50; -1,50], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(actuatedRevolute1.frame_a, Fixed1.frame_b) annotation (points=[
              -41,50; -59,50], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(damper1.flange_a, actuatedRevolute1.bearing) annotation (points=
             [-40,80; -40,64; -38,64; -38,58; -37,57], style(color=0, rgbcolor=
                {0,0,0}));
        connect(actuatedRevolute1.axis, damper1.flange_b) annotation (points=[
              -23,57; -23,63.5; -20,63.5; -20,80], style(color=0, rgbcolor={0,0,
                0}));
        connect(actuatedRevolute2.frame_b, FixedTranslation2.frame_a)
          annotation (points=[-19,-30; -1,-30], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(actuatedRevolute2.frame_a, Fixed2.frame_b) annotation (points=[
              -41,-30; -59,-30], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(damper2.flange_a, actuatedRevolute2.bearing) annotation (points=
             [-40,0; -40,-12; -36,-12; -36,-20], style(color=0, rgbcolor={0,0,0}));
        connect(damper2.flange_b, actuatedRevolute2.axis) annotation (points=[
              -20,0; -20,-12; -30,-12; -30,-20], style(color=0, rgbcolor={0,0,0}));
      end PlanarPendulum;

      model CraneCrab3 "model of a free crane crab"
                               extends Modelica.Icons.Example;
        PlanarMechanics.Parts.Fixed Fixed1 annotation (extent=[-100,60; -80,80]);
        PlanarMechanics.Joints.Revolute Revolute1(animation=false, enforceStates=
              false,
          initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity)
                                                  annotation (extent=[-20,20; 0,40]);
        PlanarMechanics.Parts.FixedTranslation FixedTranslation1(r={1,3})
          annotation (extent=[20,20; 40,40]);
        PlanarMechanics.Parts.Body Body1(m=1, J=0) annotation (extent=[60,20; 80,40]);
        PlanarMechanics.Parts.Body Body2(m=2, J=0) annotation (extent=[-18,60;
              2,80]);
        PlanarMechanics.Joints.Prismatic Prismatic1(enforceStates=false, initType=
             Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity)
          annotation (extent=[-60,60; -40,80]);
        inner Modelica.Mechanics.MultiBody.World world(nominalLength=5)
          annotation (extent=[-80,-80; -60,-60]);
        Modelica.Mechanics.MultiBody.Parts.Fixed Fixed2(r={0,0,-1}, animation=
              false)
          annotation (extent=[-100,-40; -80,-20]);
        Modelica.Mechanics.MultiBody.Parts.Body Body3(
          m=2,
          I_11=0,
          I_22=0,
          I_33=0) annotation (extent=[-20,-40; 0,-20]);
        Modelica.Mechanics.MultiBody.Parts.Body Body4(
          m=1,
          I_11=0,
          I_22=0,
          I_33=0) annotation (extent=[60,-80; 80,-60]);
        Modelica.Mechanics.MultiBody.Joints.Prismatic Prismatic2(initType=
              Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity)
          annotation (extent=[-60,-40; -40,-20]);
        Modelica.Mechanics.MultiBody.Joints.Revolute Revolute2(initType=
              Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity)
          annotation (extent=[-20,-80; 0,-60]);
        Modelica.Mechanics.MultiBody.Parts.FixedTranslation FixedTranslation2(r={1,3,
              0}) annotation (extent=[20,-80; 40,-60]);
        inner PlanarMechanics.PlanarWorld planarWorld(nominalLength=5)
          annotation (extent=[-80,20; -60,40]);
      equation
        connect(FixedTranslation1.frame_b, Body1.frame_a) annotation (points=[41,30;
              59,30], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FixedTranslation1.frame_a, Revolute1.frame_b) annotation (points=[19,
              30; 1,30], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        annotation (Diagram, preferedView="info", Documentation(info="<html>
This example presents a free crane crab.
The model concludes the wrapping process that started in <br>
<a href=\"Modelica://MultiBondLib.Examples.CraneCrab2\">MultiBondLib.Examples.CraneCrab2</a>
<p>
<img src=\"../Images/CraneCrab.png\">
</p>
<p>
The model is confronted with its equivalence of the Modelica.Mechanics.MultiBody library.
</html>"),experiment(StopTime=10, NumberOfIntervals=2500));
        connect(Fixed1.frame_b, Prismatic1.frame_a) annotation (points=[-79,70; -61,
              70], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Prismatic1.frame_b, Body2.frame_a) annotation (points=[-39,70;
              -19,70],                 style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Prismatic1.frame_b, Revolute1.frame_a) annotation (points=[-39,70;
              -30,70; -30,30; -21,30], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FixedTranslation2.frame_b, Body4.frame_a) annotation (points=[41,-70;
              59,-70], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FixedTranslation2.frame_a, Revolute2.frame_b) annotation (points=[19,
              -70; 1,-70], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Prismatic2.frame_a, Fixed2.frame_b) annotation (points=[-61,-30; -79,
              -30], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Prismatic2.frame_b, Body3.frame_a) annotation (points=[-39,-30; -21,
              -30], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Revolute2.frame_a, Prismatic2.frame_b) annotation (points=[-21,-70;
              -30,-70; -30,-30; -39,-30], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
      end CraneCrab3;

    end Examples;

    package Types "additional type definitions specific for 3D-Mechanics"

      type AngularVelocity_deg = Real (final quantity="AngularVelocity", final unit
            =    "deg/s");

      type AngularAcceleration_deg = Real (final quantity="AngularAcceleration",
            final unit="deg/s2");

      annotation (Icon(
          Text(
            extent=[-120,122; 120,73],
            string="%name",
            style(color=45, rgbcolor={255,128,0})),
          Polygon(points=[-100,50; -80,70; 100,70; 80,50; -100,50], style(
              color=45,
              rgbcolor={255,128,0},
              fillColor=30,
              rgbfillColor={235,235,235},
              fillPattern=1)),
          Polygon(points=[100,70; 100,-80; 80,-100; 80,50; 100,70], style(
              color=45,
              rgbcolor={255,128,0},
              fillColor=30,
              rgbfillColor={235,235,235},
              fillPattern=1)),
          Rectangle(extent=[-100,-100; 80,50], style(
              color=45,
              rgbcolor={255,128,0},
              fillColor=30,
              rgbfillColor={235,235,235},
              fillPattern=1)),
          Text(
            extent=[-85,35; 65,-85],
            string="Library",
            style(color=45, rgbcolor={255,128,0}))), preferedView="info", Documentation(info="<html>
This package constains type definitions.
</html>"));
    end Types;
  end PlanarMechanics;

  package Mechanics3D "A library for 3D-Mechanics based upon MultiBond graphs"
  annotation(preferedView="info", Documentation(info="<html>
  This is the package for 3D-mechanical models.
  It is a partial reimplementation of the <a href=\"Modelica://Modelica.Mechanics.MultiBody\">MultiBody</a> library of Prof. Dr. Martin Otter.
<p>
<img src=\"../Images/Bicycle.png\">
<img src=\"../Images/FourBarLoop.png\">
</p>
<p>
This library offers an object-oriented solution for the modeling of 3D-mechanical systems.
Mechanical systems can be composed out of single ideal elements. They are separated according to their nature
into subpackages. These packages contain:
<ul>
<li> basic parts: like bodies or massless rods<br>
<li> joint elements <br>
<li> ideal rolling objects <br>
<li> force elements <br>
</ul>
<p>
All the basic elements consist of multibond graphs.
<h3>Tutorial</h3>
The <a href=\"Modelica://Modelica.Mechanics.MultiBody\">MultiBody</a> library offers an excelent  <a href=\"Modelica://Modelica.Mechanics.MultiBody.UsersGuide\">tutorial</a>.
The models of this library can be treated essentially the same way.
<h3>Wrapped MultiBond Graphs</h3>
A look into the mechanical models reveals the corresponding multibond graphs.
There are separate multibonds for the translational and rotational domain, both of cardinality 3.
 The composition of them is illustrated in the next figure.
<p>
<img src=\"../Images/3DMechBond.png\">
</p>
<p>
This separation is necessary because the corresponding bondgraphic variables are resolved in different coordinate systems. The translational variables are resolved with respect to the inertial system. The rotational variables are resolved with respect to the body system. The body system is defined by the
signal R that contains the 3x3 orientation matrix.
Again, the the positional variables are processed by acuasal signals and are of course resolved in the inertial system.
<p>
Two converter elements convert the bondgraphic variables to the variables of the main connectors and vice-versa. These elements create a shell for the multibond graph.
The figure below presents such a typical shell. The multibond graph is indicated by 1-junctions.
<p>
<img src=\"../Images/3DShell.png\">
</p>
<h3>Kinematic Loops</h3>
Kinematic loops are not problematic and can be modeled in a fully object-oriented way.
The appearing redundant statements are removed automatically.
Whenever loop structures occur, non-linear algebraic equations are present on \"position level\", but
usually they are solved fast and robustly and cause no further problems.
<p>
Also an element for the manual closure of kinematic loops is provided.
The application of this element is meaningful, if you want to \"cut\" the loop at a specific point.
(This might lead to better equations)
<p>
Planar loops cannot be handled autoatically. To close such a strucute a special revolute joint is provided.
<h3>Efficency</h3>
The Mechanics3D library offers a comprehensive set of ideal elements for 3D-mechanics.
Mechanical systems can be comfortably modeled and efficiently simulated.
<p>
The selection of the state variables is of major importance for the efficiency of the resulting simulation.
This selection is automatically done by Dymola. The resulting state variables are then always the states of a joint's relative position and motion. So each joint is declaring state variables, unless there is a kinematic loop.
<p>
The state selection can be improved or fully determined by the advanced parameter \"enforceStates\"
that is part of all joints. This helpful to avoid sets of dynamic state selection as they occur in kinematic loops.
<p>
The resulting systems of linear equations are usually small and can be solved
fast and accurately. Kinematic loops lead to a systems non-linear equations.
<h3>Examples</h3>
A comprehensive set of examples demonstrate the usage of the Mechanics3D library.
They are easy to understand and offer a good starting point to make yourself familiar with this
library. Don't forget the examples of the PlanarMechanics library.
</html>
"));

    model World3D
      "world element of the 3D-mechanicsWorld coordinate system + gravity field + default animation definition"

      import SI = Modelica.SIunits;

      annotation (defaultComponentName="world3D",
        defaultComponentPrefixes="inner",
        Coordsys(
          extent=[-100, -100; 100, 100],
          grid=[2, 2],
          component=[20, 20]),
        Window(
          x=0.13,
          y=0.1,
          width=0.81,
          height=0.83),
        Icon(
          Rectangle(extent=[-100, 100; 100, -100], style(
              color=0,
              rgbcolor={0,0,0},
              fillColor=7,
              rgbfillColor={255,255,255})),
          Line(points=[-100, -118; -100, 61], style(color=0, thickness=2)),
          Polygon(points=[-100, 100; -120, 60; -80, 60; -100, 100; -100, 100],
              style(
              color=0,
              fillColor=0,
              fillPattern=1)),
          Line(points=[-119, -100; 59, -100], style(color=0, thickness=2)),
          Polygon(points=[99, -100; 59, -80; 59, -120; 99, -100], style(
              color=0,
              fillColor=0,
              fillPattern=1)),
          Text(extent=[-140, 165; 140, 103], string="%name"),
          Text(
            extent=[95, -113; 144, -162],
            string="%label1",
            style(color=0)),
          Text(
            extent=[-170, 127; -119, 77],
            string="%label2",
            style(color=0)),
          Line(points=[-56, 78; -56, -26]),
          Polygon(points=[-68, -26; -56, -66; -44, -26; -68, -26], style(fillColor=
                  3)),
          Line(points=[2, 78; 2, -26]),
          Polygon(points=[-10, -26; 2, -66; 14, -26; -10, -26], style(fillColor=3)),
          Line(points=[66, 80; 66, -26]),
          Polygon(points=[54, -26; 66, -66; 78, -26; 54, -26], style(fillColor=3))),
        Diagram, preferedView="info",
        Documentation(info="<html>
This is the World3D model.
This model is an extended copy of the Modelica.Mechanics.MultiBody.World model.
<p>
This world model serves several purposes:
<ul>
<li>It visualizes the origin of the inertial system in the animation window.
<li>It sets the default parameters for the animation of all basic elements.
<li>It models a global gravity field. (either uniform gravity or point gravity)
<li>It constains a gravity pool to model the mutual gravitiational attraction between body elements.
</ul>
<p>
Since the gravity field function is required from all bodies with mass
and the default settings of animation properties are required
from nearly every component, exactly one instance of model World3D needs
to be present in every model on the top level. The basic declaration
needs to be:
</p>
<pre>
    <b>inner</b> Mechanics3D.World3D world3D
</pre>
<p>
Note, it must be an <b>inner</b> declaration with instance name <b>world3D</b>
in order that this world object can be accessed from all objects in the
model. When dragging the \"World3D\" object from the package browser into
the diagram layer, this declaration is automatically generated
(this is defined via annotations in model World).
</p>
<p>
To use the the gravity pool, set the parameter gravityPoolSize to the number
of bodies you'd like to have in your pool. Then give each body in the pool
a different index number from 1 to gravityPoolSize.
The index number can be set by the parameter GPindex of the body element.
</p>
</html>"));

      parameter Boolean enableAnimation=true
        "= true, if animation of all components is enabled";
      parameter Boolean animateWorld=true
        "= true, if world coordinate system shall be visualized";
      parameter Boolean animateGravity=true
        "= true, if gravity field shall be visualized (acceleration vector or field center)";
      parameter Modelica.Mechanics.MultiBody.Types.AxisLabel label1="x"
        "Label of horizontal axis in icon";
      parameter Modelica.Mechanics.MultiBody.Types.AxisLabel label2="y"
        "Label of vertical axis in icon";
      parameter Modelica.Mechanics.MultiBody.Types.GravityTypes.Temp
        gravityType=
          Modelica.Mechanics.MultiBody.Types.GravityTypes.UniformGravity
        "Type of gravity field"                                                                                                     annotation (Evaluate=true);
      parameter SI.Acceleration g=9.81 " Constant gravity acceleration"
        annotation (Dialog(enable=gravityType==Modelica.Mechanics.MultiBody.Types.GravityTypes.UniformGravity));
      parameter Modelica.Mechanics.MultiBody.Types.Axis n={0,-1,0}
        " Direction of gravity resolved in world frame (gravity = g*n/length(n))"
        annotation (Evaluate=true, Dialog(enable=gravityType==Modelica.Mechanics.MultiBody.Types.GravityTypes.UniformGravity));
      parameter Real mue(
        unit="m3/s2",
        min=0) = 3.986e14
        " Gravity field constant (default = field constant of earth)"
        annotation (Dialog(enable=gravityType==Modelica.Mechanics.MultiBody.Types.GravityTypes.PointGravity));
      parameter Integer gravityPoolSize=0 "size of gravity pool";
      parameter SI.Distance axisLength=nominalLength/2
        "|Animation|if animateWorld = true| Length of world axes arrows";
      parameter SI.Distance axisDiameter=axisLength/defaultFrameDiameterFraction
        "|Animation|if animateWorld = true| Diameter of world axes arrows";
      parameter Boolean axisShowLabels=true
        "|Animation|if animateWorld = true| = true, if labels shall be shown";
      parameter Modelica.Mechanics.MultiBody.Types.Color axisColor_x=Modelica.Mechanics.MultiBody.Types.Defaults.
          FrameColor "|Animation|if animateWorld = true| Color of x-arrow";
      parameter Modelica.Mechanics.MultiBody.Types.Color axisColor_y=axisColor_x
        "|Animation|if animateWorld = true| Color of y-arrow";
      parameter Modelica.Mechanics.MultiBody.Types.Color axisColor_z=axisColor_x
        "|Animation|if animateWorld = true| Color of z-arrow";

      parameter SI.Position gravityArrowTail[3]={0,0,0}
        "|Animation|if animateGravity = true and gravityType = UniformGravity| Position vector from origin of world frame to arrow tail, resolved in world frame";
      parameter SI.Length gravityArrowLength=axisLength/2
        "|Animation|if animateGravity = true and gravityType = UniformGravity| Length of gravity arrow";
      parameter SI.Diameter gravityArrowDiameter=gravityArrowLength/
          defaultWidthFraction
        "|Animation|if animateGravity = true and gravityType = UniformGravity| Diameter of gravity arrow";
      parameter Modelica.Mechanics.MultiBody.Types.Color gravityArrowColor={0,230,0}
        "|Animation|if animateGravity = true and gravityType = UniformGravity| Color of gravity arrow";
      parameter SI.Diameter gravitySphereDiameter=12742000
        "|Animation|if animateGravity = true and gravityType = PointGravity| Diameter of sphere representing gravity center (default = mean diameter of earth)";
      parameter Modelica.Mechanics.MultiBody.Types.Color gravitySphereColor={0,230,0}
        "|Animation|if animateGravity = true and gravityType = PointGravity| Color of gravity sphere";

      parameter SI.Length nominalLength=1
        "|Defaults|| \"Nominal\" length of multi-body system";
      parameter SI.Length defaultAxisLength=nominalLength/5
        "|Defaults|| Default for length of a frame axis (but not world frame)";
      parameter SI.Length defaultJointLength=nominalLength/10
        "|Defaults|| Default for the fixed length of a shape representing a joint";
      parameter SI.Length defaultJointWidth=nominalLength/20
        "|Defaults|| Default for the fixed width of a shape representing a joint";
      parameter SI.Length defaultForceLength=nominalLength/10
        "|Defaults|| Default for the fixed length of a shape representing a force (e.g. damper)";
      parameter SI.Length defaultForceWidth=nominalLength/20
        "|Defaults|| Default for the fixed width of a shape represening a force (e.g. spring, bushing)";
      parameter SI.Length defaultBodyDiameter=nominalLength/9
        "|Defaults|| Default for diameter of sphere representing the center of mass of a body";
      parameter Real defaultWidthFraction=20
        "|Defaults|| Default for shape width as a fraction of shape length (e.g., for Parts.FixedTranslation)";
      parameter SI.Length defaultArrowDiameter=nominalLength/40
        "|Defaults|| Default for arrow diameter (e.g., of forces, torques, sensors)";
      parameter Real defaultFrameDiameterFraction=40
        "|Defaults|| Default for arrow diameter of a coordinate system as a fraction of axis length";

      parameter Modelica.Mechanics.MultiBody.Types.Color defaultJointColor={255,0,255}
        "|Defaults|| Default color of a joint element";
      parameter Modelica.Mechanics.MultiBody.Types.Color defaultBodyColor={0,64,255}
        "|Defaults|| Default color of a body element";
      parameter Modelica.Mechanics.MultiBody.Types.Color defaultRodColor={96,128,128}
        "|Defaults|| Default color of a rod element";
      parameter Modelica.Mechanics.MultiBody.Types.Color
        defaultForceElementColor =                                                {0,64,255}
        "|Defaults|| Default color of a rod element";

      Utilities.GravityPool gravityPool(poolSize=gravityPoolSize)
        annotation (extent=[-80,60; -60,80]);

      /* The World object can only use the Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape model, but no
     other models in package Modelica.Mechanics.MultiBody.Visualizers, since the other models access
     data of the "outer Modelica.Mechanics.MultiBody.World world" object, i.e., there are
     mutually dependent classes. For this reason, the higher level visualization
     objects cannot be used.
  */
    protected
      parameter Integer ndim=if enableAnimation and animateWorld then 1 else 0;
      parameter Integer ndim2=if enableAnimation and animateWorld and
          axisShowLabels then 1 else 0;

      // Parameters to define axes
      parameter SI.Length headLength=min(axisLength, axisDiameter*Modelica.
          Mechanics.MultiBody.Types.Defaults.FrameHeadLengthFraction);
      parameter SI.Length headWidth=axisDiameter*Modelica.Mechanics.MultiBody.Types.
          Defaults.FrameHeadWidthFraction;
      parameter SI.Length lineLength=max(0, axisLength - headLength);
      parameter SI.Length lineWidth=axisDiameter;

      // Parameters to define axes labels
      parameter SI.Length scaledLabel=Modelica.Mechanics.MultiBody.Types.Defaults.
          FrameLabelHeightFraction                                           *
          axisDiameter;
      parameter SI.Length labelStart=1.05*axisLength;

      // x-axis
      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape x_arrowLine[ndim](
        each shapeType="cylinder",
        each length=lineLength,
        each width=lineWidth,
        each height=lineWidth,
        each lengthDirection={1,0,0},
        each widthDirection={0,1,0},
        each color=axisColor_x,
        each specularCoefficient=0);
      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape x_arrowHead[ndim](
        each shapeType="cone",
        each length=headLength,
        each width=headWidth,
        each height=headWidth,
        each lengthDirection={1,0,0},
        each widthDirection={0,1,0},
        each color=axisColor_x,
        each r={lineLength,0,0},
        each specularCoefficient=0);
      Modelica.Mechanics.MultiBody.Visualizers.Internal.Lines x_label[ndim2](
        each lines=scaledLabel*{[0, 0; 1, 1],[0, 1; 1, 0]},
        each diameter=axisDiameter,
        each color=axisColor_x,
        each r_lines={labelStart,0,0},
        each n_x={1,0,0},
        each n_y={0,1,0},
        each specularCoefficient=0);

      // y-axis
      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape y_arrowLine[ndim](
        each shapeType="cylinder",
        each length=lineLength,
        each width=lineWidth,
        each height=lineWidth,
        each lengthDirection={0,1,0},
        each widthDirection={1,0,0},
        each color=axisColor_y,
        each specularCoefficient=0);
      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape y_arrowHead[ndim](
        each shapeType="cone",
        each length=headLength,
        each width=headWidth,
        each height=headWidth,
        each lengthDirection={0,1,0},
        each widthDirection={1,0,0},
        each color=axisColor_y,
        each r={0,lineLength,0},
        each specularCoefficient=0);
      Modelica.Mechanics.MultiBody.Visualizers.Internal.Lines y_label[ndim2](
        each lines=scaledLabel*{[0, 0; 1, 1.5],[0, 1.5; 0.5, 0.75]},
        each diameter=axisDiameter,
        each color=axisColor_y,
        each r_lines={0,labelStart,0},
        each n_x={0,1,0},
        each n_y={-1,0,0},
        each specularCoefficient=0);

      // z-axis
      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape z_arrowLine[ndim](
        each shapeType="cylinder",
        each length=lineLength,
        each width=lineWidth,
        each height=lineWidth,
        each lengthDirection={0,0,1},
        each widthDirection={0,1,0},
        each color=axisColor_z,
        each specularCoefficient=0);
      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape z_arrowHead[ndim](
        each shapeType="cone",
        each length=headLength,
        each width=headWidth,
        each height=headWidth,
        each lengthDirection={0,0,1},
        each widthDirection={0,1,0},
        each color=axisColor_z,
        each r={0,0,lineLength},
        each specularCoefficient=0);
      Modelica.Mechanics.MultiBody.Visualizers.Internal.Lines z_label[ndim2](
        each lines=scaledLabel*{[0, 0; 1, 0],[0, 1; 1, 1],[0, 1; 1, 0]},
        each diameter=axisDiameter,
        each color=axisColor_z,
        each r_lines={0,0,labelStart},
        each n_x={0,0,1},
        each n_y={0,1,0},
        each specularCoefficient=0);

      // Uniform gravity visualization
      parameter Integer ndim_uniformGravity=if enableAnimation and animateGravity
           and gravityType == 1 then 1 else 0;
      parameter SI.Length gravityHeadLength=min(gravityArrowLength,
          gravityArrowDiameter*Modelica.Mechanics.MultiBody.Types.Defaults.
          ArrowHeadLengthFraction);
      parameter SI.Length gravityHeadWidth=gravityArrowDiameter*Modelica.Mechanics.
          MultiBody.Types.Defaults.ArrowHeadWidthFraction;
      parameter SI.Length gravityLineLength=max(0, gravityArrowLength -
          gravityHeadLength);
      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape gravityArrowLine[ndim_uniformGravity](
        each shapeType="cylinder",
        each length=gravityLineLength,
        each width=gravityArrowDiameter,
        each height=gravityArrowDiameter,
        each lengthDirection=n,
        each widthDirection={0,1,0},
        each color=gravityArrowColor,
        each r_shape=gravityArrowTail,
        each specularCoefficient=0);
      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape gravityArrowHead[ndim_uniformGravity](
        each shapeType="cone",
        each length=gravityHeadLength,
        each width=gravityHeadWidth,
        each height=gravityHeadWidth,
        each lengthDirection=n,
        each widthDirection={0,1,0},
        each color=gravityArrowColor,
        each r_shape=gravityArrowTail + Modelica.Mechanics.MultiBody.Frames.normalize(
                                                         n)*gravityLineLength,
        each specularCoefficient=0);

      // Point gravity visualization
      parameter Integer ndim_pointGravity=if enableAnimation and animateGravity
           and gravityType == 2 then 1 else 0;
      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape gravitySphere[ndim_pointGravity](
        each shapeType="sphere",
        each r_shape={-gravitySphereDiameter/2,0,0},
        each lengthDirection={1,0,0},
        each length=gravitySphereDiameter,
        each width=gravitySphereDiameter,
        each height=gravitySphereDiameter,
        each color=gravitySphereColor,
        each specularCoefficient=0);

      function gravityAcceleration = gravityAccelerationTypes (
          gravityType=gravityType,
          g=g*Modelica.Mechanics.MultiBody.Frames.normalize(
                                         n),
          mue=mue);

    protected
      function gravityAccelerationTypes
        "Gravity field acceleration depending on field type and position"

        extends Modelica.Icons.Function;
        input SI.Position r[3]
          "Position vector from world frame to actual point, resolved in world frame";
        input Integer gravityType "Type of gravity field";
        input SI.Acceleration g[3]
          "Constant gravity acceleration, resolved in world frame, if gravityType=1";
        input Real mue(unit="m3/s2")
          "Field constant of point gravity field, if gravityType=2";
        output SI.Acceleration gravity[3]
          "Gravity acceleration at point r, resolved in world frame";
      algorithm
        gravity := if gravityType == 1 then g else if gravityType == 2 then -(mue/(
          r*r))*(r/Modelica.Mechanics.MultiBody.Frames.length(r)) else zeros(3);
      end gravityAccelerationTypes;
    equation

      assert(Modelica.Mechanics.MultiBody.Frames.length(n) > 1.e-10,
        "Parameter n of World object is wrong (lenght(n) > 0 required)");
    end World3D;

    package Interfaces "Connector elements"
    annotation (Icon(
          Polygon(points=[-100,50; -80,70; 100,70; 80,50; -100,50],      style(
              color=58,
              fillColor=30,
              fillPattern=1)),
          Text(
            extent=[-85,35; 65,-85],
            string="Library",
            style(color=58)),
          Rectangle(extent=[-100,-100; 80,50],   style(
              color=58,
              fillColor=30,
              fillPattern=1)),
          Polygon(points=[100,70; 100,-80; 80,-100; 80,50; 100,70],      style(
              color=58,
              fillColor=30,
              fillPattern=1)),
          Text(
            extent=[-120,122; 120,73],
            style(color=1),
          string="%name"),
          Text(
            extent=[-85,35; 65,-85],
            string="Library",
            style(color=58))), preferedView="info", Documentation(info="<html>
This package contains the basic connectors of the 3D-mechanical elements.
There are two connector types \"Frame_a\" and \"Frame_b\", but their only difference is the symbol and the name.
They both contain exactly the same variables and are therefore semantically identical.
<p>
The package contains two converter elements, that enable the comfortable wrapping of bondgraphic models.
</html>"));

      connector Frame_a "connector for the mechanical components"
        extends Frame;

        annotation (defaultComponentName="frame_a",
                Diagram(Rectangle(extent=[100,100; 0,-100], style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=8,
                rgbfillColor={202,214,220})), Text(
              extent=[-100,-92; 100,-136],
              style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1),
              string="%name")),                Icon(Rectangle(extent=[100,100; 0,-100],
                style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=8,
                rgbfillColor={202,214,220})), Text(
              extent=[-100,-94; 100,-138],
              style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1),
              string="%name")),
          Documentation(info="<html>
This is a connector for 3D-mechanical components. It inherits all its variables
from the basic connector type 'Frame'.
</html>"));
      end Frame_a;

      connector Frame_b "connector for the mechanical components"
        extends Frame;

        annotation (defaultComponentName="frame_b",
                Diagram(Rectangle(extent=[0,100; -100,-100], style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=7,
                rgbfillColor={255,255,255})), Text(
              extent=[-100,-92; 100,-136],
              style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1),
              string="%name")),                Icon(Rectangle(extent=[0,100; -100,
                  -100], style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=7,
                rgbfillColor={255,255,255})), Text(
              extent=[-100,-90; 100,-134],
              style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1),
              string="%name")),
          Documentation(info="<html>
This is a connector for 3D-mechanical components. It inherits all its variables
from the basic connector type 'Frame'.
</html>"));
      end Frame_b;

      connector Frame "connector for the mechanical components"
        import SI = Modelica.SIunits;

          Potentials P;

          flow SI.Force f[3] "Cut-force";
          flow SI.Torque t[3] "Cut-torque";
        annotation (Documentation(info="<html>
This is the basic 3D-mechanical connector type.
<p>
The connectordefines the following potential variables:
<ul>
<li>translational position: real x[3];
<li>translational velocity: real v[3];
<li>orientation: real R[3,3];
<li>angular velocity: real w[3];
</ul>
<p>
The connector defines the following flow variables:
<ul>
<li>force: real f[3];
<li>torque: real t[3];
</ul>
<p>
The potential variables are summarized in a record P.
So the variable name has to be preceeded by a P.
(I. e.: the gain access to the position: Type frame.P.x.)
<p>
The variables w and t are resolved in their body system, that is specified by the orientation R.
All other variables are resolved in the inertial system.
<p>
Do not use this connector directly! Use its two inheritors \"Frame_a\" and \"Frame_b\".
</html>"));
      end Frame;

      record Potentials "redundant part of the connector"
                        extends Modelica.Icons.Record;
        import SI = Modelica.SIunits;

          SI.Position x[3] "Position";
          Real R[3, 3] "Orientation";

          SI.Velocity v[3] "Velocity";
          SI.AngularVelocity w[3] "angular Velocity";

        encapsulated function equalityConstraint
          "Return the constraint residues to express that two frames have the same orientation"

          import Modelica;
          import MultiBondLib.Mechanics3D.Interfaces;
          extends Modelica.Icons.Function;
          input Interfaces.Potentials P1;
          input Interfaces.Potentials P2;
          output Real residue[6];
        algorithm

          residue := {P1.x[1]-P2.x[1],P1.x[2]-P2.x[2],P1.x[3]-P2.x[3],cross(P1.R[1, :], P1.R[2, :])*P2.R[2, :],-cross(P1.R[1, :],
            P1.R[2, :])*P2.R[1, :],P1.R[2, :]*P2.R[1, :]};

          //    residue[1:3] := P1.x-P2.x;
          //  residue[4] := cross(P1.R[1, :], P1.R[2, :])*P2.R[2, :];
          //    residue[5] := cross(P1.R[1, :], P1.R[2, :])*P2.R[1, :];
          //    residue[6] := P1.R[2, :]*P2.R[1, :];

          annotation (Documentation(info="<html>
This function connects the two redundant sets of two mechanical connectors
in a non-redundant way. Instead of 18 equations only 6 equations are generated.
</html>"));
        end equalityConstraint;

        annotation (Documentation(info="<html>
This record contains all potential variables of the mechanical connector.
<p>
This potential variables form a redundant set of information. This is causing problems
by the closure of kinematic loops. To overcome these problems this record also contains
the function 'equalityConstraint'.
</html>"));
      end Potentials;

      model MBG2Mech "links the bond graph with the mechanic connector"
        import MultiBondLib;
        annotation (Icon(
            Line(points=[-80,-180; -80,-20; 80,-20; -80,-180],
                                                           style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[-80,0; -94,0], style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Text(
              extent=[-60,-80; 20,-40],
              style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1),
              string="MBG"),
            Text(
              extent=[-20,-176; 60,-120],
              style(
                color=10,
                rgbcolor={135,135,135},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1),
              string="M 3D"),
            Line(points=[-60,-100; 60,-100; 40,-80; 60,-100; 40,-120],
                                                            style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[-80,-180; 80,-180; 80,-20; -80,-180],
                                                           style(
                color=10,
                rgbcolor={135,135,135},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[-80,-400; -80,200],
                                           style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[-80,-200; -100,-200],
                                           style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[-80,-400; -100,-400],
                                           style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[-80,0; -100,0],   style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[-80,200; -100,200],
                                           style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Text(
              extent=[-82,242; 2,164],
              string="T",
              style(color=71, rgbcolor={85,170,255})),
            Text(
              extent=[-78,-358; 6,-436],
              style(color=71, rgbcolor={85,170,255}),
              string="R")),       Diagram(
            Line(points=[-80,-180; -80,-20; 80,-20; -80,-180],
                                                           style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[-80,0; -94,0], style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Text(
              extent=[-60,-80; 20,-40],
              style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1),
              string="MBG"),
            Text(
              extent=[-20,-174; 60,-120],
              style(
                color=10,
                rgbcolor={135,135,135},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1),
              string="M 3D"),
            Line(points=[-60,-100; 60,-100; 40,-80; 60,-100; 40,-120],
                                                            style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[-80,-180; 80,-180; 80,-20; -80,-180],
                                                           style(
                color=10,
                rgbcolor={135,135,135},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[-80,-400; -80,200],
                                           style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[-80,200; -100,200],
                                           style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[-80,0; -100,0],   style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[-80,-400; -100,-400],
                                           style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[-80,-200; -100,-200],
                                           style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Text(
              extent=[-82,238; 2,160],
              string="T",
              style(color=71, rgbcolor={85,170,255})),
            Text(
              extent=[-78,-362; 6,-440],
              style(color=71, rgbcolor={85,170,255}),
              string="R")),
          Coordsys(extent=[-100,-500; 100,300]),
          Documentation(info="<html>
This is a converter element. The signals and bond connections of a bondgraphic model
are converted into variables of the mechanical connector. This element enables the wrapping of bondgraphic
models and is acausal.
<p>
The converter element separates the translational and rotational domain, because
the according bondgraphic variables are resolved in different coordinate systems. The bondgraphic variables
of the translational domain are resolved in the inertial system, but the variables of the rotational domain are resolved in the body system, which is specified by the rotational matrix R.
</html>"));
        MultiBondLib.Interfaces.MultiBondCon MultiBondConTrans(n=3)
          annotation (extent=[-110,190; -90,210]);
        Frame_b frame_b annotation (extent=[80,-120; 100,-80]);
        MultiBondLib.Interfaces.RealSignal x[3]
          annotation (extent=[-110,-10; -90,10]);
        MultiBondLib.Interfaces.RealSignal R[3,3]
          annotation (extent=[-110,-210; -90,-190]);
        MultiBondLib.Interfaces.MultiBondCon MultiBondConRot(n=3)
          annotation (extent=[-110,-410; -90,-390]);
      equation
        MultiBondConTrans.e*MultiBondConTrans.d = frame_b.f;
        MultiBondConRot.e*MultiBondConRot.d = frame_b.t;

        MultiBondConTrans.f = frame_b.P.v;
        MultiBondConRot.f = frame_b.P.w;

        x = frame_b.P.x;
        R = frame_b.P.R;
      end MBG2Mech;

      model Mech2MBG "links the bond graph with the mechanic connector"
        import MultiBondLib;
        annotation (Icon(
            Line(points=[-80,-180; -80,-20; 80,-20; -80,-180],
                                                           style(
                color=10,
                rgbcolor={135,135,135},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[-80,-180; 80,-180; 80,-20; -80,-180],
                                                           style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[94,0; 80,0], style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Text(
              extent=[-10,-160; 70,-120],
              style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1),
              string="MBG"),
            Text(
              extent=[-70,-100; 20,-30],
              style(
                color=10,
                rgbcolor={135,135,135},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1),
              string="M 3D"),
            Line(points=[-60,-100; 60,-100; 40,-80; 60,-100; 40,-120],
                                                            style(
                color=10,
                rgbcolor={135,135,135},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[100,200; 80,200], style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[80,-400; 80,200], style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[100,0; 80,0],     style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[100,-200; 80,-200],
                                           style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[100,-400; 80,-400],
                                           style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Text(
              extent=[-6,238; 78,160],
              string="T",
              style(color=71, rgbcolor={85,170,255})),
            Text(
              extent=[-2,-362; 82,-440],
              style(color=71, rgbcolor={85,170,255}),
              string="R")),       Diagram(
            Line(points=[-80,-180; -80,-20; 80,-20; -80,-180],
                                                           style(
                color=10,
                rgbcolor={135,135,135},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[-80,-180; 80,-180; 80,-20; -80,-180],
                                                           style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[94,0; 80,0], style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Text(
              extent=[-10,-160; 70,-120],
              style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1),
              string="MBG"),
            Text(
              extent=[-68,-92; 18,-30],
              style(
                color=10,
                rgbcolor={135,135,135},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1),
              string="M 3D"),
            Line(points=[-60,-100; 60,-100; 40,-80; 60,-100; 40,-120],
                                                            style(
                color=10,
                rgbcolor={135,135,135},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[100,0; 80,0],     style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[100,200; 80,200], style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[100,-200; 80,-200],
                                           style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[100,-400; 80,-400],
                                           style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[80,-400; 80,200], style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Text(
              extent=[-6,238; 78,160],
              string="T",
              style(color=71, rgbcolor={85,170,255})),
            Text(
              extent=[-2,-362; 82,-440],
              style(color=71, rgbcolor={85,170,255}),
              string="R")),
          Coordsys(extent=[-100,-500; 100,300]),
          Documentation(info="<html>
This is a converter element. The signals and bond connections of a bondgraphic model
are converted into variables of the mechanical connector. This element enables the wrapping of bondgraphic
models and is acausal.
<p>
The converter element separates the translational and rotational domain, because
the according bondgraphic variables are resolved in different coordinate systems. The bondgraphic variables
of the translational domain are resolved in the inertial system, but the variables of the rotational domain are resolved in the body system, which is specified by the rotational matrix R.
</html>"));
        Frame_a frame_a annotation (extent=[-100,-120; -80,-80]);
        MultiBondLib.Interfaces.MultiBondCon MultiBondConRot(n=3)
          annotation (extent=[92,-410; 112,-390]);
        MultiBondLib.Interfaces.RealSignal x[3] annotation (extent=[90,-10; 110,10]);
        MultiBondLib.Interfaces.RealSignal R[3,3]
                                                annotation (extent=[90,-210; 110,-190]);
        MultiBondLib.Interfaces.MultiBondCon MultiBondConTrans(n=3)
          annotation (extent=[90,190; 110,210]);
      equation
        MultiBondConTrans.e*MultiBondConTrans.d = frame_a.f;
        MultiBondConRot.e*MultiBondConRot.d = frame_a.t;

        MultiBondConTrans.f = frame_a.P.v;
        MultiBondConRot.f = frame_a.P.w;

        x = frame_a.P.x;
        R = frame_a.P.R;
      end Mech2MBG;

    end Interfaces;
  annotation (Icon(
        Text(
          extent=[-120,122; 120,73],
          style(color=1),
        string="%name"),
        Polygon(points=[-100,50; -80,70; 100,70; 80,50; -100,50],      style(
            color=42,
            fillColor=30,
            fillPattern=1)),
        Polygon(points=[100,70; 100,-80; 80,-100; 80,50; 100,70],      style(
            color=42,
            fillColor=30,
            fillPattern=1)),
        Rectangle(extent=[-100,-100; 80,50],   style(
            color=42,
            fillColor=30,
            fillPattern=1)),
        Text(
          extent=[-85,35; 65,-85],
          string="Library",
          style(color=42))));
    package AdditionalMBG "Additional bondgraphic elements"
      extends Modelica.Icons.Library;

      model MGY
        "multiport gyrator according to the eulerian jucntion structure (models gyroscopic effect)"
        import MultiBondLib;
               extends MultiBondLib.Interfaces.PassiveOnePort(final n=3);
        parameter Real[3,3] I=identity(3) "Inductive Field";
      equation
        e = cross(f,I*f);

        annotation (Icon(
            Text(extent=[-100,106; 100,60],string="%name"),
            Text(
              extent=[-88,96; 88,-84],
              style(color=0, fillColor=0),
              string="mGY"),
            Text(extent=[-100,-60; 100,-100], string="I=%I"),
            Text(extent=[-74,-24; 66,-64],
              string="EJS",
              style(color=0, rgbcolor={0,0,0}))), Diagram(
            Text(
              extent=[-10,70; 10,50],
              string="1",
              style(
                color=10,
                rgbcolor={135,135,135},
                pattern=0,
                fillColor=10,
                rgbfillColor={95,95,95})),
            Text(
              extent=[-80,-50; -60,-70],
              string="1",
              style(
                color=10,
                rgbcolor={135,135,135},
                pattern=0,
                fillColor=10,
                rgbfillColor={95,95,95})),
            Text(
              extent=[60,-50; 80,-70],
              string="1",
              style(
                color=10,
                rgbcolor={135,135,135},
                pattern=0,
                fillColor=10,
                rgbfillColor={95,95,95})),
            Text(
              extent=[-48,10; -28,-10],
              style(
                color=10,
                rgbcolor={135,135,135},
                fillColor=10,
                rgbfillColor={95,95,95},
                fillPattern=1),
              string="mGY"),
            Text(
              extent=[30,10; 50,-10],
              style(
                color=10,
                rgbcolor={135,135,135},
                fillColor=10,
                rgbfillColor={95,95,95},
                fillPattern=1),
              string="mGY"),
            Text(
              extent=[-10,-50; 10,-70],
              style(
                color=10,
                rgbcolor={135,135,135},
                fillColor=10,
                rgbfillColor={95,95,95},
                fillPattern=1),
              string="mGY"),
            Line(points=[-6,50; -36,8; -26,10], style(
                color=10,
                rgbcolor={135,135,135},
                thickness=2,
                fillColor=10,
                rgbfillColor={95,95,95},
                fillPattern=1)),
            Line(points=[-40,-6; -70,-48; -60,-46], style(
                color=10,
                rgbcolor={135,135,135},
                thickness=2,
                fillColor=10,
                rgbfillColor={95,95,95},
                fillPattern=1)),
            Line(points=[-60,-60; -12,-60; -20,-52], style(
                color=10,
                rgbcolor={135,135,135},
                thickness=2,
                fillColor=10,
                rgbfillColor={95,95,95},
                fillPattern=1)),
            Line(points=[10,-60; 60,-60; 52,-52], style(
                color=10,
                rgbcolor={135,135,135},
                thickness=2,
                fillColor=10,
                rgbfillColor={95,95,95},
                fillPattern=1)),
            Line(points=[70,-48; 42,-6; 54,-10], style(
                color=10,
                rgbcolor={135,135,135},
                thickness=2,
                fillColor=10,
                rgbfillColor={95,95,95},
                fillPattern=1)),
            Line(points=[34,8; 6,50; 18,46], style(
                color=10,
                rgbcolor={135,135,135},
                thickness=2,
                fillColor=10,
                rgbfillColor={95,95,95},
                fillPattern=1)),
            Line(points=[-94,-82; -76,-64; -76,-74], style(
                color=10,
                rgbcolor={135,135,135},
                thickness=2,
                fillColor=10,
                rgbfillColor={95,95,95},
                fillPattern=1)),
            Line(points=[0,90; 0,70; 6,76], style(
                color=10,
                rgbcolor={135,135,135},
                thickness=2,
                fillColor=10,
                rgbfillColor={95,95,95},
                fillPattern=1)),
            Line(points=[90,-84; 74,-68; 84,-68], style(
                color=10,
                rgbcolor={135,135,135},
                thickness=2,
                fillColor=10,
                rgbfillColor={95,95,95},
                fillPattern=1)),
            Text(
              extent=[-96,-64; -84,-76],
              style(
                color=10,
                rgbcolor={135,135,135},
                fillColor=10,
                rgbfillColor={95,95,95},
                fillPattern=1),
              string="w[1]"),
            Text(
              extent=[70,-74; 82,-86],
              style(
                color=10,
                rgbcolor={135,135,135},
                fillColor=10,
                rgbfillColor={95,95,95},
                fillPattern=1),
              string="w[2]"),
            Text(
              extent=[-14,90; -2,78],
              style(
                color=10,
                rgbcolor={135,135,135},
                fillColor=10,
                rgbfillColor={95,95,95},
                fillPattern=1),
              string="w[3]"),
            Text(
              extent=[-88,-76; -78,-84],
              style(
                color=10,
                rgbcolor={135,135,135},
                fillColor=10,
                rgbfillColor={95,95,95},
                fillPattern=1),
              string="t[1]"),
            Text(
              extent=[86,-70; 96,-78],
              style(
                color=10,
                rgbcolor={135,135,135},
                fillColor=10,
                rgbfillColor={95,95,95},
                fillPattern=1),
              string="t[2]"),
            Text(
              extent=[4,88; 14,80],
              style(
                color=10,
                rgbcolor={135,135,135},
                fillColor=10,
                rgbfillColor={95,95,95},
                fillPattern=1),
              string="t[3]"),
            Text(
              extent=[-30,-2; -16,-10],
              style(
                color=9,
                rgbcolor={175,175,175},
                fillColor=10,
                rgbfillColor={95,95,95},
                fillPattern=1),
              string="L[2]"),
            Text(
              extent=[18,-2; 32,-10],
              style(
                color=9,
                rgbcolor={175,175,175},
                fillColor=10,
                rgbfillColor={95,95,95},
                fillPattern=1),
              string="L[1]"),
            Text(
              extent=[-8,-44; 6,-52],
              style(
                color=9,
                rgbcolor={175,175,175},
                fillColor=10,
                rgbfillColor={95,95,95},
                fillPattern=1),
              string="L[3]"),
            Text(
              extent=[-44,-16; 48,-42],
              style(
                color=0,
                rgbcolor={0,0,0},
                fillColor=10,
                rgbfillColor={95,95,95},
                fillPattern=1),
              string="Eulerian Junction Structure")),
          Documentation(info="<html>
This is the internally modulated multiport gyrator.
It consists in  a eulerian junction structure, as sketched in the modelling window.
<p>
This element models the gyroskopic force of a body element with the inertia tensor
specified by the parameter I.
</html>"));
      end MGY;

      model mTF "modulated transformer that transforms either flow or effort"
        import MultiBondLib;
        extends MultiBondLib.Interfaces.TwoPort;
        MultiBondLib.Interfaces.RealSignal M[n,n] "transformation matrix"
          annotation (extent=[-10,-110; 10,-90]);
        Modelica.Blocks.Interfaces.BooleanInput transformFlow
          annotation(extent=[-70,-110; -50,-90],
                                               rotation=90);

      equation
         if transformFlow then
          f2 = M*f1;
          e1 = transpose(M)*e2;
        else
          f1 = transpose(M)*f2;
          e2 = M*e1;
        end if;
        annotation (Icon(
            Text(extent=[-100,106; 100,60],string="%name"),
            Text(
              extent=[-88,68; 92,-72],
              style(color=0, fillColor=0),
              string="mTF")), Documentation(info="<html>
This is a special variant of the modulated transformer. The modulating real signal
is the (n x n) transformation matrix.
<p>
The boolean input signal determines, if the flow or the effort should be transformed
in arrow direction. If the singal value is true, the flow is transformed in direction of the arrow.
The physical meaning of the elements isn't influenced by this boolean signal, because the transformation matrix will always be a rotation matrix. Anyhow the efficiency of the code will be influenced by the right choice of the signal.
</html>"),Diagram(
            Text(
              extent=[-88,70; 92,-70],
              style(color=0, fillColor=0),
              string="mTF")));
      end mTF;

      model translationalTF "translational transformer"
        extends MultiBondLib.Interfaces.TwoPort(final n=3);
        parameter Real r[3] = {1,0,0}
                                    annotation(Evaluate=true);
        annotation (
          extent=[-10,-114; 10,-94],
          rotation=90,
          Diagram,
          Icon(
            Text(extent=[-100,90; 100,50],
                                         string="%name"),
            Text(
              extent=[-88,78; 92,-76],
              style(color=0, fillColor=0),
              string="TF"),
            Text(extent=[-100,-48; 100,-86],
                                           string="translational")),
          Documentation(info="<html>
This is the translational transformer. It couples the rotational domain at the arrow tail
with the translational domain at the arrow head. It is of fixed cardinality 3.
<p>
The angular velocity is transformed along a vector <b>r</b>.
This leads to the equation:<br>
<b>v</b> = <b>w</b> cross <b>r</b><br>
and in consequence:<br>
<b>t</b> = <b>r</b> cross <b>f</b><br>
<p>
<b>r</b> can be set by an parameter.
</html>"));
      equation

          f2 = cross(f1,r);
          e1 = cross(r,e2);

        annotation (Icon(
            Text(extent=[-74,92; 66,52], string="%name"),
            Text(extent=[-70,-50; 70,-90], string="translational"),
            Text(
              extent=[-86,78; 92,-76],
              style(color=0, fillColor=0),
              string="mTF")));
      end translationalTF;
      annotation (preferedView="info", Documentation(info="<html>
This package contains additional multibondgraphic elements.
These elements are specific for 3D-mechanical bondgraphic models. This is why they are found here and not in the MultiBondLib.
</html>"));
      model translational_mTF
        "translational transformer modulated by amplification"
        import MultiBondLib;
        extends MultiBondLib.Interfaces.TwoPort(final n=3);
        parameter Real r[3] = {1,0,0}
                                    annotation(Evaluate=true);
        annotation (
          extent=[-10,-114; 10,-94],
          rotation=90,
          Diagram,
          Icon(
            Text(extent=[-100,90; 100,50],
                                         string="%name"),
            Text(
              extent=[-90,90; 90,-90],
              style(color=0, fillColor=0),
              string="mTF"),
            Text(extent=[-100,-48; 100,-86],
                                           string="translational")),
          Documentation(info="<html>
This is a modulated translational transformer. It couples the rotational domain at the arrow tail
with the translational domain at the arrow head.<br> It is of fixed cardinality 3.
<p>
Different from the unmodulated translational transformer, the vector <b>r</b> can be amplified
by a real signal \"ampl\".
<p>
The angular velocity is then transformed along a vector <b>r</b>*ampl.
This leads to the equation:<br>
<b>v</b> = <b>w</b> cross (<b>r</b>*ampl)<br>
and in consequence:<br>
<b>t</b> = (<b>r</b>*ampl) cross <b>f</b><br>
<p>
<b>r</b> can be set by an parameter. This element is used to model a prismatic joint.
</html>"));
        MultiBondLib.Interfaces.RealSignal ampl annotation (extent=[-10,90; 10,110]);
      equation

          f2 = cross(f1,ampl*r);
          e1 = cross(ampl*r,e2);

        annotation (Icon(
            Text(extent=[-74,92; 66,52], string="%name"),
            Text(extent=[-70,-50; 70,-90], string="translational"),
            Text(
              extent=[-86,78; 92,-76],
              style(color=0, fillColor=0),
              string="mTF")));
      end translational_mTF;

      model translational_mTF2 "modulated translational transformer"
        import MultiBondLib;
        extends MultiBondLib.Interfaces.TwoPort(final n=3);
        annotation (
          extent=[-10,-114; 10,-94],
          rotation=90,
          Diagram,
          Icon(
            Text(extent=[-100,90; 100,50],
                                         string="%name"),
            Text(
              extent=[-90,90; 90,-90],
              style(color=0, fillColor=0),
              string="mTF"),
            Text(extent=[-100,-52; 100,-90],
                                           string="translational")),
          Documentation(info="<html>
This is a modulated translational transformer. It couples the rotational domain at the arrow tail
with the translational domain at the arrow head.
<br>It is of fixed cardinality 3.
<p>
Different from the unmodulated translational transformer, the vector <b>r</b> is not a parameter, it
is the modulating signal.
<p>
The angular velocity is then transformed along this vector <b>r</b>.
This leads to the equation:<br>
<b>v</b> = <b>w</b> cross <b>r</b><br>
and in consequence:<br>
<b>t</b> = <b>r</b> cross <b>f</b><br>
<p>
This element is useful to model a rollig wheel.
</html>"));
        MultiBondLib.Interfaces.RealSignal r[3] annotation (extent=[-10,90; 10,110]);
      equation

          f2 = cross(f1,r);
          e1 = cross(r,e2);

        annotation (Icon(
            Text(extent=[-74,92; 66,52], string="%name"),
            Text(extent=[-70,-50; 70,-90], string="translational"),
            Text(
              extent=[-86,78; 92,-76],
              style(color=0, fillColor=0),
              string="mTF")));
      end translational_mTF2;
    end AdditionalMBG;

    package Forces "force elements"
      extends Modelica.Icons.Library;

      model Damping "linear damping element"
        parameter Real d(
          final unit="N.s/m",
          final min=0) = 0 "Damping constant";
        Interfaces.Frame_a frame_a annotation (extent=[-120,-20; -100,20]);
        Interfaces.Frame_b frame_b annotation (extent=[100,-20; 120,20]);

        annotation (Diagram, Icon(
            Rectangle(extent=[-40,40; 20,-40], style(
                pattern=0,
                fillColor=30,
                rgbfillColor={215,215,215})),
            Line(points=[-100,0; -40,0; -40,40; 40,40], style(color=0, rgbcolor={0,0,
                    0})),
            Line(points=[-40,0; -40,-40; 42,-40], style(color=0, rgbcolor={0,0,0})),
            Line(points=[100,0; 0,0; 0,32; 0,-32], style(color=0, rgbcolor={0,0,0})),
            Text(
              extent=[-68,-50; -100,-20],
              string="a",
              style(
                color=9,
                rgbcolor={175,175,175},
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1)),
            Text(
              extent=[100,-50; 68,-20],
              style(
                color=9,
                rgbcolor={175,175,175},
                pattern=0,
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1),
              string="b"),
            Text(
              extent=[-100,112; 100,60],
              string="%name",
              style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1)),
            Text(
              extent=[-100,-60; 100,-106],
              style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1),
              string="d=%d")),
          Documentation(info="<html>
This is the model of a linear damper element.
<p>
The damper generates a counteracting force that is proportional to the
relative velocity.
<p>
The damping coefficient can be set by the parameter d.
</html>"));

      protected
        inner Defaults MBG_defaults(n=3) annotation (extent=[-80,60; -60,80]);
        Interfaces.Mech2MBG Mech2MBG1 annotation (extent=[-100,-40; -80,40]);
        Interfaces.MBG2Mech MBG2Mech1 annotation (extent=[80,-40; 100,40]);
        Junctions.J0 J0_1(n=3) annotation (extent=[-10,20; 10,40]);
        Passive.R R1(R={d}, n=3)     annotation (extent=[-10,80; 10,60],rotation=270);
        Junctions.J0 J0_2(n=3) annotation (extent=[-10,-40; 10,-20]);
        Sources.Se Se1(n=3, e0={0})
          annotation (extent=[-10,-80; 10,-60], rotation=270);
        Bonds.MultiBond MultiBond8      annotation (extent=[-10,-60; 10,-40],
            rotation=90);
        Bonds.MultiBond MultiBond3      annotation (extent=[-10,40; 10,60], rotation=90);
        Bonds.MultiBond MultiBond1      annotation (extent=[-30,20; -10,40]);
        Bonds.MultiBond MultiBond2      annotation (extent=[30,20; 10,40], rotation=0);
        Bonds.MultiBond MultiBond4      annotation (extent=[-30,-40; -10,-20]);
        Bonds.MultiBond MultiBond5      annotation (extent=[30,-40; 10,-20]);
        Bonds.Utilities.MultiBondTail MultiBondTail2
                                           annotation (extent=[-78,-40; -28,-20]);
        Bonds.Utilities.MultiBondTail MultiBondTail1
                                           annotation (extent=[28,-40; 78,-20],
            rotation=180);
        Bonds.Utilities.MultiBondTail MultiBondTail3
                                           annotation (extent=[-78,20; -28,40]);
        Bonds.Utilities.MultiBondTail MultiBondTail4
                                           annotation (extent=[78,20; 28,40]);

      equation
        connect(Mech2MBG1.frame_a, frame_a) annotation (points=[-99,0; -110,0],
                                style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(MultiBond1.MultiBondCon2, J0_1.MultiBondCon1)
          annotation (points=[-10,30; -10,30],
                                             style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond4.MultiBondCon2,J0_2. MultiBondCon1)
          annotation (points=[-10,-30; -10,-30],
                                             style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond8.MultiBondCon2, J0_2.MultiBondCon3) annotation (points=[
              6.12303e-016,-40; 0,-40], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=83,
            rgbfillColor={255,170,255},
            fillPattern=1));
        connect(MultiBond8.MultiBondCon1, Se1.MultiBondCon1) annotation (points=[
              -6.12303e-016,-60; 1.83691e-015,-60], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=83,
            rgbfillColor={255,170,255},
            fillPattern=1));
        connect(MultiBond5.MultiBondCon2, J0_2.MultiBondCon2) annotation (points=[10,-30;
              10,-30],      style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=83,
            rgbfillColor={255,170,255},
            fillPattern=1));
        connect(J0_1.MultiBondCon2, MultiBond2.MultiBondCon2)
          annotation (points=[10,30; 10,30], style(color=71, rgbcolor={85,170,255}));
        connect(MBG2Mech1.frame_b, frame_b) annotation (points=[99,0; 110,0], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(MultiBond3.MultiBondCon1, J0_1.MultiBondCon4) annotation (points=[
              -6.12303e-016,40; 0,40], style(color=71, rgbcolor={85,170,255}));
        connect(R1.MultiBondCon1, MultiBond3.MultiBondCon2) annotation (points=[
              1.83691e-015,60; 6.12303e-016,60], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond4.MultiBondCon1, Mech2MBG1.MultiBondConRot) annotation (
            points=[-30,-30; -79.8,-30], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond5.MultiBondCon1, MBG2Mech1.MultiBondConRot) annotation (
            points=[30,-30; 80,-30], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond2.MultiBondCon1, MBG2Mech1.MultiBondConTrans)
          annotation (points=[30,30; 80,30], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond1.MultiBondCon1, Mech2MBG1.MultiBondConTrans) annotation (
            points=[-30,30; -80,30],                 style(color=71, rgbcolor={85,170,
                255}));
      end Damping;

      model Spring "linear spring element"
        import SI = Modelica.SIunits;
        import MB = Modelica.Mechanics.MultiBody;

        Interfaces.Frame_a frame_a annotation (extent=[-120,-20; -100,20]);
        Interfaces.Frame_b frame_b annotation (extent=[100,-20; 120,20]);

        parameter Boolean animation = true "animate spring";

        parameter Real c(
          final unit="N/m",
          final min=0) = 0 "Spring constant";

        parameter SI.Position s0 = 0 "rest length of spring";
        parameter SI.Position s_small = 1e-4
          "|Advanced||critical Spring length";

        parameter SI.Distance width= world3D.defaultForceWidth
          "|Animation|if animation = true| Width of spring";
        parameter SI.Distance coilWidth=width/5
          "|Animation|if animation = true| Width of spring coil";
        parameter Integer numberOfWindings=5
          "|Animation|if animation = true| Number of spring windings";
        parameter MB.Types.Color color= world3D.defaultForceElementColor
          "|Animation|if animation = true| Color of spring";

        SI.Distance s;
        SI.Distance d[3];
        SI.Force f[3];
        annotation (Diagram(
            Rectangle(extent=[32,100; 52,80], style(color=10, rgbcolor={135,135,135})),
            Line(points=[-74,-10; -64,-10; -64,90; 32,90], style(color=10, rgbcolor={
                    135,135,135})),
            Text(
              extent=[32,94; 52,84],
              string="Distance",
              style(color=10, rgbcolor={135,135,135})),
            Line(points=[74,90; 74,-10], style(color=10, rgbcolor={135,135,135})),
            Line(points=[78,-10; 74,-10], style(color=10, rgbcolor={135,135,135})),
            Line(points=[44,80; 44,70; 30,70], style(color=10, rgbcolor={135,135,135})),
            Polygon(points=[30,80; 30,60; 10,70; 30,80], style(color=10, rgbcolor={
                    135,135,135})),
            Text(
              extent=[20,60; 40,50],
              style(color=74, rgbcolor={0,0,196}),
              string="Gain=c"),
            Line(points=[10,70; 0,70; 0,64], style(color=10, rgbcolor={135,135,135})),
            Line(points=[74,90; 52,90], style(color=10, rgbcolor={135,135,135}))),
                             Icon(
            Text(
              extent=[-100,100; 100,48],
              string="%name",
              style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1)),
            Line(points=[-100,0; -80,0; -40,40; 40,-40], style(color=0, rgbcolor={0,0,
                    0})),
            Ellipse(extent=[-10,10; 10,-10], style(
                pattern=0,
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1)),
            Line(points=[40,-40; 80,0; 100,0], style(color=0, rgbcolor={0,0,0})),
            Text(
              extent=[100,-50; 68,-20],
              style(
                color=9,
                rgbcolor={175,175,175},
                pattern=0,
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1),
              string="b"),
            Text(
              extent=[-100,-46; 100,-92],
              style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1),
              string="c=%c"),
            Text(
              extent=[-68,-50; -100,-20],
              string="a",
              style(
                color=9,
                rgbcolor={175,175,175},
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1))),
          Documentation(info="<html>
This is the model of a linear spring.
<p>
<img src=\"../Images/Spring.png\">
</p>
<p>
The spring generates a counteracting force that is linear dependent on the positional shift.
<p>
The spring coefficient can be set by the parameter c. The rest lenght can be specified by the parameter s0.
<p>
A spring with a rest length s0 unequal to zero, has a stiff behavior if its length is approaching zero.
The parameter s_small in the advanced menu reduces this stiffness for spring lengths ranging from zero up to s_small.
<h3>Visualization</h3>
This element is visualized by a coil. Further specifications can be made by the parameters in the animation group.
</html>"));

      protected
        outer World3D world3D;
        inner Defaults MBG_defaults(n=3) annotation (extent=[-100,60; -80,80]);

        Interfaces.MBG2Mech MBG2Mech1 annotation (extent=[80,-60; 100,20]);
        Interfaces.Mech2MBG Mech2MBG1 annotation (extent=[-100,-60; -80,20]);

        Junctions.J0 J0_1(n=3) annotation (extent=[-10,0; 10,20]);
        Junctions.J0 J0_2(n=3) annotation (extent=[-10,-60; 10,-40]);
        Sources.Se Se1(n=3, e0={0})
          annotation (extent=[-10,-100; 10,-80],rotation=270);
        Sources.mSe mSe1(n=3)
                         annotation (extent=[-10,40; 10,60], rotation=90);
        Bonds.MultiBond MultiBond8      annotation (extent=[-10,-80; 10,-60],
                                                                            rotation=90);
        Bonds.MultiBond MultiBond3      annotation (extent=[-10,20; 10,40], rotation=
              270);
        Bonds.MultiBond MultiBond1      annotation (extent=[-30,0; -10,20]);
        Bonds.MultiBond MultiBond2      annotation (extent=[60,0; 80,20],  rotation=0);
        Bonds.MultiBond MultiBond4      annotation (extent=[-30,-60; -10,-40]);
        Bonds.MultiBond MultiBond5      annotation (extent=[30,-60; 10,-40]);
        Bonds.Utilities.MultiBondTail MultiBondTail2
                                           annotation (extent=[-78,-60; -28,-40]);
        Bonds.Utilities.MultiBondTail MultiBondTail1
                                           annotation (extent=[28,-60; 80,-40],
            rotation=180);
        Bonds.Utilities.MultiBondTail MultiBondTail3
                                           annotation (extent=[-78,0; -28,20]);
        Bonds.Utilities.MultiBondTail MultiBondTail4
                                           annotation (extent=[16,0; 62,20]);

        parameter Integer ndim=if world3D.enableAnimation and animation then 1 else 0;
        MB.Visualizers.Advanced.Shape springShape[ndim](
          each shapeType="spring",
          each color=color,
          each length=s,
          each width=width,
          each height=coilWidth,
          each lengthDirection=d,
          each widthDirection={0,0,1},
          each r_shape={0,0,0},
          each r=MBG2Mech1.x,
          each extra=numberOfWindings,
          each R=MB.Frames.Orientation(T=identity(3),w=zeros(3)));

      equation
        //equations to compute the spring force
        d = Mech2MBG1.x - MBG2Mech1.x;
        s = sqrt(d*d);
        f = if s >= s_small then c*d - s0*c*(d/s) else c*d - s0*c*(d/s_small);
        mSe1.s = f;

        connect(Mech2MBG1.frame_a, frame_a) annotation (points=[-99,-20; -118,-20;
              -118,0; -110,0],  style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(MBG2Mech1.frame_b, frame_b) annotation (points=[99,-20; 100,-20; 100,
              -2; 106,-2; 106,0; 110,0],
                         style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(MultiBond1.MultiBondCon2, J0_1.MultiBondCon1)
          annotation (points=[-10,10; -10,10],
                                             style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond4.MultiBondCon2,J0_2. MultiBondCon1)
          annotation (points=[-10,-50; -10,-50],
                                             style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond5.MultiBondCon2, J0_2.MultiBondCon2) annotation (points=[10,-50;
              10,-50],      style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=83,
            rgbfillColor={255,170,255},
            fillPattern=1));
        connect(MultiBond3.MultiBondCon2, J0_1.MultiBondCon4) annotation (points=[
              -1.83691e-015,20; 0,20], style(color=71, rgbcolor={85,170,255}));
        connect(mSe1.MultiBondCon1, MultiBond3.MultiBondCon1) annotation (points=[
              -6.12303e-016,40; 1.83691e-015,40], style(color=71, rgbcolor={85,170,
                255}));
        connect(MultiBond1.MultiBondCon1, Mech2MBG1.MultiBondConTrans) annotation (points=[-30,10;
              -80,10],         style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond8.MultiBondCon2, J0_2.MultiBondCon3) annotation (points=[
              6.12303e-016,-60; 0,-60], style(color=71, rgbcolor={85,170,255}));
        connect(Se1.MultiBondCon1, MultiBond8.MultiBondCon1) annotation (points=[
              1.83691e-015,-80; -6.12303e-016,-80], style(color=71, rgbcolor={85,170,
                255}));
        connect(MultiBond5.MultiBondCon1, MBG2Mech1.MultiBondConRot) annotation (
            points=[30,-50; 80,-50], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond4.MultiBondCon1, Mech2MBG1.MultiBondConRot) annotation (
            points=[-30,-50; -79.8,-50], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond2.MultiBondCon2, MBG2Mech1.MultiBondConTrans)
          annotation (points=[80,10; 80,10], style(color=71, rgbcolor={85,170,
                255}));
        connect(MultiBond2.MultiBondCon1, J0_1.MultiBondCon2) annotation (
            points=[60,10; 10,10], style(color=71, rgbcolor={85,170,255}));
      end Spring;

      model WorldForce "world force acting on frame"
        import SI = Modelica.SIunits;
        import MB = Modelica.Mechanics.MultiBody;

        Interfaces.Frame_b frame_b annotation (extent=[100,-20; 120,20]);

      protected
        outer World3D world3D;
        inner Defaults MBG_defaults(n=3) annotation (extent=[-100,60; -80,80]);

        Interfaces.MBG2Mech MBG2Mech1 annotation (extent=[60,-40; 80,40]);
        annotation (Diagram, Icon(
            Text(
              extent=[-100,100; 100,48],
              string="%name",
              style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1)),
            Polygon(points=[98,0; 20,60; 20,20; -68,20; -68,-20; 20,-20; 20,-60;
                  98,0],
                style(
                color=58,
                rgbcolor={0,127,0},
                fillColor=2,
                rgbfillColor={0,255,0}))),
          Documentation(info="<html>
This element applies an artificially generated force on the connector.
<p>
The force vector has to be given by an input signal and is resolved in the inertial system.
</html>"));

        Bonds.MultiBond MultiBond1      annotation (extent=[40,-40; 60,-20]);

        Sources.Se Se2(n=3, e0={0})
          annotation (extent=[20,-40; 40,-20],  rotation=180);
        Bonds.MultiBond MultiBond4      annotation (extent=[40,20; 60,40]);
      public
        Modelica.Blocks.Interfaces.RealInput force[3]
          annotation (extent=[-114,-10; -94,10]);
        Sources.mSe mSe1 annotation (extent=[40,20; 20,40]);
      equation

        connect(MBG2Mech1.frame_b, frame_b) annotation (points=[79,0; 100,0;
              100,-2; 106,-2; 106,0; 110,0],
                         style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(MultiBond1.MultiBondCon2, MBG2Mech1.MultiBondConRot) annotation (
            points=[60,-30; 60,-30], style(color=71, rgbcolor={85,170,255}));
        connect(Se2.MultiBondCon1, MultiBond1.MultiBondCon1) annotation (points=[40,-30;
              40,-30],      style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond4.MultiBondCon2, MBG2Mech1.MultiBondConTrans)
          annotation (points=[60,30; 60,30], style(color=71, rgbcolor={85,170,255}));
        connect(mSe1.MultiBondCon1, MultiBond4.MultiBondCon1) annotation (points=[40,30; 40,
              30], style(color=71, rgbcolor={85,170,255}));
        connect(force, mSe1.s) annotation (points=[-104,0; -30,0; -30,30; 20.2,
              30], style(color=74, rgbcolor={0,0,127}));
      end WorldForce;

      model WorldTorque "world torque acting on frame"
        import SI = Modelica.SIunits;
        import MB = Modelica.Mechanics.MultiBody;

        Interfaces.Frame_b frame_b annotation (extent=[100,-20; 120,20]);

      protected
        outer World3D world3D;
        inner Defaults MBG_defaults(n=3) annotation (extent=[-100,60; -80,80]);
        Interfaces.MBG2Mech MBG2Mech1 annotation (extent=[60,-40; 80,40]);
        annotation (Diagram, Icon(
            Text(
              extent=[-100,100; 100,48],
              string="%name",
              style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1)),
            Polygon(points=[96,0; 18,60; 18,20; -70,20; -70,-20; 18,-20; 18,-60;
                  96,0], style(
                color=58,
                rgbcolor={0,127,0},
                fillColor=60,
                rgbfillColor={170,255,170})),
            Polygon(points=[66,0; -12,60; -12,20; -70,20; -70,-20; -12,-20; -12,
                  -60; 66,0],
                style(
                color=58,
                rgbcolor={0,127,0},
                fillColor=2,
                rgbfillColor={0,255,0}))),
          Documentation(info="<html>
This element applies an artificially generated torque on the connector.
<p>
The torque vector has to be given by an input signal and is resolved in the inertial system.
</html>"));
        Bonds.MultiBond MultiBond1      annotation (extent=[0,-40; 20,-20]);
        Sources.Se Se1(e0={0})
          annotation (extent=[20,20; 40,40],    rotation=180);
        Bonds.MultiBond MultiBond4      annotation (extent=[40,20; 60,40]);
        Passive.mTF_effort mTF_effort1 annotation (extent=[20,-20; 40,-40]);
        Bonds.MultiBond MultiBond2      annotation (extent=[40,-40; 60,-20]);

      public
        Sources.mSe mSe1 annotation (extent=[0,-40; -20,-20]);
        Modelica.Blocks.Interfaces.RealInput torque[3]
          annotation (extent=[-114,-10; -94,10]);
      equation
        connect(MBG2Mech1.frame_b, frame_b) annotation (points=[79,0; 100,0;
              100,-2; 106,-2; 106,0; 110,0],
                         style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(MultiBond4.MultiBondCon2, MBG2Mech1.MultiBondConTrans)
          annotation (points=[60,30; 60,30], style(color=71, rgbcolor={85,170,255}));
        connect(Se1.MultiBondCon1, MultiBond4.MultiBondCon1)
          annotation (points=[40,30; 40,30], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond2.MultiBondCon2, MBG2Mech1.MultiBondConRot) annotation (
            points=[60,-30; 60,-30], style(color=71, rgbcolor={85,170,255}));
        connect(mTF_effort1.MultiBondCon2, MultiBond2.MultiBondCon1) annotation (
            points=[40,-30; 40,-30], style(color=71, rgbcolor={85,170,255}));
        connect(mTF_effort1.MultiBondCon1, MultiBond1.MultiBondCon2) annotation (
            points=[20,-30; 20,-30], style(color=71, rgbcolor={85,170,255}));
        connect(mTF_effort1.M, MBG2Mech1.R) annotation (points=[30,-20; 30,-10;
              60,-10],
                    style(color=3, rgbcolor={0,0,255}));
        connect(torque, mSe1.s) annotation (points=[-104,0; -30,0; -30,-30;
              -19.8,-30], style(color=74, rgbcolor={0,0,127}));
        connect(mSe1.MultiBondCon1, MultiBond1.MultiBondCon1) annotation (
            points=[0,-30; 0,-30], style(color=71, rgbcolor={85,170,255}));
      end WorldTorque;

      annotation (preferedView="info", Documentation(info="<html>
This package contains force elements.
These elements cause a force to act on or between mechanical elements.
<p>
There are mainly three types of force elements:
<ul>
<li>physical interactions like spring or damper elements
<li>soft collision models, that include geometric computations
<li>artificially generated forces
</ul>
<p>
Elements of this package do not create rigid connections and therefore do not close
kinematic loops.
</html>"));
      model BodyForce "body force acting on frame"
        import SI = Modelica.SIunits;
        import MB = Modelica.Mechanics.MultiBody;

        Interfaces.Frame_b frame_b annotation (extent=[100,-20; 120,20]);

      protected
        outer World3D world3D;
        inner Defaults MBG_defaults(n=3) annotation (extent=[-100,60; -80,80]);

        Interfaces.MBG2Mech MBG2Mech1 annotation (extent=[60,-40; 80,40]);
        annotation (Diagram, Icon(
            Text(
              extent=[-100,100; 100,48],
              string="%name",
              style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1)),
            Polygon(points=[98,0; 20,60; 20,20; -68,20; -68,-20; 20,-20; 20,-60;
                  98,0],
                style(
                color=58,
                rgbcolor={0,127,0},
                fillColor=2,
                rgbfillColor={0,255,0}))),
          Documentation(info="<html>
This element applies an artificially generated force on the connector.
<p>
The force vector has to be given by an input signal and is resolved in the corresponding body system.
</html>"));

        Bonds.MultiBond MultiBond1      annotation (extent=[40,-40; 60,-20]);

        Sources.Se Se2(n=3, e0={0})
          annotation (extent=[20,-40; 40,-20],  rotation=180);
        Bonds.MultiBond MultiBond4      annotation (extent=[40,20; 60,40]);
      public
        Modelica.Blocks.Interfaces.RealInput force[3]
          annotation (extent=[-114,-10; -94,10]);
        Sources.mSe mSe1 annotation (extent=[0,20; -20,40]);
      protected
        Passive.mTF_effort mTF_effort1 annotation (extent=[20,20; 40,40]);
        Bonds.MultiBond MultiBond2      annotation (extent=[0,20; 20,40]);
      equation

        connect(MBG2Mech1.frame_b, frame_b) annotation (points=[79,0; 100,0;
              100,-2; 106,-2; 106,0; 110,0],
                         style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(MultiBond1.MultiBondCon2, MBG2Mech1.MultiBondConRot) annotation (
            points=[60,-30; 60,-30], style(color=71, rgbcolor={85,170,255}));
        connect(Se2.MultiBondCon1, MultiBond1.MultiBondCon1) annotation (points=[40,-30;
              40,-30],      style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond4.MultiBondCon2, MBG2Mech1.MultiBondConTrans)
          annotation (points=[60,30; 60,30], style(color=71, rgbcolor={85,170,255}));
        connect(force, mSe1.s) annotation (points=[-104,0; -30,0; -30,30; -19.8,30], style(
              color=74, rgbcolor={0,0,127}));
        connect(MultiBond2.MultiBondCon1, mSe1.MultiBondCon1) annotation (
            points=[0,30; 0,30], style(color=71, rgbcolor={85,170,255}));
        connect(mTF_effort1.MultiBondCon1, MultiBond2.MultiBondCon2)
          annotation (points=[20,30; 20,30], style(color=71, rgbcolor={85,170,
                255}));
        connect(MultiBond4.MultiBondCon1, mTF_effort1.MultiBondCon2)
          annotation (points=[40,30; 40,30], style(color=71, rgbcolor={85,170,
                255}));
        connect(MBG2Mech1.R, mTF_effort1.M) annotation (points=[60,-10; 30,-10;
              30,20], style(color=3, rgbcolor={0,0,255}));
      end BodyForce;

      model BodyTorque "body torque acting on frame"
        import SI = Modelica.SIunits;
        import MB = Modelica.Mechanics.MultiBody;

        Interfaces.Frame_b frame_b annotation (extent=[100,-20; 120,20]);

      protected
        outer World3D world3D;
        inner Defaults MBG_defaults(n=3) annotation (extent=[-100,60; -80,80]);
        Interfaces.MBG2Mech MBG2Mech1 annotation (extent=[60,-40; 80,40]);
        annotation (Diagram, Icon(
            Text(
              extent=[-100,100; 100,48],
              string="%name",
              style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1)),
            Polygon(points=[96,0; 18,60; 18,20; -70,20; -70,-20; 18,-20; 18,-60;
                  96,0], style(
                color=58,
                rgbcolor={0,127,0},
                fillColor=60,
                rgbfillColor={170,255,170})),
            Polygon(points=[66,0; -12,60; -12,20; -70,20; -70,-20; -12,-20; -12,
                  -60; 66,0],
                style(
                color=58,
                rgbcolor={0,127,0},
                fillColor=2,
                rgbfillColor={0,255,0}))),
          Documentation(info="<html>
This element applies an artificially generated torque on the connector.
<p>
The torque vector has to be given by an input signal and is resolved in the corresponding body system.
</html>"));
        Bonds.MultiBond MultiBond1      annotation (extent=[40,-40; 60,-20]);
        Sources.Se Se1(e0={0})
          annotation (extent=[20,20; 40,40],    rotation=180);
        Bonds.MultiBond MultiBond4      annotation (extent=[40,20; 60,40]);

      public
        Sources.mSe mSe1 annotation (extent=[40,-40; 20,-20]);
        Modelica.Blocks.Interfaces.RealInput torque[3]
          annotation (extent=[-114,-10; -94,10]);
      equation
        connect(MBG2Mech1.frame_b, frame_b) annotation (points=[79,0; 100,0;
              100,-2; 106,-2; 106,0; 110,0],
                         style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(MultiBond4.MultiBondCon2, MBG2Mech1.MultiBondConTrans)
          annotation (points=[60,30; 60,30], style(color=71, rgbcolor={85,170,255}));
        connect(Se1.MultiBondCon1, MultiBond4.MultiBondCon1)
          annotation (points=[40,30; 40,30], style(color=71, rgbcolor={85,170,255}));
        connect(torque, mSe1.s) annotation (points=[-104,0; -30,0; -30,-30; 20.2,-30],
            style(color=74, rgbcolor={0,0,127}));
        connect(mSe1.MultiBondCon1, MultiBond1.MultiBondCon1) annotation (
            points=[40,-30; 40,-30], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond1.MultiBondCon2, MBG2Mech1.MultiBondConRot)
          annotation (points=[60,-30; 60,-30], style(color=71, rgbcolor={85,170,
                255}));
      end BodyTorque;

      model Force "force acting between two frames"
        import SI = Modelica.SIunits;
        import MB = Modelica.Mechanics.MultiBody;

        Interfaces.Frame_b frame_b annotation (extent=[100,-20; 120,20]);

      protected
        outer World3D world3D;
        inner Defaults MBG_defaults(n=3) annotation (extent=[-100,60; -80,80]);

        Interfaces.MBG2Mech MBG2Mech1 annotation (extent=[60,-80; 80,0]);
        annotation (Diagram, Icon(
            Text(
              extent=[-100,100; 100,48],
              string="%name",
              style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1)),
            Text(
              extent=[-100,-54; 100,-100],
              string="force",
              style(
                color=10,
                rgbcolor={95,95,95},
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1)),
            Polygon(points=[98,0; 20,54; 20,14; -100,14; -100,-14; 20,-14; 20,
                  -52; 98,0],
                style(
                color=58,
                rgbcolor={0,127,0},
                fillColor=2,
                rgbfillColor={0,255,0})),
            Text(
              extent=[-68,-50; -100,-20],
              string="a",
              style(
                color=9,
                rgbcolor={175,175,175},
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1)),
            Text(
              extent=[100,-50; 68,-20],
              style(
                color=9,
                rgbcolor={175,175,175},
                pattern=0,
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1),
              string="b")),
          Documentation(info="<html>
This element applies an artificially generated force between the two frames.

<p>
The force vector has to be given by an input signal.
The force acts from frame a on frame b and is resolved in the body system of frame a.
</html>"));

        Bonds.MultiBond MultiBond1      annotation (extent=[40,-80; 60,-60]);

        Sources.Se Se2(n=3, e0={0})
          annotation (extent=[-10,-48; 10,-28], rotation=90);
        Bonds.MultiBond MultiBond4      annotation (extent=[40,-20; 60,0]);
      public
        Modelica.Blocks.Interfaces.RealInput force[3]
          annotation (extent=[-10,94; 10,114], rotation=270);
        Sources.mSe mSe1 annotation (extent=[10,60; -10,80], rotation=90);
        Interfaces.Frame_a frame_a annotation (extent=[-120,-20; -100,20]);
        Interfaces.Mech2MBG mech2MBG annotation (extent=[-80,-80; -60,0]);
      protected
        Bonds.MultiBond MultiBond2      annotation (extent=[-30,-20; -10,0]);
        Bonds.MultiBond MultiBond3      annotation (extent=[-30,-80; -10,-60]);
      public
        Junctions.J0 j0_1 annotation (extent=[-10,-20; 10,0]);
        Junctions.J0 j0_2 annotation (extent=[-10,-80; 10,-60]);
      protected
        Bonds.MultiBond MultiBond5      annotation (extent=[-10,0; 10,20],
            rotation=270);
        Bonds.MultiBond MultiBond6      annotation (extent=[-10,-60; 10,-48],
            rotation=270);
      public
        Bonds.Utilities.MultiBondTail multiBondTail
          annotation (extent=[-60,-20; -28,0]);
        Bonds.Utilities.MultiBondTail multiBondTail1
          annotation (extent=[10,-20; 42,0]);
        Bonds.Utilities.MultiBondTail multiBondTail2
          annotation (extent=[10,-80; 42,-60]);
        Bonds.Utilities.MultiBondTail multiBondTail3
          annotation (extent=[-58,-80; -26,-60]);
      protected
        Bonds.MultiBond MultiBond7      annotation (extent=[-10,40; 10,60],
            rotation=270);
      public
        Passive.mTF_flow mTF_flow
          annotation (extent=[-10,40; 10,20], rotation=270);
      equation

        connect(MBG2Mech1.frame_b, frame_b) annotation (points=[79,-40; 100,-40;
              100,-2; 106,-2; 106,0; 110,0],
                         style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(MultiBond1.MultiBondCon2, MBG2Mech1.MultiBondConRot) annotation (
            points=[60,-70; 60,-70], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond4.MultiBondCon2, MBG2Mech1.MultiBondConTrans)
          annotation (points=[60,-10; 60,-10],
                                             style(color=71, rgbcolor={85,170,255}));
        connect(force, mSe1.s) annotation (points=[0,104; 0,79.8; -6.00057e-016,
              79.8],
                   style(color=74, rgbcolor={0,0,127}));
        connect(mech2MBG.frame_a, frame_a) annotation (points=[-79,-40; -100,
              -40; -100,0; -110,0], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(MultiBond4.MultiBondCon1, j0_1.MultiBondCon2) annotation (
            points=[40,-10; 10,-10], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond1.MultiBondCon1, j0_2.MultiBondCon2) annotation (
            points=[40,-70; 10,-70], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond3.MultiBondCon2, j0_2.MultiBondCon1) annotation (
            points=[-10,-70; -10,-70], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond2.MultiBondCon2, j0_1.MultiBondCon1) annotation (
            points=[-10,-10; -10,-10], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond2.MultiBondCon1, mech2MBG.MultiBondConTrans)
          annotation (points=[-30,-10; -60,-10], style(color=71, rgbcolor={85,
                170,255}));
        connect(MultiBond3.MultiBondCon1, mech2MBG.MultiBondConRot) annotation (
           points=[-30,-70; -59.8,-70], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond6.MultiBondCon1, Se2.MultiBondCon1) annotation (points=[
              1.83691e-015,-48; -6.12303e-016,-48], style(color=71, rgbcolor={
                85,170,255}));
        connect(MultiBond7.MultiBondCon1, mSe1.MultiBondCon1) annotation (
            points=[1.83691e-015,60; 6.12303e-016,60], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=60,
            rgbfillColor={170,255,170},
            fillPattern=1));
        connect(MultiBond5.MultiBondCon2, j0_1.MultiBondCon4) annotation (
            points=[-1.83691e-015,0; 0,0], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=60,
            rgbfillColor={170,255,170},
            fillPattern=1));
        connect(MultiBond6.MultiBondCon2, j0_2.MultiBondCon4) annotation (
            points=[-1.83691e-015,-60; 0,-60], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=60,
            rgbfillColor={170,255,170},
            fillPattern=1));
        connect(mTF_flow.MultiBondCon2, MultiBond7.MultiBondCon2) annotation (
            points=[-1.83691e-015,40; -1.83691e-015,40], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=60,
            rgbfillColor={170,255,170},
            fillPattern=1));
        connect(mTF_flow.MultiBondCon1, MultiBond5.MultiBondCon1) annotation (
            points=[1.83691e-015,20; 1.83691e-015,20], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=60,
            rgbfillColor={170,255,170},
            fillPattern=1));
        connect(mech2MBG.R, mTF_flow.M) annotation (points=[-60,-50; -40,-50;
              -40,30; -10,30], style(
            color=3,
            rgbcolor={0,0,255},
            fillColor=60,
            rgbfillColor={170,255,170},
            fillPattern=1));
      end Force;

      model Torque "torque acting between two frames"
        import SI = Modelica.SIunits;
        import MB = Modelica.Mechanics.MultiBody;

        Interfaces.Frame_b frame_b annotation (extent=[100,-20; 120,20]);

      protected
        outer World3D world3D;
        inner Defaults MBG_defaults(n=3) annotation (extent=[-60,60; -40,80]);

        Interfaces.MBG2Mech MBG2Mech1 annotation (extent=[80,-40; 100,40]);
        annotation (Diagram, Icon(
            Polygon(points=[98,0; 20,54; 20,14; -80,14; -80,-14; 20,-14; 20,-52;
                  98,0], style(
                color=58,
                rgbcolor={0,127,0},
                fillColor=60,
                rgbfillColor={170,255,170})),
            Text(
              extent=[-100,100; 100,48],
              string="%name",
              style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1)),
            Text(
              extent=[-100,-54; 100,-100],
              style(
                color=10,
                rgbcolor={95,95,95},
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1),
              string="torque"),
            Polygon(points=[78,0; 0,54; 0,14; -100,14; -100,-14; 0,-14; 0,-52;
                  78,0],
                style(
                color=58,
                rgbcolor={0,127,0},
                fillColor=2,
                rgbfillColor={0,255,0})),
            Text(
              extent=[-68,-50; -100,-20],
              string="a",
              style(
                color=9,
                rgbcolor={175,175,175},
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1)),
            Text(
              extent=[100,-50; 68,-20],
              style(
                color=9,
                rgbcolor={175,175,175},
                pattern=0,
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1),
              string="b")),
          Documentation(info="<html>
This element applies an artificially generated torque between the two frames.
<p>
The torque vector has to be given by an input signal.
The torque acts from frame a on frame b and is resolved in the body system of frame a.
</html>"));

        Bonds.MultiBond MultiBond1      annotation (extent=[60,-40; 80,-20]);

        Sources.Se Se2(n=3, e0={0})
          annotation (extent=[-60,20; -40,40],  rotation=0);
        Bonds.MultiBond MultiBond4      annotation (extent=[60,20; 80,40]);
      public
        Modelica.Blocks.Interfaces.RealInput torque[3]
          annotation (extent=[-10,94; 10,114], rotation=270);
        Sources.mSe mSe1 annotation (extent=[-20,0; -40,20], rotation=90);
        Interfaces.Frame_a frame_a annotation (extent=[-120,-20; -100,20]);
        Interfaces.Mech2MBG mech2MBG annotation (extent=[-100,-40; -80,40]);
      protected
        Bonds.MultiBond MultiBond3      annotation (extent=[-60,-40; -40,-20]);
      public
        Junctions.J0 j0_2 annotation (extent=[-40,-40; -20,-20]);
      protected
        Bonds.MultiBond MultiBond5      annotation (extent=[-80,40; -60,20],
            rotation=180);
        Bonds.MultiBond MultiBond6      annotation (extent=[-40,-20; -20,0],
            rotation=270);
      public
        Bonds.Utilities.MultiBondTail multiBondTail3
          annotation (extent=[-78,-40; -58,-20]);
      protected
        Sources.Se Se1(n=3, e0={0})
          annotation (extent=[60,20; 40,40],    rotation=0);
      public
        Passive.mTF_effort mTF_effort annotation (extent=[40,-20; 60,-40]);
      protected
        Bonds.MultiBond MultiBond2      annotation (extent=[20,-40; 40,-20]);
      public
        Passive.mTF_flow mTF_flow
          annotation (extent=[0,-40; 20,-20], rotation=180);
      protected
        Bonds.MultiBond MultiBond7      annotation (extent=[-20,-40; 0,-20]);
      equation

        connect(MBG2Mech1.frame_b, frame_b) annotation (points=[99,0; 110,0],
                         style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(MultiBond1.MultiBondCon2, MBG2Mech1.MultiBondConRot) annotation (
            points=[80,-30; 80,-30], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond4.MultiBondCon2, MBG2Mech1.MultiBondConTrans)
          annotation (points=[80,30; 80,30], style(color=71, rgbcolor={85,170,255}));
        connect(mech2MBG.frame_a, frame_a) annotation (points=[-99,0; -110,0], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(MultiBond3.MultiBondCon2, j0_2.MultiBondCon1) annotation (points=[-40,-30;
              -40,-30], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond3.MultiBondCon1, mech2MBG.MultiBondConRot) annotation (
           points=[-60,-30; -79.8,-30], style(color=71, rgbcolor={85,170,255}));
        connect(mSe1.MultiBondCon1, MultiBond6.MultiBondCon1) annotation (
            points=[-30,0; -30,0], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=60,
            rgbfillColor={170,255,170},
            fillPattern=1));
        connect(MultiBond5.MultiBondCon2, mech2MBG.MultiBondConTrans)
          annotation (points=[-80,30; -80,30], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=60,
            rgbfillColor={170,255,170},
            fillPattern=1));
        connect(Se2.MultiBondCon1, MultiBond5.MultiBondCon1) annotation (points=
             [-60,30; -60,30], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=60,
            rgbfillColor={170,255,170},
            fillPattern=1));
        connect(Se1.MultiBondCon1, MultiBond4.MultiBondCon1) annotation (points=
             [60,30; 60,30], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=60,
            rgbfillColor={170,255,170},
            fillPattern=1));
        connect(mSe1.s, torque) annotation (points=[-30,19.8; -30,60; 0,60; 0,
              104], style(
            color=3,
            rgbcolor={0,0,255},
            fillColor=60,
            rgbfillColor={170,255,170},
            fillPattern=1));
        connect(mTF_effort.MultiBondCon2, MultiBond1.MultiBondCon1) annotation (
           points=[60,-30; 60,-30], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=60,
            rgbfillColor={170,255,170},
            fillPattern=1));
        connect(mTF_effort.M, MBG2Mech1.R) annotation (points=[50,-20; 50,-4;
              80,-4; 80,-10], style(
            color=3,
            rgbcolor={0,0,255},
            fillColor=60,
            rgbfillColor={170,255,170},
            fillPattern=1));
        connect(mTF_flow.MultiBondCon1, MultiBond2.MultiBondCon1) annotation (
            points=[20,-30; 20,-30], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=60,
            rgbfillColor={170,255,170},
            fillPattern=1));
        connect(mech2MBG.R, mTF_flow.M) annotation (points=[-80,-10; -80,-4; 10,
              -4; 10,-20], style(
            color=3,
            rgbcolor={0,0,255},
            fillColor=60,
            rgbfillColor={170,255,170},
            fillPattern=1));
        connect(MultiBond7.MultiBondCon2, mTF_flow.MultiBondCon2) annotation (
            points=[0,-30; 0,-30], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=60,
            rgbfillColor={170,255,170},
            fillPattern=1));
        connect(MultiBond7.MultiBondCon1, j0_2.MultiBondCon2) annotation (
            points=[-20,-30; -20,-30], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=60,
            rgbfillColor={170,255,170},
            fillPattern=1));
        connect(MultiBond2.MultiBondCon2, mTF_effort.MultiBondCon1) annotation (
           points=[40,-30; 40,-30], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=60,
            rgbfillColor={170,255,170},
            fillPattern=1));
        connect(MultiBond6.MultiBondCon2, j0_2.MultiBondCon4) annotation (
            points=[-30,-20; -30,-20], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=60,
            rgbfillColor={170,255,170},
            fillPattern=1));
      end Torque;

      model SoftImpuls_SphereSphere "soft impact between two spheres"
        import SI = Modelica.SIunits;
        import MB = Modelica.Mechanics.MultiBody;

        Interfaces.Frame_a frame_a annotation (extent=[-120,-20; -100,20]);
        Interfaces.Frame_b frame_b annotation (extent=[100,-20; 120,20]);

        parameter Real c(
          final unit="N/m",
          final min=0) = 0 "Spring constant";

        parameter Real d(
          final unit="N.s/m",
          final min=0) = 0 "Damping constant";

        parameter SI.Radius ra = 1 "radius of sphere at frame a";
        parameter SI.Radius rb = 1 "radius of sphere at frame b";

        parameter SI.Position s_small = 1e-4
          "|Advanced||critical Spring length";

      //  parameter Real muR "friction coefficient";
      //  parameter SI.Velocity vAdhesion "range of Adhesion";

        SI.Distance s;
        SI.Distance r[3];
        Real eR[3];
        SI.Force fI[3];
      //  SI.Force fR[3];
      //  SI.Velocity deltaV[3];
      //  SI.Velocity vR[3];

        annotation (Diagram(
            Rectangle(extent=[32,100; 52,80], style(color=10, rgbcolor={135,135,135})),
            Line(points=[-74,-10; -64,-10; -64,90; 32,90], style(color=10, rgbcolor={
                    135,135,135})),
            Text(
              extent=[32,94; 52,84],
              string="Distance",
              style(color=10, rgbcolor={135,135,135})),
            Line(points=[74,90; 74,-10], style(color=10, rgbcolor={135,135,135})),
            Line(points=[78,-10; 74,-10], style(color=10, rgbcolor={135,135,135})),
            Line(points=[44,80; 44,70; 30,70], style(color=10, rgbcolor={135,135,135})),
            Polygon(points=[30,80; 30,60; 10,70; 30,80], style(color=10, rgbcolor={
                    135,135,135})),
            Text(
              extent=[20,60; 40,50],
              style(color=74, rgbcolor={0,0,196}),
              string="Gain=c"),
            Line(points=[10,70; 0,70; 0,64], style(color=10, rgbcolor={135,135,135})),
            Line(points=[74,90; 52,90], style(color=10, rgbcolor={135,135,135}))),
                             Icon(
            Text(
              extent=[-100,100; 100,48],
              string="%name",
              style(
                color=3,
                rgbcolor={0,0,255},
                gradient=3,
                fillColor=30,
                rgbfillColor={215,215,215})),
            Line(points=[80,0; 74,0; 100,0],   style(color=0, rgbcolor={0,0,0})),
            Text(
              extent=[100,-50; 68,-20],
              style(
                color=9,
                rgbcolor={175,175,175},
                pattern=0,
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1),
              string="b"),
            Text(
              extent=[-100,-48; 100,-94],
              style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1),
              string="c=%c"),
            Text(
              extent=[-68,-50; -100,-20],
              string="a",
              style(
                color=9,
                rgbcolor={175,175,175},
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1)),
            Line(points=[-100,0; -100,0; -70,0],
                                               style(color=0, rgbcolor={0,0,0})),
            Ellipse(extent=[-70,30; -10,-30], style(
                pattern=0,
                gradient=3,
                fillColor=75,
                rgbfillColor={85,133,255})),
            Ellipse(extent=[14,30; 74,-30], style(
                pattern=0,
                gradient=3,
                fillColor=75,
                rgbfillColor={85,133,255})),
            Line(points=[0,40; 0,-40], style(
                color=2,
                rgbcolor={0,255,0},
                gradient=3,
                fillColor=75,
                rgbfillColor={85,133,255})),
            Line(points=[14,40; 4,4], style(
                color=2,
                rgbcolor={0,255,0},
                gradient=3,
                fillColor=75,
                rgbfillColor={85,133,255})),
            Line(points=[4,-4; 12,-40], style(
                color=2,
                rgbcolor={0,255,0},
                gradient=3,
                fillColor=75,
                rgbfillColor={85,133,255})),
            Line(points=[-4,-4; -14,-40], style(
                color=2,
                rgbcolor={0,255,0},
                gradient=3,
                fillColor=75,
                rgbfillColor={85,133,255})),
            Line(points=[-14,40; -4,4], style(
                color=2,
                rgbcolor={0,255,0},
                gradient=3,
                fillColor=75,
                rgbfillColor={85,133,255})),
            Ellipse(extent=[-4,4; 4,-4], style(
                pattern=0,
                gradient=3,
                fillColor=2,
                rgbfillColor={0,255,0}))),
          Documentation(info="<html>
This element models the soft collision between two spheres.
<p>
The spheres are supposed to suround the two connector with the radii ra and rb.
<p>
The collision characteristics can be specified by the coefficients
of the virtual spring and damper.
</html>"));

      protected
        outer World3D world3D;
      protected
        inner Defaults MBG_defaults(n=3) annotation (extent=[-100,60; -80,80]);

      protected
        Interfaces.MBG2Mech MBG2Mech1 annotation (extent=[80,-60; 100,20]);
        Interfaces.Mech2MBG Mech2MBG1 annotation (extent=[-100,-60; -80,20]);

      protected
        Junctions.J0 J0_1(n=3) annotation (extent=[-10,0; 10,20]);
        Junctions.J0 J0_2(n=3) annotation (extent=[-10,-60; 10,-40]);
        Sources.Se Se1(n=3, e0={0})
          annotation (extent=[-10,-100; 10,-80],rotation=270);
        Sources.mSe mSe1(n=3)
                         annotation (extent=[-10,40; 10,60], rotation=90);
        Bonds.MultiBond MultiBond8      annotation (extent=[-10,-80; 10,-60],
                                                                            rotation=90);
        Bonds.MultiBond MultiBond3      annotation (extent=[-10,20; 10,40], rotation=
              270);
        Bonds.MultiBond MultiBond1      annotation (extent=[-30,0; -10,20]);
        Bonds.MultiBond MultiBond2      annotation (extent=[60,0; 80,20],  rotation=0);
        Bonds.MultiBond MultiBond4      annotation (extent=[-30,-60; -10,-40]);
        Bonds.MultiBond MultiBond5      annotation (extent=[30,-60; 10,-40]);
        Bonds.Utilities.MultiBondTail MultiBondTail2
                                           annotation (extent=[-78,-60; -28,-40]);
        Bonds.Utilities.MultiBondTail MultiBondTail1
                                           annotation (extent=[28,-60; 80,-40],
            rotation=180);
        Bonds.Utilities.MultiBondTail MultiBondTail3
                                           annotation (extent=[-78,0; -28,20]);
        Bonds.Utilities.MultiBondTail MultiBondTail4
                                           annotation (extent=[16,0; 62,20]);

      equation
        //equations to compute the spring force
        r = Mech2MBG1.x - MBG2Mech1.x;
        s = sqrt(r*r);
        eR = if s >= s_small then r/s else r/s_small;
        fI = if (s-ra-rb) < 0 then c*(s-ra-rb)*eR else zeros(3);
        mSe1.s = fI;

        connect(Mech2MBG1.frame_a, frame_a) annotation (points=[-99,-20; -110,
              -20; -110,0],     style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(MBG2Mech1.frame_b, frame_b) annotation (points=[99,-20; 100,-20; 100,
              -2; 106,-2; 106,0; 110,0],
                         style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(MultiBond1.MultiBondCon2, J0_1.MultiBondCon1)
          annotation (points=[-10,10; -10,10],
                                             style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond4.MultiBondCon2,J0_2. MultiBondCon1)
          annotation (points=[-10,-50; -10,-50],
                                             style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond5.MultiBondCon2, J0_2.MultiBondCon2) annotation (points=[10,-50;
              10,-50],      style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=83,
            rgbfillColor={255,170,255},
            fillPattern=1));
        connect(MultiBond3.MultiBondCon2, J0_1.MultiBondCon4) annotation (points=[
              -1.83691e-015,20; 0,20], style(color=71, rgbcolor={85,170,255}));
        connect(mSe1.MultiBondCon1, MultiBond3.MultiBondCon1) annotation (points=[
              -6.12303e-016,40; 1.83691e-015,40], style(color=71, rgbcolor={85,170,
                255}));
        connect(MultiBond1.MultiBondCon1, Mech2MBG1.MultiBondConTrans) annotation (points=[-30,10;
              -80,10],         style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond8.MultiBondCon2, J0_2.MultiBondCon3) annotation (points=[
              6.12303e-016,-60; 0,-60], style(color=71, rgbcolor={85,170,255}));
        connect(Se1.MultiBondCon1, MultiBond8.MultiBondCon1) annotation (points=[
              1.83691e-015,-80; -6.12303e-016,-80], style(color=71, rgbcolor={85,170,
                255}));
        connect(MultiBond5.MultiBondCon1, MBG2Mech1.MultiBondConRot) annotation (
            points=[30,-50; 80,-50], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond4.MultiBondCon1, Mech2MBG1.MultiBondConRot) annotation (
            points=[-30,-50; -79.8,-50], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond2.MultiBondCon2, MBG2Mech1.MultiBondConTrans)
          annotation (points=[80,10; 80,10], style(color=71, rgbcolor={85,170,
                255}));
        connect(MultiBond2.MultiBondCon1, J0_1.MultiBondCon2) annotation (
            points=[60,10; 10,10], style(color=71, rgbcolor={85,170,255}));
      end SoftImpuls_SphereSphere;
    end Forces;

    package Joints "joint elements"
      model Prismatic "prismatic joint with 1 degree of freedom"
        annotation (Icon(
               Text(
              extent=[-142,66; 147,105],
              style(color=0),
              string="n=%n"),  Text(extent=[-135,-107; 141,-50],   string="%name"),
            Rectangle(extent=[-100,-40; -30,51], style(
                pattern=0,
                fillColor=83,
                rgbfillColor={255,170,255})),
            Rectangle(extent=[-30,-20; 100,30], style(
                pattern=0,
                fillColor=83,
                rgbfillColor={255,170,255})),
            Text(
              extent=[60,22; 96,-3],
              string="b",
              style(color=10)),
            Rectangle(extent=[-30,30; 100,40],   style(
                pattern=0,
                fillColor=0,
                fillPattern=1)),
            Rectangle(extent=[-100,50; -30,60],   style(
                pattern=0,
                fillColor=0,
                fillPattern=1)),
            Text(
              extent=[-95,23; -60,1],
              string="a",
              style(color=10))), Diagram,
          Documentation(info="<html>
This is a prismatic joint. The two connected frames are allowed to shift in direction of the joint axis.
This joint defines one degree of freedom.
<p>
<img src=\"../Images/Prismatic3D.png\">
</p>
<h3>General parameter</h3>
The joint axis can be defined by the parameter n. n can be of arbitrary length, but it must not be zero.
<p>
The parameter s_offset defines an offset value for the joint length s.
<p>
The parameter animation toggles the visualization of the element.
<h3>Initialization</h3>
In general, you can specify...
<ul>
<li>...the initial joint length.
<li>...the initial joint velocity.
<li>...the initial joint acceleration.
</ul>
Which of these variables do effectively appear in the inital equations can be defined by the parameter initType.
<h3>Visualization</h3>
This element is visualized by box. The settings for width, height and color can be specified by the animation parameters.
<h3>Advanced settings</h3>
The activation of enforceStates enforces the joint to explicitely define integrators.
This parameter is useful to choose the state variables in a kinematic loop.
</html>"));
        import SI = Modelica.SIunits;
        import MB = Modelica.Mechanics.MultiBody;

        parameter Boolean animation = true "animate prismatic joint as box";

        parameter SI.Position n[3] = {1,0,0} "direction of the joint axis"
                                                                         annotation(Evaluate=true);
        parameter SI.Position s_offset=0
          "Relative distance offset (distance between frame_a and frame_b = s_offset + s)"
          annotation (Evaluate=false);
        final parameter SI.Position eN[3] = n/sqrt(n*n) annotation(Evaluate = true);

        parameter MB.Types.Init.Temp initType=MB.Types.Init.Free
          "|Initialization| Type of initialization (defines usage of start values below)";
        parameter SI.Distance s_start = 0 "|Initialization|initial length";
        parameter SI.Velocity v_start = 0 "|Initialization|initial velocity";
        parameter SI.Acceleration a_start = 0
          "|Initialization|initial acceleration";

        parameter SI.Distance boxWidth=world3D.defaultJointWidth
          "|Animation|if animation = true| Width of prismatic joint box";
        parameter SI.Distance boxHeight=boxWidth
          "|Animation|if animation = true| Height of prismatic joint box";
        parameter Modelica.Mechanics.MultiBody.Types.Color boxColor=world3D.defaultJointColor
          "|Animation|if animation = true| Color of prismatic joint box";

        parameter Boolean enforceStates =  false
          "|Advanced||enforce s and v as states";

        SI.Position s(stateSelect=if enforceStates then StateSelect.always else StateSelect.prefer)
          "length of prismatic joint";
        SI.Velocity v(stateSelect=if enforceStates then StateSelect.always else StateSelect.prefer)
          "velocity of prismatic joint";
        SI.Acceleration a "acceleration of prismatic joint";

        replaceable Interfaces.Frame_a frame_a
          "|Advanced||replaceable Interface for further extensions"
                                   annotation (extent=[-120,-20; -100,20]);
        replaceable Interfaces.Frame_b frame_b
          "|Advanced||replaceable Interface for further extensions"
                                   annotation (extent=[100,-20; 120,20]);

      protected
        outer World3D world3D;
        inner Defaults MBG_defaults(n=3) annotation (extent=[-100,80; -80,100]);
        replaceable Interfaces.Mech2MBG Mech2MBG1
                                      annotation (extent=[-100,-80; -80,0]);
        replaceable Interfaces.MBG2Mech MBG2Mech1
                                      annotation (extent=[80,-80; 100,0]);
        Junctions.J1 J1_1(n=1)
                          annotation (extent=[-20,60; 0,80]);
        Sources.Se Se1(e0={0}, n=1)
                       annotation (extent=[-20,20; 0,40], rotation=270);
        Sensors.Dq Dq1(stateInitialCondition=false,q(stateSelect = StateSelect.never), n=1)         annotation (extent=[-40,60; -60,80]);
        Passive.mTF_effort mTF_effort1 annotation (extent=[30,-50; 10,-30]);
        Bonds.Utilities.MultiBondTail MultiBondTail2
                                           annotation (extent=[48,-50; 30,-30],
            rotation=180);
        Junctions.J0 J0_1 annotation (extent=[40,-20; 60,0]);
        Junctions.J1 J1_2 annotation (extent=[-60,-80; -40,-60]);
        AdditionalMBG.translational_mTF translational_mTF1(r=eN)
          annotation (extent=[-30,-50; -10,-30]);
        Passive.mTF_effort mTF_effort2
          annotation (extent=[60,40; 40,20], rotation=270);
        Bonds.MultiBond MultiBond2      annotation (extent=[-80,-80; -60,-60]);
        Bonds.MultiBond MultiBond11     annotation (extent=[60,-80; 80,-60]);
        Bonds.MultiBond MultiBond8      annotation (extent=[-50,-50; -30,-30],
            rotation=0);
        Bonds.MultiBond MultiBond1      annotation (extent=[60,-20; 80,0]);
        Bonds.MultiBond MultiBond3      annotation (extent=[20,-20; 40,0]);
        Bonds.MultiBond MultiBond5(n=1)
                                   annotation (extent=[0,60; 20,80],  rotation=0);
        Bonds.MultiBond MultiBond6
          annotation (extent=[40,0; 60,20], rotation=-90);
        Bonds.MultiBond MultiBond7(n=1)
                                   annotation (extent=[-20,60; -40,80]);
        Bonds.MultiBond MultiBond9      annotation (extent=[-10,-50; 10,-30],
            rotation=0);
        Bonds.MultiBond MultiBond10     annotation (extent=[40,-40; 60,-20], rotation=
             90);
        Bonds.MultiBond MultiBond4(n=1)
                                   annotation (extent=[-20,40; 0,60], rotation=90);
        Bonds.MultiBond MultiBond12
          annotation (extent=[40,40; 60,60],rotation=270);
        Bonds.Utilities.MultiBondTail MultiBondTail1
                                           annotation (extent=[-80,-20; 22,0]);
        Bonds.Utilities.MultiBondTail MultiBondTail3
                                           annotation (extent=[-40,-60; -60,-42],
            rotation=90);
        Bonds.Utilities.MultiBondTail MultiBondTail4
                                           annotation (extent=[-40,-80; 62,-60]);
        Bonds.Utilities.MultiBondTail MultiBondTail5
                                           annotation (extent=[48,60; 40,80]);
        Bonds.Utilities.MultiBondTail MultiBondTail6
                                           annotation (extent=[60,68; 40,58],
            rotation=90);
        Utilities.Translation Translation1(r=eN)
          annotation (extent=[-74,-40; -54,-20]);

        parameter Integer ndim=if world3D.enableAnimation and animation then 1 else 0;
        MB.Visualizers.Advanced.Shape box[ndim](
          each shapeType="box",
          each color=boxColor,
          each length=Dq1.q[1],
          each width=boxWidth,
          each height=boxHeight,
          each lengthDirection=eN,
          each widthDirection={0,0,1},
          each r_shape={0,0,0},
          each r=Mech2MBG1.x,
          each R=MB.Frames.Orientation(T=Mech2MBG1.R,w=zeros(3)));

      public
        Passive.TF2_effort projectiveTF(
          nA=3,
          nB=1,
          M={eN}) annotation (extent=[40,60; 20,80], rotation=0);
      initial equation
        if initType == MB.Types.Init.Position or initType == MB.Types.Init.
            PositionVelocity or initType == MB.Types.Init.PositionVelocityAcceleration then
          // Initialize positional variables
          s = s_start;
        end if;

        if initType == MB.Types.Init.PositionVelocity or initType == MB.Types.Init.
            PositionVelocityAcceleration or initType == MB.Types.Init.Velocity or
            initType == MB.Types.Init.VelocityAcceleration then
          // Initialize velocity variables
          v = v_start;
        end if;

        if initType == MB.Types.Init.VelocityAcceleration or initType == MB.Types.Init.
            PositionVelocityAcceleration then
          // Initialize acceleration variables
          a = a_start;
        end if;

        if initType == MB.Types.Init.SteadyState then
          v = 0;
          a = 0;
        end if;

      equation
        defineBranch(frame_a.P,frame_b.P);

        s = Dq1.q[1]-s_offset;
        v = J1_1.MultiBondCon1.f[1];
        a = der(v);
        connect(Mech2MBG1.frame_a, frame_a) annotation (points=[-99,-40; -100,-40;
              -100,-2; -106,-2; -106,0; -110,0],
                          style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=83,
            rgbfillColor={255,170,255},
            fillPattern=1));
        connect(MBG2Mech1.frame_b, frame_b) annotation (points=[99,-40; 100,-40; 100,
              0; 110,0],
                      style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=83,
            rgbfillColor={255,170,255},
            fillPattern=1));
        connect(MultiBond7.MultiBondCon1, J1_1.MultiBondCon1)
          annotation (points=[-20,70; -20,70],
                                             style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond7.MultiBondCon2, Dq1.MultiBondCon1)
          annotation (points=[-40,70; -40,70],
                                           style(color=71, rgbcolor={85,170,255}));
        connect(Mech2MBG1.x, Translation1.x1) annotation (points=[-80,-30; -74,-30],
                                 style(color=3, rgbcolor={0,0,255}));
        connect(MultiBond1.MultiBondCon2, MBG2Mech1.MultiBondConTrans) annotation (
            points=[80,-10; 80,-10], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond1.MultiBondCon1, J0_1.MultiBondCon2) annotation (points=[60,
              -10; 60,-10], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond3.MultiBondCon2, J0_1.MultiBondCon1) annotation (points=[40,
              -10; 40,-10], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond3.MultiBondCon1, Mech2MBG1.MultiBondConTrans) annotation (
            points=[20,-10; -80,-10], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond2.MultiBondCon2, J1_2.MultiBondCon1) annotation (points=[-60,
              -70; -60,-70], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond2.MultiBondCon1, Mech2MBG1.MultiBondConRot) annotation (
            points=[-80,-70; -79.8,-70], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond11.MultiBondCon2, MBG2Mech1.MultiBondConRot) annotation (
            points=[80,-70; 80,-70], style(color=71, rgbcolor={85,170,255}));
        connect(Translation1.x2, MBG2Mech1.x) annotation (points=[-54,-30; -48,-30;
              -48,-26; 74,-26; 74,-30; 80,-30], style(color=3, rgbcolor={0,0,255}));
        connect(Mech2MBG1.R, MBG2Mech1.R) annotation (points=[-80,-50; -78,-50; -78,
              -54; 74,-54; 74,-50; 80,-50], style(color=3, rgbcolor={0,0,255}));
        connect(Translation1.R, Mech2MBG1.R) annotation (points=[-64,-40; -64,-54;
              -78,-54; -78,-50; -80,-50], style(color=3, rgbcolor={0,0,255}));
        connect(mTF_effort1.M, Mech2MBG1.R) annotation (points=[20,-50; 20,-54; -78,
              -54; -78,-50; -80,-50], style(color=3, rgbcolor={0,0,255}));
        connect(mTF_effort1.MultiBondCon1, MultiBond10.MultiBondCon1) annotation (
            points=[30,-40; 50,-40], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond9.MultiBondCon2, mTF_effort1.MultiBondCon2) annotation (
            points=[10,-40; 10,-40], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond8.MultiBondCon1, J1_2.MultiBondCon4) annotation (points=[-50,
              -40; -50,-60], style(color=71, rgbcolor={85,170,255}));
        connect(J1_2.MultiBondCon2, MultiBond11.MultiBondCon1) annotation (points=[
              -40,-70; 60,-70], style(color=71, rgbcolor={85,170,255}));
        connect(J0_1.MultiBondCon3, MultiBond10.MultiBondCon2) annotation (points=[50,
              -20; 50,-20], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond6.MultiBondCon2, J0_1.MultiBondCon4)
          annotation (points=[50,0; 50,0], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond5.MultiBondCon1, J1_1.MultiBondCon2)
          annotation (points=[0,70; 0,70], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond4.MultiBondCon2, J1_1.MultiBondCon3) annotation (points=[-10,
              60; -10,60], style(color=71, rgbcolor={85,170,255}));
        connect(Se1.MultiBondCon1, MultiBond4.MultiBondCon1) annotation (points=[-10,40;
              -10,40],     style(color=71, rgbcolor={85,170,255}));
        connect(Translation1.ampl, Dq1.q[1]) annotation (points=[-64,-20; -64,70; -60,
              70], style(color=3, rgbcolor={0,0,255}));
        connect(translational_mTF1.MultiBondCon1, MultiBond8.MultiBondCon2)
          annotation (points=[-30,-40; -30,-40], style(color=71, rgbcolor={85,170,255}));
        connect(translational_mTF1.MultiBondCon2, MultiBond9.MultiBondCon1)
          annotation (points=[-10,-40; -10,-40], style(color=71, rgbcolor={85,170,255}));
        connect(translational_mTF1.ampl, Dq1.q[1]) annotation (points=[-20,-30; -20,6;
              -64,6; -64,70; -60,70], style(color=3, rgbcolor={0,0,255}));
        connect(mTF_effort2.MultiBondCon2, MultiBond12.MultiBondCon2)
          annotation (points=[50,40; 50,40], style(color=71, rgbcolor={85,170,255}));
        connect(mTF_effort2.MultiBondCon1, MultiBond6.MultiBondCon1)
          annotation (points=[50,20; 50,20], style(color=71, rgbcolor={85,170,255}));
        connect(mTF_effort2.M, MBG2Mech1.R) annotation (points=[60,30; 64,30;
              64,-54; 74,-54; 74,-50; 80,-50],
                                       style(color=3, rgbcolor={0,0,255}));
        connect(projectiveTF.MultiBondConB, MultiBond5.MultiBondCon2) annotation (
           points=[20,70; 20,70], style(color=71, rgbcolor={85,170,255}));
        connect(projectiveTF.MultiBondConA, MultiBond12.MultiBondCon1)
          annotation (points=[40,70; 50,70; 50,60], style(color=71, rgbcolor={
                85,170,255}));
      end Prismatic;

      model ActuatedPrismatic "prismatic joint with 1 degree of freedom"
        annotation (Icon(
               Text(
              extent=[-140,-76; 149,-37],
              style(color=0),
              string="n=%n"),  Text(extent=[-135,-119; 142,-66],   string="%name"),
            Rectangle(extent=[-100,-40; -30,51], style(
                pattern=0,
                fillColor=83,
                rgbfillColor={255,170,255})),
            Rectangle(extent=[-30,-20; 100,30], style(
                pattern=0,
                fillColor=83,
                rgbfillColor={255,170,255})),
            Text(
              extent=[60,22; 96,-3],
              string="b",
              style(color=10)),
            Rectangle(extent=[-30,30; 100,40],   style(
                pattern=0,
                fillColor=0,
                fillPattern=1)),
            Rectangle(extent=[-100,50; -30,60],   style(
                pattern=0,
                fillColor=0,
                fillPattern=1)),
            Text(
              extent=[-95,23; -60,1],
              string="a",
              style(color=10)),
            Rectangle(extent=[80,40; 100,80], style(
                pattern=0,
                fillColor=83,
                rgbfillColor={255,170,255}))),
                                 Diagram,
          Documentation(info="<html>
This is a prismatic joint. The two connected frames are allowed to shift in direction of the joint axis.
This joint defines one degree of freedom. <br>
This prismatic joint has two additional 1-dimensional mechanical flanges (flange \"axis\" represents the driving flange and
flange \"bearing\" represents the bearing) where it can be driven with elements of the
<a href=\"Modelica://BondLib.Mechanical.Translational\">BondLib.Mechanical.Translational</a> library. library.

<p>
<img src=\"../Images/Prismatic3D.png\">
</p>
<h3>General parameter</h3>
The joint axis can be defined by the parameter n. n can be of arbitrary length, but it must not be zero.
<p>
The parameter s_offset defines an offset value for the joint length s.
<p>
The parameter animation toggles the visualization of the element.
<h3>Initialization</h3>
In general, you can specify...
<ul>
<li>...the initial joint length.
<li>...the initial joint velocity.
<li>...the initial joint acceleration.
</ul>
Which of these variables do effectively appear in the inital equations can be defined by the parameter initType.
<h3>Visualization</h3>
This element is visualized by box. The settings for width, height and color can be specified by the animation parameters.
<h3>Advanced settings</h3>
The activation of enforceStates enforces the joint to explicitely define integrators.
This parameter is useful to choose the state variables in a kinematic loop.
</html>"));
        import SI = Modelica.SIunits;
        import MB = Modelica.Mechanics.MultiBody;

        parameter Boolean animation = true "animate prismatic joint as box";

        parameter SI.Position n[3] = {1,0,0} "direction of the joint axis"
                                                                         annotation(Evaluate=true);
        parameter SI.Position s_offset=0
          "Relative distance offset (distance between frame_a and frame_b = s_offset + s)"
          annotation (Evaluate=false);
        final parameter SI.Position eN[3] = n/sqrt(n*n) annotation(Evaluate = true);

        parameter MB.Types.Init.Temp initType=MB.Types.Init.Free
          "|Initialization| Type of initialization (defines usage of start values below)";
        parameter SI.Distance s_start = 0 "|Initialization|initial length";
        parameter SI.Velocity v_start = 0 "|Initialization|initial velocity";
        parameter SI.Acceleration a_start = 0
          "|Initialization|initial acceleration";

        parameter SI.Distance boxWidth=world3D.defaultJointWidth
          "|Animation|if animation = true| Width of prismatic joint box";
        parameter SI.Distance boxHeight=boxWidth
          "|Animation|if animation = true| Height of prismatic joint box";
        parameter Modelica.Mechanics.MultiBody.Types.Color boxColor=world3D.defaultJointColor
          "|Animation|if animation = true| Color of prismatic joint box";

        parameter Boolean enforceStates =  false
          "|Advanced||enforce s and v as states";

        SI.Position s(stateSelect=if enforceStates then StateSelect.always else StateSelect.prefer)
          "length of prismatic joint";
        SI.Velocity v(stateSelect=if enforceStates then StateSelect.always else StateSelect.prefer)
          "velocity of prismatic joint";
        SI.Acceleration a "acceleration of prismatic joint";

        replaceable Interfaces.Frame_a frame_a
          "|Advanced||replaceable Interface for further extensions"
                                   annotation (extent=[-120,-20; -100,20]);
        replaceable Interfaces.Frame_b frame_b
          "|Advanced||replaceable Interface for further extensions"
                                   annotation (extent=[100,-20; 120,20]);

      protected
        outer World3D world3D;
        inner Defaults MBG_defaults(n=3) annotation (extent=[-100,80; -80,100]);
        replaceable Interfaces.Mech2MBG Mech2MBG1
                                      annotation (extent=[-100,-100; -80,-20]);
        replaceable Interfaces.MBG2Mech MBG2Mech1
                                      annotation (extent=[80,-100; 100,-20]);
        Junctions.J1 J1_1(n=1)
                          annotation (extent=[-20,20; 0,40]);
        Sensors.Dq Dq1(stateInitialCondition=false,q(stateSelect = StateSelect.never), n=1)         annotation (extent=[-40,20;
              -60,40]);
        Passive.mTF_effort mTF_effort1 annotation (extent=[30,-70; 10,-50]);
        Bonds.Utilities.MultiBondTail MultiBondTail2
                                           annotation (extent=[48,-70; 30,-50],
            rotation=180);
        Junctions.J0 J0_1 annotation (extent=[40,-40; 60,-20]);
        Junctions.J1 J1_2 annotation (extent=[-60,-100; -40,-80]);
        AdditionalMBG.translational_mTF translational_mTF1(r=eN)
          annotation (extent=[-30,-70; -10,-50]);
        Passive.mTF_effort mTF_effort2
          annotation (extent=[60,16; 40,-4], rotation=270);
        Bonds.MultiBond MultiBond2      annotation (extent=[-80,-100; -60,-80]);
        Bonds.MultiBond MultiBond11     annotation (extent=[60,-100; 80,-80]);
        Bonds.MultiBond MultiBond8      annotation (extent=[-50,-70; -30,-50],
            rotation=0);
        Bonds.MultiBond MultiBond1      annotation (extent=[60,-40; 80,-20]);
        Bonds.MultiBond MultiBond3      annotation (extent=[20,-40; 40,-20]);
        Bonds.MultiBond MultiBond5(n=1)
                                   annotation (extent=[0,20; 20,40],  rotation=0);
        Bonds.MultiBond MultiBond6
          annotation (extent=[40,-20; 60,-4],
                                            rotation=-90);
        Bonds.MultiBond MultiBond7(n=1)
                                   annotation (extent=[-20,20; -40,40]);
        Bonds.MultiBond MultiBond9      annotation (extent=[-10,-70; 10,-50],
            rotation=0);
        Bonds.MultiBond MultiBond10     annotation (extent=[40,-60; 60,-40], rotation=
             90);
        Bonds.MultiBond MultiBond12
          annotation (extent=[40,16; 60,28],rotation=270);
        Bonds.Utilities.MultiBondTail MultiBondTail1
                                           annotation (extent=[-80,-40; 22,-20]);
        Bonds.Utilities.MultiBondTail MultiBondTail3
                                           annotation (extent=[-40,-80; -60,-62],
            rotation=90);
        Bonds.Utilities.MultiBondTail MultiBondTail4
                                           annotation (extent=[-40,-100; 62,-80]);
        Bonds.Utilities.MultiBondTail MultiBondTail5
                                           annotation (extent=[40,20; 48,40],
            rotation=180);
        Utilities.Translation Translation1(r=eN)
          annotation (extent=[-74,-60; -54,-40]);

        parameter Integer ndim=if world3D.enableAnimation and animation then 1 else 0;
        MB.Visualizers.Advanced.Shape box[ndim](
          each shapeType="box",
          each color=boxColor,
          each length=Dq1.q[1],
          each width=boxWidth,
          each height=boxHeight,
          each lengthDirection=eN,
          each widthDirection={0,0,1},
          each r_shape={0,0,0},
          each r=Mech2MBG1.x,
          each R=MB.Frames.Orientation(T=Mech2MBG1.R,w=zeros(3)));

      public
        Passive.TF2_effort projectiveTF(
          nA=3,
          nB=1,
          M={eN}) annotation (extent=[40,20; 20,40], rotation=0);
        BondLib.Mechanical.Translational.Interfaces.Flange_a axis
          annotation (extent=[60,60; 80,80]);
        BondLib.Mechanical.Translational.Interfaces.Flange_b bearing
          annotation (extent=[-70,60; -50,80]);
        BondLib.Mechanical.Translational.Interfaces.Tr2BG tr2BG
          annotation (extent=[-50,80; -30,100]);
        BondLib.Mechanical.Translational.Interfaces.BG2Tr bG2Tr
          annotation (extent=[40,60; 60,80]);
        BondLib.Bonds.Bond bond
          annotation (extent=[-30,100; -10,80], rotation=180);
        Modelica.Blocks.Sources.Constant Constant(k=0)
          annotation (extent=[-52,60; -42,70]);
      protected
        Bonds.Utilities.MultiBondTail MultiBondTail6
                                           annotation (extent=[40,24; 60,28],
            rotation=270);
        Bonds.Utilities.MultiBondTail MultiBondTail7
                                           annotation (extent=[-20,40; 0,68],
            rotation=270);
      public
        Compositions.FromMultiBond fromMultiBond
          annotation (extent=[22,60; 40,80]);
        BondLib.Sources.Sf sf(f0=0)
          annotation (extent=[-10,80; 10,100], rotation=0);
      protected
        Bonds.Utilities.MultiBondTail MultiBondTail8
                                           annotation (extent=[-10,60; 24,80],
            rotation=0);
      initial equation
        if initType == MB.Types.Init.Position or initType == MB.Types.Init.
            PositionVelocity or initType == MB.Types.Init.PositionVelocityAcceleration then
          // Initialize positional variables
          s = s_start;
        end if;

        if initType == MB.Types.Init.PositionVelocity or initType == MB.Types.Init.
            PositionVelocityAcceleration or initType == MB.Types.Init.Velocity or
            initType == MB.Types.Init.VelocityAcceleration then
          // Initialize velocity variables
          v = v_start;
        end if;

        if initType == MB.Types.Init.VelocityAcceleration or initType == MB.Types.Init.
            PositionVelocityAcceleration then
          // Initialize acceleration variables
          a = a_start;
        end if;

        if initType == MB.Types.Init.SteadyState then
          v = 0;
          a = 0;
        end if;

      equation
        defineBranch(frame_a.P,frame_b.P);

        s = Dq1.q[1]-s_offset;
        v = J1_1.MultiBondCon1.f[1];
        a = der(v);
        connect(Mech2MBG1.frame_a, frame_a) annotation (points=[-99,-60; -100,
              -60; -100,-2; -106,-2; -106,0; -110,0],
                          style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=83,
            rgbfillColor={255,170,255},
            fillPattern=1));
        connect(MBG2Mech1.frame_b, frame_b) annotation (points=[99,-60; 100,-60;
              100,0; 110,0],
                      style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=83,
            rgbfillColor={255,170,255},
            fillPattern=1));
        connect(MultiBond7.MultiBondCon1, J1_1.MultiBondCon1)
          annotation (points=[-20,30; -20,30],
                                             style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond7.MultiBondCon2, Dq1.MultiBondCon1)
          annotation (points=[-40,30; -40,30],
                                           style(color=71, rgbcolor={85,170,255}));
        connect(Mech2MBG1.x, Translation1.x1) annotation (points=[-80,-50; -74,
              -50],              style(color=3, rgbcolor={0,0,255}));
        connect(MultiBond1.MultiBondCon2, MBG2Mech1.MultiBondConTrans) annotation (
            points=[80,-30; 80,-30], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond1.MultiBondCon1, J0_1.MultiBondCon2) annotation (points=[60,-30;
              60,-30],      style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond3.MultiBondCon2, J0_1.MultiBondCon1) annotation (points=[40,-30;
              40,-30],      style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond3.MultiBondCon1, Mech2MBG1.MultiBondConTrans) annotation (
            points=[20,-30; -80,-30], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond2.MultiBondCon2, J1_2.MultiBondCon1) annotation (points=[-60,-90;
              -60,-90],      style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond2.MultiBondCon1, Mech2MBG1.MultiBondConRot) annotation (
            points=[-80,-90; -79.8,-90], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond11.MultiBondCon2, MBG2Mech1.MultiBondConRot) annotation (
            points=[80,-90; 80,-90], style(color=71, rgbcolor={85,170,255}));
        connect(Translation1.x2, MBG2Mech1.x) annotation (points=[-54,-50; -48,
              -50; -48,-46; 74,-46; 74,-50; 80,-50],
                                                style(color=3, rgbcolor={0,0,255}));
        connect(Mech2MBG1.R, MBG2Mech1.R) annotation (points=[-80,-70; -78,-70;
              -78,-74; 74,-74; 74,-70; 80,-70],
                                            style(color=3, rgbcolor={0,0,255}));
        connect(Translation1.R, Mech2MBG1.R) annotation (points=[-64,-60; -64,
              -74; -78,-74; -78,-70; -80,-70],
                                          style(color=3, rgbcolor={0,0,255}));
        connect(mTF_effort1.M, Mech2MBG1.R) annotation (points=[20,-70; 20,-74;
              -78,-74; -78,-70; -80,-70],
                                      style(color=3, rgbcolor={0,0,255}));
        connect(mTF_effort1.MultiBondCon1, MultiBond10.MultiBondCon1) annotation (
            points=[30,-60; 50,-60], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond9.MultiBondCon2, mTF_effort1.MultiBondCon2) annotation (
            points=[10,-60; 10,-60], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond8.MultiBondCon1, J1_2.MultiBondCon4) annotation (points=[-50,-60;
              -50,-80],      style(color=71, rgbcolor={85,170,255}));
        connect(J1_2.MultiBondCon2, MultiBond11.MultiBondCon1) annotation (points=[-40,-90;
              60,-90],          style(color=71, rgbcolor={85,170,255}));
        connect(J0_1.MultiBondCon3, MultiBond10.MultiBondCon2) annotation (points=[50,-40;
              50,-40],      style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond6.MultiBondCon2, J0_1.MultiBondCon4)
          annotation (points=[50,-20; 50,-20],
                                           style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond5.MultiBondCon1, J1_1.MultiBondCon2)
          annotation (points=[0,30; 0,30], style(color=71, rgbcolor={85,170,255}));
        connect(Translation1.ampl, Dq1.q[1]) annotation (points=[-64,-40; -64,
              30; -60,30],
                   style(color=3, rgbcolor={0,0,255}));
        connect(translational_mTF1.MultiBondCon1, MultiBond8.MultiBondCon2)
          annotation (points=[-30,-60; -30,-60], style(color=71, rgbcolor={85,170,255}));
        connect(translational_mTF1.MultiBondCon2, MultiBond9.MultiBondCon1)
          annotation (points=[-10,-60; -10,-60], style(color=71, rgbcolor={85,170,255}));
        connect(translational_mTF1.ampl, Dq1.q[1]) annotation (points=[-20,-50;
              -20,-14; -64,-14; -64,30; -60,30],
                                      style(color=3, rgbcolor={0,0,255}));
        connect(mTF_effort2.MultiBondCon2, MultiBond12.MultiBondCon2)
          annotation (points=[50,16; 50,16], style(color=71, rgbcolor={85,170,255}));
        connect(mTF_effort2.MultiBondCon1, MultiBond6.MultiBondCon1)
          annotation (points=[50,-4; 50,-4], style(color=71, rgbcolor={85,170,255}));
        connect(mTF_effort2.M, MBG2Mech1.R) annotation (points=[60,6; 64,6; 64,
              -74; 74,-74; 74,-70; 80,-70],
                                       style(color=3, rgbcolor={0,0,255}));
        connect(projectiveTF.MultiBondConB, MultiBond5.MultiBondCon2) annotation (
           points=[20,30; 20,30], style(color=71, rgbcolor={85,170,255}));
        connect(tr2BG.Tr, bearing) annotation (points=[-50.1,89.9; -55.05,89.9;
              -55.05,70; -60,70], style(color=58, rgbcolor={0,127,0}));
        connect(bG2Tr.Tr, axis) annotation (points=[59.9,69.9; 45.95,69.9;
              45.95,70; 70,70], style(color=58, rgbcolor={0,127,0}));
        connect(Constant.y, tr2BG.s) annotation (points=[-41.5,65; -40,65; -40,
              80], style(color=74, rgbcolor={0,0,127}));
        connect(Dq1.q[1], bG2Tr.s) annotation (points=[-60,30; -64,30; -64,52;
              50,52; 50,60], style(color=3, rgbcolor={0,0,255}));
        connect(MultiBond12.MultiBondCon1, projectiveTF.MultiBondConA)
          annotation (points=[50,28; 50,30; 40,30], style(color=71, rgbcolor={
                85,170,255}));
        connect(fromMultiBond.MultiBondCon1, J1_1.MultiBondCon4) annotation (
            points=[22,70; -10,70; -10,40], style(color=71, rgbcolor={85,170,
                255}));
        connect(bond.BondCon2, tr2BG.BondCon1) annotation (points=[-30,90; -30,
              90], style(color=8, rgbcolor={192,192,192}));
        connect(bond.BondCon1, sf.BondCon1) annotation (points=[-10.2,90; -10,
              90], style(
            color=8,
            rgbcolor={192,192,192},
            pattern=0));
        connect(fromMultiBond.BondCon1, bG2Tr.BondCon1) annotation (points=[40,
              70; 40,70], style(
            color=8,
            rgbcolor={192,192,192},
            pattern=0));
      end ActuatedPrismatic;
      extends Modelica.Icons.Library;

      model Revolute "revolute joint with 1 degree of freedom"
        import SI = Modelica.SIunits;
        import MB = Modelica.Mechanics.MultiBody;
        import Cv = Modelica.SIunits.Conversions;
        annotation (Icon(
            Rectangle(extent=[-100,-60; -20,60], style(
                color=8,
                rgbcolor={192,192,192},
                gradient=2,
                fillColor=83,
                rgbfillColor={255,170,255})),
            Rectangle(extent=[20,-60; 100,60], style(
                color=8,
                rgbcolor={192,192,192},
                gradient=2,
                fillColor=83,
                rgbfillColor={255,170,255},
                fillPattern=1)),
            Rectangle(extent=[-20,10; 20,-10], style(
                color=0,
                rgbcolor={0,0,0},
                gradient=0,
                fillColor=83,
                rgbfillColor={255,170,255},
                fillPattern=1)),
            Text(
              extent=[-99,12; -63,-13],
              style(color=10),
              string="a"),
            Text(
              extent=[63,11; 99,-14],
              style(color=10),
              string="b"),
            Text(extent=[-100,-74; 102,-126],
                                            string="%name"),
               Text(
              extent=[-100,70; 100,106],
              style(color=0),
              string="n=%n")),                                Diagram(
            Rectangle(extent=[-78,-20; -58,-40],
                                               style(color=5, rgbcolor={255,0,255})),
            Text(
              extent=[-78,-24; -58,-36],
              style(color=5, rgbcolor={255,0,255}),
              string="root?"),
            Line(points=[-98,-16; -88,-16; -88,-32; -78,-32], style(color=5, rgbcolor=
                   {255,0,255})),
            Line(points=[-58,-30; -16,-30; -16,-22], style(color=5, rgbcolor={255,0,
                    255})),
            Line(points=[-40,-4; -40,-30], style(color=5, rgbcolor={255,0,255}))),
          Documentation(info="<html>
This is a revolute joint. The two connected frames are allowed to rotate around the joint axis.
This joint defines one degree of freedom.
<p>
<img src=\"../Images/Revolute.png\">
</p>
<h3>General parameter</h3>
The rotation axis of the revolute joint can be defined by the parameter n. n can be of arbitrary length, but it must not be zero.
<p>
The parameter phi_offset defines an offset value for the revolute angle phi.
<p>
The parameter animation toggles the visualization of the element.
<h3>Initialization</h3>
In general, you can specify...
<ul>
<li>...the initial revolute angle.
<li>...the initial angular velocity.
<li>...the initial angular acceleration.
</ul>
Which of these variables do effectively appear in the inital equations can be defined by the parameter initType.
<h3>Visualization</h3>
This element is visualized by cylinder along the rotation axis. The settings for length, diameter and color can be specified by the animation parameters.
<h3>Advanced settings</h3>
The activation of enforceStates enforces the joint to explicitely define integrators.
This parameter is useful to choose the state variables in a kinematic loop.
</html>"));

        parameter Boolean animation = true "animate revolute joint as cylinder";
        parameter SI.Position n[3] = {0,0,1} "direction of revolute axis"    annotation(Evaluate=true);
        final parameter SI.Position eN[3] = n/sqrt(n*n) annotation(Evaluate = true);
        parameter Cv.NonSIunits.Angle_deg phi_offset = 0
          "phi + phi_offset = angle between frames";
        final parameter SI.Angle phi_offset_rad = Cv.from_deg(phi_offset);

        parameter MB.Types.Init.Temp initType=MB.Types.Init.Free
          "|Initialization| Type of initialization (defines usage of start values below)";
        parameter Cv.NonSIunits.Angle_deg phi_start = 0
          "|Initialization|initial angle";
        parameter Types.AngularVelocity_deg w_start = 0
          "|Initialization|initial angular velocity";
        parameter Types.AngularAcceleration_deg z_start = 0
          "|Initialization|initial angular acceleration";

        final parameter SI.Angle phi_start_rad = Cv.from_deg(phi_start)
          "initial cardan angles";
        final parameter SI.AngularVelocity w_start_rad = Cv.from_deg(w_start)
          "initial angular velocity";
        final parameter SI.AngularAcceleration z_start_rad = Cv.from_deg(z_start)
          "initial angular acceleration";

        parameter SI.Distance cylinderLength=world3D.defaultJointLength
          "|Animation|if animation = true| Length of cylinder representing the joint axis";
        parameter SI.Distance cylinderDiameter=world3D.defaultJointWidth
          "|Animation|if animation = true| Diameter of cylinder representing the joint axis";
        parameter Modelica.Mechanics.MultiBody.Types.Color cylinderColor=world3D.defaultJointColor
          "|Animation|if animation = true| Color of cylinder representing the joint axis";

        parameter Boolean enforceStates =  false
          "|Advanced||enforce phi and w as states";

        SI.Angle phi(stateSelect=if enforceStates then StateSelect.always else StateSelect.prefer)
          "revolute angle";
        SI.AngularVelocity w(stateSelect=if enforceStates then StateSelect.always else StateSelect.prefer)
          "revolute angular velocity";
        SI.AngularAcceleration z "revolute angular acceleration";

        replaceable Interfaces.Frame_a frame_a
          "|Advanced||replaceable Interface for further extensions"
                                   annotation (extent=[-120,-20; -100,20]);
        replaceable Interfaces.Frame_b frame_b
          "|Advanced||replaceable Interface for further extensions"
                                   annotation (extent=[100,-20; 120,20]);

      protected
        outer World3D world3D;
        inner Defaults MBG_defaults(n=3) annotation (extent=[-100,80; -80,100]);
        replaceable Interfaces.Mech2MBG Mech2MBG1
                                      annotation (extent=[-100,-20; -80,60]);
        replaceable Interfaces.MBG2Mech MBG2Mech1
                                      annotation (extent=[80,-20; 100,60]);
        Junctions.J1 J1_1(n=1) annotation (extent=[20,-100; 40,-80]);
        Sources.Se Se1(n=1, e0={0}) annotation (extent=[60,-100; 80,-80],
                                                                       rotation=0);
        Sensors.Dq Dq_phi(stateInitialCondition=false, n=1)
                          annotation (extent=[-20,-100; 0,-80], rotation=180);
        Junctions.J0 J0_1 annotation (extent=[20,-20; 40,0]);
        AdditionalMBG.mTF mTF1 annotation (extent=[-20,-20; 0,0]);
        Bonds.MultiBond MultiBond7      annotation (extent=[60,-20; 80,0]);
        Bonds.MultiBond MultiBond8      annotation (extent=[60,40; 80,60]);
        Bonds.MultiBond MultiBond6(n=1)
          annotation (extent=[0,-80; 20,-100],
                                             rotation=180);
         Bonds.MultiBond MultiBond1      annotation (extent=[0,-20; 20,0]);
        Bonds.MultiBond MultiBond2      annotation (extent=[-40,-20; -20,0]);
        Bonds.MultiBond MultiBond3
          annotation (extent=[20,-40; 40,-20],
                                            rotation=90);
        Bonds.MultiBond MultiBond5(n=1)
          annotation (extent=[20,-80; 40,-60],
                                             rotation=90);
        Bonds.MultiBond MultiBond9(n=1)
          annotation (extent=[40,-80; 60,-100],
                                             rotation=180);
        Bonds.Utilities.MultiBondTail MultiBondTail1
                                           annotation (extent=[-80,-20; -38,0]);
        Bonds.Utilities.MultiBondTail MultiBondTail2
                                           annotation (extent=[-80,40; 62,60]);
        Bonds.Utilities.MultiBondTail MultiBondTail3
                                           annotation (extent=[42,-20; 62,0]);
        Utilities.Rotation Rotation1     annotation (extent=[-46,20; -26,0]);
        Utilities.planarRotation planarRotation1(n=eN)
          annotation (extent=[-46,-60; -26,-40],
                                             rotation=90);

        parameter Integer ndim=if world3D.enableAnimation and animation then 1 else 0;
        MB.Visualizers.Advanced.Shape cylinder[ndim](
          each shapeType="cylinder",
          each color=cylinderColor,
          each length=cylinderLength,
          each width=cylinderDiameter,
          each height=cylinderDiameter,
          each lengthDirection=eN,
          each widthDirection={0,1,0},
          each r_shape=-eN*cylinderLength/2,
          each r=Mech2MBG1.x,
          each R=MB.Frames.Orientation(T=Mech2MBG1.R,w=zeros(3)));

      public
        Passive.TF2_effort projectiveTF(
          nA=3,
          nB=1,
          M={eN}) annotation (extent=[20,-60; 40,-40], rotation=270);
      initial equation
        if initType == MB.Types.Init.Position or initType == MB.Types.Init.
            PositionVelocity or initType == MB.Types.Init.PositionVelocityAcceleration then
          // Initialize positional variables
          phi = phi_start_rad;
        end if;

        if initType == MB.Types.Init.PositionVelocity or initType == MB.Types.Init.
            PositionVelocityAcceleration or initType == MB.Types.Init.Velocity or
            initType == MB.Types.Init.VelocityAcceleration then
          // Initialize velocity variables
          w = w_start_rad;
        end if;

        if initType == MB.Types.Init.VelocityAcceleration or initType == MB.Types.Init.
            PositionVelocityAcceleration then
          // Initialize acceleration variables
          z = z_start_rad;
        end if;

        if initType == MB.Types.Init.SteadyState then
          w = 0;
          z = 0;
        end if;

      equation
        defineBranch(frame_a.P,frame_b.P);

        //change the causality of the transformation according to the root's position
        if rooted(frame_a.P) then
          Rotation1.dirForward = true;
          mTF1.transformFlow = true;
        else
          Rotation1.dirForward = false;
          mTF1.transformFlow = false;
        end if;

        phi = Dq_phi.q[1]-phi_offset_rad;
        w = J1_1.MultiBondCon1.f[1];
        z = der(w);
        connect(MBG2Mech1.frame_b, frame_b) annotation (points=[99,20; 110,20; 110,0],
                      style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            gradient=2,
            fillColor=71,
            rgbfillColor={85,170,255}));
        connect(Mech2MBG1.frame_a, frame_a) annotation (points=[-99,20; -100,20;
              -100,0; -110,0],
                          style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            gradient=2,
            fillColor=71,
            rgbfillColor={85,170,255}));
        connect(Mech2MBG1.x, MBG2Mech1.x) annotation (points=[-80,30; 80,30],
                                            style(color=3, rgbcolor={0,0,255}));
        connect(Mech2MBG1.R, Rotation1.R1) annotation (points=[-80,10; -46,10],
                    style(color=3, rgbcolor={0,0,255}));
        connect(Rotation1.R2, MBG2Mech1.R) annotation (points=[-26,10; 80,10],
            style(color=3, rgbcolor={0,0,255}));
        connect(planarRotation1.phi, Dq_phi.q[1]) annotation (points=[-36,-60; -36,
              -90; -20,-90],
                      style(color=3, rgbcolor={0,0,255}));
        connect(planarRotation1.Rrel, Rotation1.Rrel) annotation (points=[-36,-40;
              -36,0],           style(color=3, rgbcolor={0,0,255}));
        connect(MultiBond5.MultiBondCon1, J1_1.MultiBondCon4) annotation (points=[30,-80;
              30,-80],       style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond8.MultiBondCon2, MBG2Mech1.MultiBondConTrans)
          annotation (points=[80,50; 80,50], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond8.MultiBondCon1, Mech2MBG1.MultiBondConTrans) annotation (
            points=[60,50; -80,50],                 style(color=71, rgbcolor={85,170,
                255}));
        connect(MultiBond7.MultiBondCon2, MBG2Mech1.MultiBondConRot) annotation (
            points=[80,-10; 80,-10], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond2.MultiBondCon1, Mech2MBG1.MultiBondConRot) annotation (
            points=[-40,-10; -79.8,-10], style(color=71, rgbcolor={85,170,255}));
        connect(J0_1.MultiBondCon2, MultiBond7.MultiBondCon1) annotation (points=[40,
              -10; 60,-10], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond1.MultiBondCon2, J0_1.MultiBondCon1) annotation (points=[20,
              -10; 20,-10], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond3.MultiBondCon2, J0_1.MultiBondCon3) annotation (points=[30,
              -20; 30,-20], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond9.MultiBondCon2, J1_1.MultiBondCon2) annotation (points=[40,
              -90; 40,-90], style(color=71, rgbcolor={85,170,255}));
        connect(Se1.MultiBondCon1, MultiBond9.MultiBondCon1) annotation (points=[60,
              -90; 60,-90], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond6.MultiBondCon1, J1_1.MultiBondCon1) annotation (points=[20,
              -90; 20,-90], style(color=71, rgbcolor={85,170,255}));
        connect(Dq_phi.MultiBondCon1, MultiBond6.MultiBondCon2)
          annotation (points=[0,-90; 0,-90], style(color=71, rgbcolor={85,170,255}));
        connect(mTF1.MultiBondCon1, MultiBond2.MultiBondCon2) annotation (points=[-20,
              -10; -20,-10], style(color=71, rgbcolor={85,170,255}));
        connect(mTF1.MultiBondCon2, MultiBond1.MultiBondCon1)
          annotation (points=[0,-10; 0,-10], style(color=71, rgbcolor={85,170,255}));
        connect(mTF1.M, planarRotation1.Rrel) annotation (points=[-10,-20; -10,-36;
              -36,-36; -36,-40], style(color=3, rgbcolor={0,0,255}));
        connect(projectiveTF.MultiBondConA, MultiBond3.MultiBondCon1)
          annotation (points=[30,-40; 30,-40], style(color=71, rgbcolor={85,170,
                255}));
        connect(projectiveTF.MultiBondConB, MultiBond5.MultiBondCon2)
          annotation (points=[30,-60; 30,-60], style(color=71, rgbcolor={85,170,
                255}));
      end Revolute;

      model ActuatedRevolute "revolute joint with 1 degree of freedom"
        import SI = Modelica.SIunits;
        import MB = Modelica.Mechanics.MultiBody;
        import Cv = Modelica.SIunits.Conversions;
        annotation (Icon(
            Rectangle(extent=[-100,-60; -20,60], style(
                color=8,
                rgbcolor={192,192,192},
                gradient=2,
                fillColor=83,
                rgbfillColor={255,170,255})),
            Rectangle(extent=[40,-60; 100,60], style(
                color=8,
                rgbcolor={192,192,192},
                gradient=2,
                fillColor=83,
                rgbfillColor={255,170,255},
                fillPattern=1)),
            Rectangle(extent=[-20,10; 20,-10], style(
                color=0,
                rgbcolor={0,0,0},
                gradient=0,
                fillColor=83,
                rgbfillColor={255,170,255},
                fillPattern=1)),
            Text(
              extent=[-99,12; -63,-13],
              style(color=10),
              string="a"),
            Text(
              extent=[63,11; 99,-14],
              style(color=10),
              string="b"),
            Text(extent=[-100,136; 102,84], string="%name"),
               Text(
              extent=[-100,60; 100,92],
              style(color=0),
              string="n=%n"),
            Line(points=[-10,78; -50,78],   style(color=0)),
            Line(points=[-50,68; -50,98],   style(color=0)),
            Line(points=[-10,88; -10,68],   style(color=0)),
            Line(points=[30,88; 30,68],   style(color=0)),
            Line(points=[30,78; 51,78],   style(color=0)),
            Rectangle(extent=[0,-40; 20,-80], style(
                color=8,
                rgbcolor={192,192,192},
                gradient=1,
                fillColor=83,
                rgbfillColor={255,170,255})),
            Polygon(points=[0,-20; 20,-20; 40,-40; -20,-40; 0,-20], style(
                color=0,
                rgbcolor={0,0,0},
                fillColor=83,
                rgbfillColor={255,170,255})),
            Polygon(points=[20,20; 40,40; 40,-40; 20,-20; 20,20], style(
                color=0,
                rgbcolor={0,0,0},
                fillColor=83,
                rgbfillColor={255,170,255})),
            Line(points=[-12,-70; -52,-70], style(color=0)),
            Line(points=[-12,-60; -12,-80], style(color=0)),
            Line(points=[-52,-80; -52,-60], style(color=0)),
            Line(points=[28,-70; 60,-70], style(color=0)),
            Line(points=[28,-60; 28,-80], style(color=0))),   Diagram(
            Rectangle(extent=[-78,20; -58,0],  style(color=5, rgbcolor={255,0,255})),
            Text(
              extent=[-78,16; -58,4],
              style(color=5, rgbcolor={255,0,255}),
              string="root?"),
            Line(points=[-98,24; -88,24; -88,8; -78,8],       style(color=5, rgbcolor=
                   {255,0,255})),
            Line(points=[-58,10; -16,10; -16,18],    style(color=5, rgbcolor={255,0,
                    255})),
            Line(points=[-40,36; -40,10],  style(color=5, rgbcolor={255,0,255}))),
          Documentation(info="<html>
This is a revolute joint. The two connected frames are allowed to rotate around the joint axis.
This joint defines one degree of freedom. <br>
This revolute joint has two additional 1-dimensional mechanical flanges (flange \"axis\" represents the driving flange and
flange \"bearing\" represents the bearing) where it can be driven with elements of the
<a href=\"Modelica://BondLib.Mechanical.Rotational\">BondLib.Mechanical.Rotational</a> library.

<p>
<img src=\"../Images/Revolute.png\">
</p>
<h3>General parameter</h3>
The rotation axis of the revolute joint can be defined by the parameter n. n can be of arbitrary length, but it must not be zero.
<p>
The parameter phi_offset defines an offset value for the revolute angle phi.
<p>
The parameter animation toggles the visualization of the element.
<h3>Initialization</h3>
In general, you can specify...
<ul>
<li>...the initial revolute angle.
<li>...the initial angular velocity.
<li>...the initial angular acceleration.
</ul>
Which of these variables do effectively appear in the inital equations can be defined by the parameter initType.
<h3>Visualization</h3>
This element is visualized by cylinder along the rotation axis. The settings for length, diameter and color can be specified by the animation parameters.
<h3>Advanced settings</h3>
The activation of enforceStates enforces the joint to explicitely define integrators.
This parameter is useful to choose the state variables in a kinematic loop.
</html>"));

        parameter Boolean animation = true "animate revolute joint as cylinder";
        parameter SI.Position n[3] = {0,0,1} "direction of revolute axis"    annotation(Evaluate=true);
        final parameter SI.Position eN[3] = n/sqrt(n*n) annotation(Evaluate = true);
        parameter Cv.NonSIunits.Angle_deg phi_offset = 0
          "phi + phi_offset = angle between frames";
        final parameter SI.Angle phi_offset_rad = Cv.from_deg(phi_offset);

        parameter MB.Types.Init.Temp initType=MB.Types.Init.Free
          "|Initialization| Type of initialization (defines usage of start values below)";
        parameter Cv.NonSIunits.Angle_deg phi_start = 0
          "|Initialization|initial angle";
        parameter Types.AngularVelocity_deg w_start = 0
          "|Initialization|initial angular velocity";
        parameter Types.AngularAcceleration_deg z_start = 0
          "|Initialization|initial angular acceleration";

        final parameter SI.Angle phi_start_rad = Cv.from_deg(phi_start)
          "initial cardan angles";
        final parameter SI.AngularVelocity w_start_rad = Cv.from_deg(w_start)
          "initial angular velocity";
        final parameter SI.AngularAcceleration z_start_rad = Cv.from_deg(z_start)
          "initial angular acceleration";

        parameter SI.Distance cylinderLength=world3D.defaultJointLength
          "|Animation|if animation = true| Length of cylinder representing the joint axis";
        parameter SI.Distance cylinderDiameter=world3D.defaultJointWidth
          "|Animation|if animation = true| Diameter of cylinder representing the joint axis";
        parameter Modelica.Mechanics.MultiBody.Types.Color cylinderColor=world3D.defaultJointColor
          "|Animation|if animation = true| Color of cylinder representing the joint axis";

        parameter Boolean enforceStates =  false
          "|Advanced||enforce phi and w as states";

        SI.Angle phi(stateSelect=if enforceStates then StateSelect.always else StateSelect.prefer)
          "revolute angle";
        SI.AngularVelocity w(stateSelect=if enforceStates then StateSelect.always else StateSelect.prefer)
          "revolute angular velocity";
        SI.AngularAcceleration z "revolute angular acceleration";

        replaceable Interfaces.Frame_a frame_a
          "|Advanced||replaceable Interface for further extensions"
                                   annotation (extent=[-120,-20; -100,20]);
        replaceable Interfaces.Frame_b frame_b
          "|Advanced||replaceable Interface for further extensions"
                                   annotation (extent=[100,-20; 120,20]);

      protected
        outer World3D world3D;
        inner Defaults MBG_defaults(n=3) annotation (extent=[-100,80; -80,100]);
        replaceable Interfaces.Mech2MBG Mech2MBG1
                                      annotation (extent=[-100,20; -80,100]);
        replaceable Interfaces.MBG2Mech MBG2Mech1
                                      annotation (extent=[80,20; 100,100]);
        Junctions.J1 J1_1(n=1) annotation (extent=[0,-40; 20,-20]);
        Sensors.Dq Dq_phi(stateInitialCondition=false, n=1)
                          annotation (extent=[-32,-40; -12,-20],rotation=180);
        Junctions.J0 J0_1 annotation (extent=[40,20; 60,40]);
        AdditionalMBG.mTF mTF1 annotation (extent=[-20,20; 0,40]);
        Bonds.MultiBond MultiBond7      annotation (extent=[60,20; 80,40]);
        Bonds.MultiBond MultiBond8      annotation (extent=[60,80; 80,100]);
        Bonds.MultiBond MultiBond6(n=1)
          annotation (extent=[-12,-20; 0,-40],
                                             rotation=180);
         Bonds.MultiBond MultiBond1      annotation (extent=[20,20; 40,40]);
        Bonds.MultiBond MultiBond2      annotation (extent=[-40,20; -20,40]);
        Bonds.MultiBond MultiBond3
          annotation (extent=[40,0; 60,20], rotation=90);
        Bonds.MultiBond MultiBond5(n=1)
          annotation (extent=[30,-40; 50,-20],
                                             rotation=0);
        Bonds.Utilities.MultiBondTail MultiBondTail1
                                           annotation (extent=[-80,20; -38,40]);
        Bonds.Utilities.MultiBondTail MultiBondTail2
                                           annotation (extent=[-80,80; 62,100]);
        Bonds.Utilities.MultiBondTail MultiBondTail3
                                           annotation (extent=[2,20; 22,40]);
        Utilities.Rotation Rotation1     annotation (extent=[-46,60; -26,40]);
        Utilities.planarRotation planarRotation1(n=eN)
          annotation (extent=[-46,-20; -26,0],
                                             rotation=90);

        parameter Integer ndim=if world3D.enableAnimation and animation then 1 else 0;
        MB.Visualizers.Advanced.Shape cylinder[ndim](
          each shapeType="cylinder",
          each color=cylinderColor,
          each length=cylinderLength,
          each width=cylinderDiameter,
          each height=cylinderDiameter,
          each lengthDirection=eN,
          each widthDirection={0,1,0},
          each r_shape=-eN*cylinderLength/2,
          each r=Mech2MBG1.x,
          each R=MB.Frames.Orientation(T=Mech2MBG1.R,w=zeros(3)));

      public
        Passive.TF2_effort projectiveTF(
          nA=3,
          nB=1,
          M={eN}) annotation (extent=[40,-20; 60,0],   rotation=270);
        BondLib.Mechanical.Rotational.Interfaces.Flange_a axis
          annotation (extent=[60,-80; 80,-60]);
        BondLib.Mechanical.Rotational.Interfaces.Flange_b bearing
          annotation (extent=[-80,-80; -60,-60]);
        BondLib.Mechanical.Rotational.Interfaces.Rot2BG rot2BG
          annotation (extent=[-60,-80; -40,-60]);
        BondLib.Mechanical.Rotational.Interfaces.BG2Rot bG2Rot
          annotation (extent=[40,-60; 60,-80]);
        BondLib.Bonds.Bond bond annotation (extent=[-20,-80; -40,-60]);
      protected
        Bonds.Utilities.MultiBondTail MultiBondTail4
                                           annotation (extent=[20,-40; 34,-20]);
      public
        Modelica.Blocks.Sources.Constant Constant(k=0)
          annotation (extent=[-56,-96; -44,-84]);
        BondLib.Sources.Sf sf(f0=0)
          annotation (extent=[-20,-80; 0,-60], rotation=0);
      protected
        Bonds.Utilities.MultiBondTail MultiBondTail7
                                           annotation (extent=[0,-40; 20,-68],
            rotation=270);
        Bonds.Utilities.MultiBondTail MultiBondTail8
                                           annotation (extent=[12,-80; 24,-60],
            rotation=0);
      public
        Compositions.FromMultiBond fromMultiBond
          annotation (extent=[22,-80; 40,-60]);
      initial equation
        if initType == MB.Types.Init.Position or initType == MB.Types.Init.
            PositionVelocity or initType == MB.Types.Init.PositionVelocityAcceleration then
          // Initialize positional variables
          phi = phi_start_rad;
        end if;

        if initType == MB.Types.Init.PositionVelocity or initType == MB.Types.Init.
            PositionVelocityAcceleration or initType == MB.Types.Init.Velocity or
            initType == MB.Types.Init.VelocityAcceleration then
          // Initialize velocity variables
          w = w_start_rad;
        end if;

        if initType == MB.Types.Init.VelocityAcceleration or initType == MB.Types.Init.
            PositionVelocityAcceleration then
          // Initialize acceleration variables
          z = z_start_rad;
        end if;

        if initType == MB.Types.Init.SteadyState then
          w = 0;
          z = 0;
        end if;

      equation
        defineBranch(frame_a.P,frame_b.P);

        //change the causality of the transformation according to the root's position
        if rooted(frame_a.P) then
          Rotation1.dirForward = true;
          mTF1.transformFlow = true;
        else
          Rotation1.dirForward = false;
          mTF1.transformFlow = false;
        end if;

        phi = Dq_phi.q[1]-phi_offset_rad;
        w = J1_1.MultiBondCon1.f[1];
        z = der(w);
        connect(MBG2Mech1.frame_b, frame_b) annotation (points=[99,60; 110,60;
              110,0], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            gradient=2,
            fillColor=71,
            rgbfillColor={85,170,255}));
        connect(Mech2MBG1.frame_a, frame_a) annotation (points=[-99,60; -100,60;
              -100,0; -110,0],
                          style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            gradient=2,
            fillColor=71,
            rgbfillColor={85,170,255}));
        connect(Mech2MBG1.x, MBG2Mech1.x) annotation (points=[-80,70; 80,70],
                                            style(color=3, rgbcolor={0,0,255}));
        connect(Mech2MBG1.R, Rotation1.R1) annotation (points=[-80,50; -46,50],
                    style(color=3, rgbcolor={0,0,255}));
        connect(Rotation1.R2, MBG2Mech1.R) annotation (points=[-26,50; 80,50],
            style(color=3, rgbcolor={0,0,255}));
        connect(planarRotation1.phi, Dq_phi.q[1]) annotation (points=[-36,-20;
              -36,-30; -32,-30],
                      style(color=3, rgbcolor={0,0,255}));
        connect(planarRotation1.Rrel, Rotation1.Rrel) annotation (points=[-36,0;
              -36,40],          style(color=3, rgbcolor={0,0,255}));
        connect(MultiBond8.MultiBondCon2, MBG2Mech1.MultiBondConTrans)
          annotation (points=[80,90; 80,90], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond8.MultiBondCon1, Mech2MBG1.MultiBondConTrans) annotation (
            points=[60,90; -80,90],                 style(color=71, rgbcolor={85,170,
                255}));
        connect(MultiBond7.MultiBondCon2, MBG2Mech1.MultiBondConRot) annotation (
            points=[80,30; 80,30],   style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond2.MultiBondCon1, Mech2MBG1.MultiBondConRot) annotation (
            points=[-40,30; -79.8,30],   style(color=71, rgbcolor={85,170,255}));
        connect(J0_1.MultiBondCon2, MultiBond7.MultiBondCon1) annotation (points=[60,30;
              60,30],       style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond1.MultiBondCon2, J0_1.MultiBondCon1) annotation (points=[40,30;
              40,30],       style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond3.MultiBondCon2, J0_1.MultiBondCon3) annotation (points=[50,20;
              50,20],       style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond6.MultiBondCon1, J1_1.MultiBondCon1) annotation (points=[0,-30; 0,
              -30],         style(color=71, rgbcolor={85,170,255}));
        connect(Dq_phi.MultiBondCon1, MultiBond6.MultiBondCon2)
          annotation (points=[-12,-30; -12,-30],
                                             style(color=71, rgbcolor={85,170,255}));
        connect(mTF1.MultiBondCon1, MultiBond2.MultiBondCon2) annotation (points=[-20,30;
              -20,30],       style(color=71, rgbcolor={85,170,255}));
        connect(mTF1.MultiBondCon2, MultiBond1.MultiBondCon1)
          annotation (points=[0,30; 20,30],  style(color=71, rgbcolor={85,170,255}));
        connect(mTF1.M, planarRotation1.Rrel) annotation (points=[-10,20; -10,4;
              -36,4; -36,0],     style(color=3, rgbcolor={0,0,255}));
        connect(projectiveTF.MultiBondConA, MultiBond3.MultiBondCon1)
          annotation (points=[50,0; 50,0],     style(color=71, rgbcolor={85,170,
                255}));
        connect(rot2BG.Rot, bearing) annotation (points=[-60,-70; -70,-70],
            style(color=0, rgbcolor={0,0,0}));
        connect(bG2Rot.Rot, axis) annotation (points=[60,-70; 70,-70], style(
              color=0, rgbcolor={0,0,0}));
        connect(J1_1.MultiBondCon2, MultiBond5.MultiBondCon1) annotation (
            points=[20,-30; 30,-30], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond5.MultiBondCon2, projectiveTF.MultiBondConB)
          annotation (points=[50,-30; 50,-20], style(color=71, rgbcolor={85,170,
                255}));
        connect(Dq_phi.q[1], bG2Rot.phi) annotation (points=[-32,-30; -36,-30;
              -36,-50; 50,-50; 50,-60], style(color=3, rgbcolor={0,0,255}));
        connect(Constant.y, rot2BG.phi) annotation (points=[-43.4,-90; -50,-90;
              -50,-80], style(color=74, rgbcolor={0,0,127}));
        connect(bond.BondCon2, rot2BG.BondCon1) annotation (points=[-40,-70;
              -40,-70], style(
            color=8,
            rgbcolor={192,192,192},
            pattern=0));
        connect(sf.BondCon1, bond.BondCon1) annotation (points=[-20,-70; -20.2,
              -70], style(
            color=8,
            rgbcolor={192,192,192},
            pattern=0));
        connect(fromMultiBond.BondCon1, bG2Rot.BondCon1) annotation (points=[40,
              -70; 40,-70], style(
            color=8,
            rgbcolor={192,192,192},
            pattern=0));
        connect(J1_1.MultiBondCon3, fromMultiBond.MultiBondCon1) annotation (
            points=[10,-40; 10,-70; 22,-70], style(
            color=71,
            rgbcolor={85,170,255},
            pattern=0));
      end ActuatedRevolute;

      model Spherical
        "spherical joint with all 3 rotational degrees of freedom"
        import SI = Modelica.SIunits;
        import Cv = Modelica.SIunits.Conversions;

        import MB = Modelica.Mechanics.MultiBody;
        import MultiBondLib;
        annotation (Icon(
            Ellipse(extent=[-70,-70; 70,70], style(
                color=10,
                rgbcolor={128,128,128},
                gradient=3,
                fillColor=83,
                rgbfillColor={255,170,255})),
            Ellipse(extent=[-49,-50; 51,50],   style(
                color=10,
                fillColor=7,
                fillPattern=1)),
            Rectangle(extent=[30,70; 71,-68],   style(
                color=7,
                fillColor=7,
                fillPattern=1)),
            Rectangle(extent=[-100,10; -68,-10], style(
                color=10,
                rgbcolor={128,128,128},
                gradient=2,
                fillColor=83,
                rgbfillColor={255,170,255})),
            Rectangle(extent=[23,10; 100,-10], style(
                color=10,
                rgbcolor={128,128,128},
                gradient=2,
                fillColor=83,
                rgbfillColor={255,170,255},
                fillPattern=1)),
            Ellipse(extent=[-24,25; 26,-25], style(
                color=0,
                rgbcolor={0,0,0},
                gradient=3,
                fillColor=83,
                rgbfillColor={255,170,255})),
            Text(extent=[-100,-130; 100,-70], string="%name"),
                           Text(
              extent=[81,-25; 118,-54],
              style(color=10),
              string="b"),
               Text(
              extent=[-118,-22; -80,-50],
              style(color=10),
              string="a")),                                   Diagram(
            Text(
              extent=[-80,-4; -60,-16],
              style(color=5, rgbcolor={255,0,255}),
              string="root?"),
            Rectangle(extent=[-80,0; -60,-20], style(color=5, rgbcolor={255,0,255})),
            Line(points=[-40,18; -40,-10], style(color=5, rgbcolor={255,0,255})),
            Line(points=[-60,-10; -16,-10; -16,-4], style(color=5, rgbcolor={255,0,255})),
            Line(points=[-80,-10; -98,-10], style(color=5, rgbcolor={255,0,255})),
            Line(points=[-36,18; -36,-16], style(color=3, rgbcolor={0,0,255})),
            Line(points=[-34,-16; -10,-16], style(color=3, rgbcolor={0,0,255})),
            Line(points=[-10,-2; -10,-16], style(color=3, rgbcolor={0,0,255})),
            Line(points=[-30,-16; -30,-28], style(color=3, rgbcolor={0,0,255})),
            Line(points=[50,-82; 50,-90], style(color=3, rgbcolor={0,0,255})),
            Line(points=[50,-90; 30,-90], style(color=3, rgbcolor={0,0,255}))),
          Documentation(info="<html>
This is an spherical joint. The two connected frames are allowed to rotate freely.
This joint defines three degrees of freedom.
<p>
<img src=\"../Images/Spherical.png\">
</p>
<h3>General parameter</h3>
The parameter animation toggles the visualization of the element
<h3>Initialization</h3>
In general, you can specify...
<ul>
<li>...the initial orientation.
<li>...the initial angular velocity.
<li>...the initial angular acceleration.
</ul>
Which of these variables do effectively appear in the inital equations can be defined by the parameter initType.
<h3>Visualization</h3>
This element is visualized by a sphere.
<h3>Advanced settings</h3>
The activation of enforceStates enforces the joint to explicitely define integrators.
This parameter is useful to choose the state variables in a kinematic loop.
<p>
The orientation can either be expressed by the three cardan angles or by quaternions.
<ul>
<li>The usage of cardan angles leads to a faster computation but contains a singular point. It is therefore of limited applicability.
<li> The usage of quaternions lead to a robust solution, but it generates the need for dynamic state selection and leads to non-linear equations.
</ul>
<p>
Which of these two variants is used, can be specified by the parameter useQuaternions.
If cardan angles are chosen to be used, you can specify the sequence of rotation axis by the parameter sequence_angles.
</html>"));

        parameter Boolean animation = true "animate spherical joint as sphere";

        parameter MB.Types.Init.Temp initType=MB.Types.Init.Free
          "|Initialization| Type of initialization (defines usage of start values below)";

        parameter Cv.NonSIunits.Angle_deg phi_start[3] = {0,0,0}
          "|Initialization|initial cardan angles in degree";
        parameter Types.AngularVelocity_deg w_start[3] = {0,0,0}
          "|Initialization|initial angular velocity in deg/s";
        parameter Types.AngularAcceleration_deg z_start[3] = {0,0,0}
          "|Initialization|initial angular acceleration in deg/s2";

        final parameter SI.Angle phi_start_rad[3] = Cv.from_deg(phi_start)
          "initial cardan angles";
        final parameter SI.AngularVelocity w_start_rad[3] = Cv.from_deg(w_start)
          "initial angular velocity";
        final parameter SI.AngularAcceleration z_start_rad[3] = Cv.from_deg(z_start)
          "initial angular acceleration";

        parameter SI.Distance sphereDiameter=world3D.defaultJointLength
          "|if animation = true| Diameter of sphere representing the spherical joint";
        parameter MB.Types.Color sphereColor=world3D.defaultJointColor
          "|if animation = true| Color of sphere representing the spherical joint";

        parameter Boolean enforceStates =  false
          "|Advanced||enforce Quaternions or cardan angles and w as states";
        parameter Boolean useQuaternions =  true
          "|Advanced||use Quaternions instead of cardan angles";
        parameter Types.RotationSequence sequence_angles = {1,2,3}
          "|Advanced||sequence of the cardan angles";

        final parameter Types.Quaternion Q_start = Utilities.AxesRotQ(phi_start_rad,sequence_angles);

        Types.Quaternion Q(stateSelect=if useQuaternions then StateSelect.prefer else StateSelect.never,start = Q_start, fixed = false)
          "quaternions";
        SI.Angle phi[3](stateSelect=if not useQuaternions then (if enforceStates then
                        StateSelect.always else StateSelect.prefer) else  StateSelect.never)
          "cardan angles";
        SI.Angle phi_d[3](stateSelect=if not useQuaternions then (if enforceStates then
                        StateSelect.always else StateSelect.prefer) else  StateSelect.never)
          "cardan angles derivatives";

        SI.AngularVelocity w[3](stateSelect=if useQuaternions then (if enforceStates then
                        StateSelect.always else StateSelect.prefer) else  StateSelect.default)
          "angular velocity";
        SI.AngularAcceleration z[3] "angular acceleration";

        replaceable Interfaces.Frame_a frame_a
          "|Advanced||replaceable Interface for further extensions"
                                   annotation (extent=[-120,-20; -100,20]);
        replaceable Interfaces.Frame_b frame_b
          "|Advanced||replaceable Interface for further extensions"
                                   annotation (extent=[100,-20; 120,20]);

      protected
        outer World3D world3D;
        inner Defaults MBG_defaults(n=3) annotation (extent=[-100,80; -80,100]);
        replaceable Interfaces.Mech2MBG Mech2MBG1
                                      annotation (extent=[-100,0; -80,80]);
        replaceable Interfaces.MBG2Mech MBG2Mech1
                                      annotation (extent=[80,0; 100,80]);
        Junctions.J1 J1_1(n=3) annotation (extent=[40,-40; 60,-20]);
        Sources.Se Se1(     e0={0}, n=3)
                                    annotation (extent=[0,-40; 20,-20],rotation=180);
        Sensors.Df Df1(n=3) annotation (extent=[40,-80; 60,-60],
                                                               rotation=270);
        MultiBondLib.Junctions.J0 J0_1 annotation (extent=[40,0; 60,20]);
        AdditionalMBG.mTF mTF1                            annotation (extent=[-20,0; 0,20]);
        Bonds.MultiBond MultiBond1      annotation (extent=[20,0; 40,20]);
        Bonds.MultiBond MultiBond2      annotation (extent=[-40,0; -20,20]);
        Bonds.MultiBond MultiBond3
          annotation (extent=[40,-20; 60,0],rotation=90);
        Bonds.MultiBond MultiBond4
          annotation (extent=[20,-40; 40,-20],
                                             rotation=0);
        Bonds.MultiBond MultiBond7      annotation (extent=[60,0; 80,20]);
        Bonds.MultiBond MultiBond5
          annotation (extent=[40,-60; 60,-40],
                                             rotation=270);
        Bonds.MultiBond MultiBond6      annotation (extent=[60,60; 80,80]);
        Bonds.Utilities.MultiBondTail MultiBondTail1
                                           annotation (extent=[-80,0; -38,20]);
        Bonds.Utilities.MultiBondTail MultiBondTail2
                                           annotation (extent=[-80,60; 64,80]);
        Bonds.Utilities.MultiBondTail MultiBondTail3
                                           annotation (extent=[0,0; 22,20]);

        Utilities.Rotation Rotation1     annotation (extent=[-46,40; -26,20]);
        Utilities.toQuaternions toQuaternions1 if useQuaternions     annotation (extent=[20,-100;
              0,-80]);
        Utilities.quaternionRotation quaternionRotation1 if useQuaternions     annotation (extent=[-60,-60;
              -40,-40], rotation=90);
        Utilities.cardanRotation cardanRotation1(
            sequence_angles=sequence_angles) if                                   not useQuaternions
          annotation (extent=[-40,-60; -20,-40], rotation=90);
        Utilities.toCardanAngles toCardanAngles1(sequence_angles=sequence_angles) if
                                                        not useQuaternions
          annotation (extent=[0,-80; -20,-60], rotation=0);
        MultiBondLib.Interfaces.RealSignal S_Q[4]
          annotation (extent=[-80,-100; -60,-80]);
        MultiBondLib.Interfaces.RealSignal S_phi[ 3]
          annotation (extent=[-80,-80; -60,-60]);

        parameter Integer ndim=if world3D.enableAnimation and animation then 1 else 0;
        MB.Visualizers.Advanced.Shape sphere[ndim](
          each shapeType="sphere",
          each color=sphereColor,
          each length=sphereDiameter,
          each width=sphereDiameter,
          each height=sphereDiameter,
          each lengthDirection={0,0,1},
          each widthDirection={0,1,0},
          each r_shape=-{0,0,1}*sphereDiameter/2,
          each r=Mech2MBG1.x,
          each R=MB.Frames.Orientation(T=Mech2MBG1.R,w=zeros(3)));

      initial equation
        if initType == MB.Types.Init.Position or initType == MB.Types.Init.
            PositionVelocity or initType == MB.Types.Init.PositionVelocityAcceleration then
          // Initialize positional variables
          if useQuaternions then
            Q[1:3] = Q_start[1:3];
          else
            phi = phi_start_rad;
          end if;
        end if;

        if initType == MB.Types.Init.PositionVelocity or initType == MB.Types.Init.
            PositionVelocityAcceleration or initType == MB.Types.Init.Velocity or
            initType == MB.Types.Init.VelocityAcceleration then
          // Initialize velocity variables
          w = w_start_rad;
        end if;

        if initType == MB.Types.Init.VelocityAcceleration or initType == MB.Types.Init.
            PositionVelocityAcceleration then
          // Initialize acceleration variables
          z = z_start_rad;
        end if;

        if initType == MB.Types.Init.SteadyState then
          w = zeros(3);
          z = zeros(3);
        end if;

      equation
        defineBranch(frame_a.P,frame_b.P);

        //change the causality of the transformation according to the root's position
        if rooted(frame_a.P) then
          Rotation1.dirForward = true;
          mTF1.transformFlow = true;
        else
          Rotation1.dirForward = false;
          mTF1.transformFlow = false;
        end if;

        Q = S_Q;
        phi = S_phi;
        w = Df1.f_out;

        if useQuaternions then
          phi = zeros(3); //dummy
          phi_d = zeros(3);
        else
          Q = {0,0,0,1}; //dummy
          phi_d = der(phi);
        end if;
        z = der(w);
        connect(MBG2Mech1.frame_b, frame_b) annotation (points=[99,40; 100,40; 100,-2;
              106,-2; 106,0; 110,0],
                      style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            gradient=2,
            fillColor=71,
            rgbfillColor={85,170,255}));
        connect(Mech2MBG1.frame_a, frame_a) annotation (points=[-99,40; -100,40; -100,
              0; -110,0], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            gradient=2,
            fillColor=71,
            rgbfillColor={85,170,255}));
        connect(Mech2MBG1.x, MBG2Mech1.x) annotation (points=[-80,50; 80,50],
                                            style(color=3, rgbcolor={0,0,255}));
        connect(Mech2MBG1.R, Rotation1.R1) annotation (points=[-80,30; -46,30],
                    style(color=3, rgbcolor={0,0,255}));
        connect(Rotation1.R2, MBG2Mech1.R) annotation (points=[-26,30; 80,30],
            style(color=3, rgbcolor={0,0,255}));
        connect(toQuaternions1.Q, quaternionRotation1.Q) annotation (points=[0,-90;
              -50,-90; -50,-60], style(
            color=3,
            rgbcolor={0,0,255},
            pattern=4));
        connect(quaternionRotation1.Rrel, Rotation1.Rrel) annotation (points=[-50,-40;
              -50,-28; -30,-28; -30,-16; -36,-16; -36,20], style(
            color=3,
            rgbcolor={0,0,255},
            pattern=4,
            fillColor=83,
            rgbfillColor={255,170,255},
            fillPattern=1));
        connect(toQuaternions1.w, Df1.f_out) annotation (points=[20,-90; 50,-90; 50,
              -80], style(
            color=3,
            rgbcolor={0,0,255},
            pattern=4,
            fillColor=83,
            rgbfillColor={255,170,255},
            fillPattern=1));
        connect(J1_1.MultiBondCon4, MultiBond3.MultiBondCon1) annotation (points=[50,-20;
              50,-20],      style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond5.MultiBondCon1, J1_1.MultiBondCon3) annotation (points=[50,-40;
              50,-40],      style(color=71, rgbcolor={85,170,255}));
        connect(Df1.MultiBondCon1, MultiBond5.MultiBondCon2) annotation (points=[50,-60;
              50,-60],      style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond4.MultiBondCon2, J1_1.MultiBondCon1) annotation (points=[40,-30;
              40,-30],      style(color=71, rgbcolor={85,170,255}));
        connect(Se1.MultiBondCon1, MultiBond4.MultiBondCon1)
          annotation (points=[20,-30; 20,-30],
                                             style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond6.MultiBondCon2, MBG2Mech1.MultiBondConTrans)
          annotation (points=[80,70; 80,70], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond6.MultiBondCon1, Mech2MBG1.MultiBondConTrans) annotation (
            points=[60,70; -80,70], style(color=71, rgbcolor={85,170,255}));
        connect(J0_1.MultiBondCon1, MultiBond1.MultiBondCon2)
          annotation (points=[40,10; 40,10], style(color=71, rgbcolor={85,170,255}));
        connect(J0_1.MultiBondCon2, MultiBond7.MultiBondCon1)
          annotation (points=[60,10; 60,10], style(color=71, rgbcolor={85,170,255}));
        connect(J0_1.MultiBondCon3, MultiBond3.MultiBondCon2)
          annotation (points=[50,0; 50,0], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond2.MultiBondCon1, Mech2MBG1.MultiBondConRot) annotation (
            points=[-40,10; -79.8,10], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond7.MultiBondCon2, MBG2Mech1.MultiBondConRot)
          annotation (points=[80,10; 80,10], style(color=71, rgbcolor={85,170,255}));
        connect(mTF1.MultiBondCon2, MultiBond1.MultiBondCon1)
          annotation (points=[0,10; 20,10], style(color=71, rgbcolor={85,170,255}));
        connect(mTF1.MultiBondCon1, MultiBond2.MultiBondCon2) annotation (points=[-20,
              10; -20,10], style(color=71, rgbcolor={85,170,255}));
        connect(quaternionRotation1.Rrel, mTF1.M) annotation (points=[-50,-40; -50,
              -28; -30,-28; -30,-16; -10,-16; -10,0], style(
            color=3,
            rgbcolor={0,0,255},
            pattern=4));
        connect(toCardanAngles1.phi, cardanRotation1.phi) annotation (points=[-20,-70;
              -30,-70; -30,-60], style(
            color=3,
            rgbcolor={0,0,255},
            pattern=4));
        connect(toCardanAngles1.w, Df1.f_out) annotation (points=[0,-70; 30,-70; 30,
              -90; 50,-90; 50,-80], style(
            color=3,
            rgbcolor={0,0,255},
            pattern=4));
        connect(cardanRotation1.Rrel, mTF1.M) annotation (points=[-30,-40; -30,
              -16; -10,-16; -10,0],
                               style(
            color=3,
            rgbcolor={0,0,255},
            pattern=4));
        connect(cardanRotation1.Rrel, Rotation1.Rrel) annotation (points=[-30,-40;
              -30,-16; -36,-16; -36,20], style(
            color=3,
            rgbcolor={0,0,255},
            pattern=4));
        connect(toQuaternions1.Q, S_Q)
          annotation (points=[0,-90; -70,-90], style(
            color=3,
            rgbcolor={0,0,255},
            pattern=4));
        connect(toCardanAngles1.phi, S_phi)
          annotation (points=[-20,-70; -70,-70], style(
            color=3,
            rgbcolor={0,0,255},
            pattern=4));
      end Spherical;

      annotation (preferedView="info", Documentation(info="<html>
This package contains models of joints.
<p>
Joints are massles objects, that define the relative movement between two rigid elements.
The number of degrees of freedom specifies how many variables are minimally needed to describe the relative
position. An object in 3D-space can have up to 6 degrees of freedom.
<p>
Joints usually define integrators and the joint variables on positional and velocity level
become state variables of the system. Anyhow the integrators might be removed by the Pantelides algorithm, if the joint is placed in a kinematic loop.<br>
The number of degrees of freedom equals the number of potential state variables.
<p>
It is possible and common to create complex joints out of simple joints.
However, one has to pay attention that no singularities occur if two or more joints are connected (directly or through massless elements).
</html>"));

      model FreeTranslationalMovement
        "joint with all 3 translational degrees of freedom"
        annotation (Diagram, Icon(
            Line(points=[0,100; 0,-100],   style(color=0)),
            Line(points=[-100,0; 100,0],style(color=0)),
            Text(extent=[-118,146; 112,88], string="%name"),
            Text(
              extent=[112,-130; -120,-90],
              style(color=0),
              string="r=%r"),
            Line(points=[-60,-60; 60,60],
                                        style(color=0)),
            Line(points=[-40,-40; 40,40], style(color=5, rgbcolor={255,0,255})),
            Line(points=[0,60; 0,-60], style(color=5, rgbcolor={255,0,255})),
            Line(points=[-60,0; 60,0], style(color=5, rgbcolor={255,0,255})),
            Ellipse(extent=[-20,20; 20,-20], style(
                color=1,
                rgbcolor={255,0,0},
                fillColor=1,
                rgbfillColor={255,0,0},
                fillPattern=1))),
          Documentation(info="<html>
This is an untypical joint. The translational movement of its connected element is not restricted
and all 3 translational degrees of freedom are defined. The orientation is fixated.
<h3>General parameter</h3>
The parameter r defines a positional offset.
<h3>Initialization</h3>
In general, you can specify...
<ul>
<li>...the initial position.
<li>...the initial velocity.
<li>...the initial acceleration.
</ul>
Which of these variables do effectively appear in the inital equations can be defined by the parameter initType.
<h3>Visualization</h3>
This element isn't visualized.
<h3>Advanced settings</h3>
The activation of enforceStates enforces the joint to explicitely define integrators.
This parameter is useful to choose the state variables in a kinematic loop.
</html>"));
        import SI = Modelica.SIunits;
        import MB = Modelica.Mechanics.MultiBody;

        parameter SI.Position r[3] = {0,0,0}
          "positional shift to inertial frame"
                                             annotation(Evaluate=true);

        parameter MB.Types.Init.Temp initType=MB.Types.Init.Free
          "|Initialization| Type of initialization (defines usage of start values below)";
        parameter SI.Position x_start[3] = {0,0,0}
          "|Initialization|initial position";
        parameter SI.Velocity v_start[3] = {0,0,0}
          "|Initialization|initial velocity";
        parameter SI.Acceleration a_start[3] = {0,0,0}
          "|Initialization|initial acceleration";

        parameter Boolean enforceStates =  false
          "|Advanced||enforce position and velocity as states";

        SI.Position x[3](stateSelect=if enforceStates then StateSelect.always else StateSelect.prefer)
          "Position of the frame";
        SI.Velocity v[3](stateSelect=if enforceStates then StateSelect.always else StateSelect.prefer)
          "Velocity";
        SI.Acceleration a[3] "Acceleration";

        replaceable Interfaces.Frame_b frame_b
          "|Advanced||replaceable Interface for further extensions"
                                   annotation (extent=[100,-20; 120,20]);

      protected
        inner Defaults MBG_defaults(n=3) annotation (extent=[-80,60; -60,80]);
        replaceable Interfaces.MBG2Mech MBG2Mech1
                                      annotation (extent=[80,-40; 100,40]);
        Sources.Sf Sf1(     f0={0}, n=3)
                                    annotation (extent=[60,-40; 40,-20]);
        Junctions.J1 J1_1(n=3) annotation (extent=[22,20; 42,40]);
        Sources.Se Se1(n=3, e0={0}) annotation (extent=[42,60; 22,80],rotation=90);
        Sensors.Dq Dq1(
          n=3,
          stateInitialCondition=false,
          q_start=zeros(3)) annotation (extent=[-18,20; 2,40], rotation=180);
        Bonds.MultiBond MultiBond2      annotation (extent=[60,20; 80,40]);
        Bonds.MultiBond MultiBond3      annotation (extent=[60,-40; 80,-20]);
        Bonds.MultiBond MultiBond4      annotation (extent=[22,20; 2,40]);
        Bonds.MultiBond MultiBond5      annotation (extent=[22,40; 42,60], rotation=270);
        Bonds.Utilities.MultiBondTail MultiBondTail2
                                           annotation (extent=[40,20; 62,40]);
        Modelica.Blocks.Sources.Constant R0[3,3](k=identity(3))
          annotation (extent=[0,-20; 20,0]);

      initial equation
        if initType == MB.Types.Init.Position or initType == MB.Types.Init.
            PositionVelocity or initType == MB.Types.Init.PositionVelocityAcceleration then
          // Initialize positional variables
          x = x_start;
        end if;

        if initType == MB.Types.Init.PositionVelocity or initType == MB.Types.Init.
            PositionVelocityAcceleration or initType == MB.Types.Init.Velocity or
            initType == MB.Types.Init.VelocityAcceleration then
          // Initialize velocity variables
          v = v_start;
        end if;

        if initType == MB.Types.Init.VelocityAcceleration or initType == MB.Types.Init.
            PositionVelocityAcceleration then
          // Initialize acceleration variables
          a = a_start;
        end if;

        if initType == MB.Types.Init.SteadyState then
          v = zeros(3);
          a = zeros(3);
        end if;

      equation
        x+r = Dq1.q;
        v = J1_1.MultiBondCon2.f;
        a = der(v);
        defineRoot(frame_b.P);

        connect(MBG2Mech1.frame_b, frame_b) annotation (points=[99,0; 110,0],
                      style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Sf1.MultiBondCon1, MultiBond3.MultiBondCon1)
          annotation (points=[60,-30; 60,-30],
                                             style(color=71, rgbcolor={85,170,255}));
        connect(J1_1.MultiBondCon2, MultiBond2.MultiBondCon1)
          annotation (points=[42,30; 60,30],
                                           style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond3.MultiBondCon2, MBG2Mech1.MultiBondConRot) annotation (points=[80,-30;
              80,-30],         style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond2.MultiBondCon2, MBG2Mech1.MultiBondConTrans)
          annotation (points=[80,30; 80,30], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond4.MultiBondCon1, J1_1.MultiBondCon1)
          annotation (points=[22,30; 22,30],
                                           style(color=71, rgbcolor={85,170,255}));
        connect(Dq1.MultiBondCon1, MultiBond4.MultiBondCon2) annotation (points=[2,30; 2,
              30],         style(color=71, rgbcolor={85,170,255}));
        connect(Dq1.q, MBG2Mech1.x) annotation (points=[-18,30; -32,30; -32,10; 80,10],
            style(color=3, rgbcolor={0,0,255}));
        connect(MultiBond5.MultiBondCon1, Se1.MultiBondCon1)
          annotation (points=[32,60; 32,60], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond5.MultiBondCon2, J1_1.MultiBondCon4)
          annotation (points=[32,40; 32,40], style(color=71, rgbcolor={85,170,255}));
        connect(MBG2Mech1.R, R0.y)
          annotation (points=[80,-10; 21,-10],style(color=3, rgbcolor={0,0,255}));
      end FreeTranslationalMovement;

      model FreeBodyMovement "joint with all 6 degrees of freedom"
        import SI = Modelica.SIunits;
        import Cv = Modelica.SIunits.Conversions;

        import MB = Modelica.Mechanics.MultiBody;
        import MultiBondLib;
        annotation (Icon(
            Text(extent=[-116,134; 114,76], string="%name"),
            Ellipse(extent=[-70,70; 70,-70], style(
                color=5,
                rgbcolor={255,0,255},
                pattern=3)),
            Text(
              extent=[-92,-58; 94,-120],
              string="free",
              style(color=3, rgbcolor={0,0,255})),
            Line(points=[98,0; 60,0], style(color=5, rgbcolor={255,0,255})),
            Ellipse(extent=[-20,20; 20,-20], style(
                color=1,
                rgbcolor={255,0,0},
                fillColor=1,
                rgbfillColor={255,0,0},
                fillPattern=1)),
            Ellipse(extent=[-58,56; 56,-56], style(color=5, rgbcolor={255,0,255})),
            Ellipse(extent=[-42,40; 40,-42], style(color=79, rgbcolor={170,85,255}))),
                                                              Diagram(
            Line(points=[50,-82; 50,-90], style(color=3, rgbcolor={0,0,255})),
            Line(points=[50,-90; 30,-90], style(color=3, rgbcolor={0,0,255}))),
          Documentation(info="<html>
This is an untypical joint, that does not restrict the movement of its connected element
and defines all 6 degrees of freedom. The usage of this joint is hardly necessary, because it is potentially avaiable in each body element.
<h3>General parameter</h3>
There are no general parameters
<h3>Initialization</h3>
In general, you can specify...
<ul>
<li>...the initial position and orientation.
<li>...the initial velocity and angular velocity.
<li>...the initial acceleration and angular acceleration.
</ul>
Which of these variables do effectively appear in the inital equations can be defined by the parameter initType.
<h3>Visualization</h3>
This element isn't visualized.
<h3>Advanced settings</h3>
The activation of enforceStates enforces the joint to explicitely define integrators.
This parameter is useful to choose the state variables in a kinematic loop.
<p>
The orientation can either be expressed by the three cardan angles or by quaternions.
<ul>
<li>The usage of cardan angles leads to a faster computation but contains a singular point. It is therefore of limited applicability.
<li> The usage of quaternions lead to a robust solution, but it generates the need for dynamic state selection and leads to non-linear equations.
</ul>
<p>
Which of these two variants is used, can be specified by the parameter useQuaternions.
If cardan angles are chosen to be used, you can specify the sequence of rotation axis by the parameter sequence_angles.
</html>"));

        parameter MB.Types.Init.Temp initType=MB.Types.Init.Free
          "|Initialization| Type of initialization (defines usage of start values below)";

        parameter SI.Position x_start[3] = {0,0,0}
          "|Initialization|initial position";
        parameter SI.Velocity v_start[3] = {0,0,0}
          "|Initialization|initial velocity";
        parameter SI.Acceleration a_start[3] = {0,0,0}
          "|Initialization|initial acceleration";

        parameter Cv.NonSIunits.Angle_deg phi_start[3] = {0,0,0}
          "|Initialization|initial cardan angles in degree";
        parameter Types.AngularVelocity_deg w_start[3] = {0,0,0}
          "|Initialization|initial angular velocity in deg/s";
        parameter Types.AngularAcceleration_deg z_start[3] = {0,0,0}
          "|Initialization|initial angular acceleration in deg/s2";

        final parameter SI.Angle phi_start_rad[3] = Cv.from_deg(phi_start)
          "initial cardan angles";
        final parameter SI.AngularVelocity w_start_rad[3] = Cv.from_deg(w_start)
          "initial angular velocity";
        final parameter SI.AngularAcceleration z_start_rad[3] = Cv.from_deg(z_start)
          "initial angular acceleration";

        parameter Boolean enforceStates =  false
          "|Advanced||enforce Quaternions or cardan angles and w as states";
        parameter Boolean useQuaternions =  true
          "|Advanced||use Quaternions instead of cardan angles";
        parameter Types.RotationSequence sequence_angles = {1,2,3}
          "|Advanced||sequence of the cardan angles";
        final parameter Types.Quaternion Q_start = Utilities.AxesRotQ(phi_start_rad,sequence_angles);

        SI.Position x[3](stateSelect=if enforceStates then StateSelect.always else StateSelect.prefer)
          "Position of the frame";
        SI.Velocity v[3](stateSelect=if enforceStates then StateSelect.always else StateSelect.prefer)
          "Velocity";
        SI.Acceleration a[3] "Acceleration";
        SI.Force f[3] "force";

        Types.Quaternion Q(stateSelect=if useQuaternions then StateSelect.prefer else StateSelect.never,start = Q_start, fixed = false)
          "quaternions";
        SI.Angle phi[3](stateSelect=if not useQuaternions then (if enforceStates then
                        StateSelect.always else StateSelect.prefer) else  StateSelect.never)
          "cardan angles";
        SI.Angle phi_d[3](stateSelect=if not useQuaternions then (if enforceStates then
                        StateSelect.always else StateSelect.prefer) else  StateSelect.never)
          "cardan angles derivatives";

        SI.AngularVelocity w[3](stateSelect=if useQuaternions then (if enforceStates then
                        StateSelect.always else StateSelect.prefer) else  StateSelect.default)
          "angular velocity";
        SI.AngularAcceleration z[3] "angular acceleration";
        SI.Torque t[3] "torque";

        replaceable Interfaces.Frame_b frame_b
          "|Advanced||replaceable Interface for further extensions"
                                   annotation (extent=[100,-20; 120,20]);

      protected
        outer World3D world3D;
        inner Defaults MBG_defaults(n=3) annotation (extent=[-100,80; -80,100]);
        replaceable Interfaces.MBG2Mech MBG2Mech1
                                      annotation (extent=[80,-40; 100,40]);
        Junctions.J1 J1_1(n=3) annotation (extent=[40,-40; 60,-20]);
        Sources.Se Se1(     e0={0}, n=3)
                                    annotation (extent=[0,-40; 20,-20],rotation=180);
        Bonds.MultiBond MultiBond4
          annotation (extent=[20,-40; 40,-20],
                                             rotation=0);
        Bonds.MultiBond MultiBond7      annotation (extent=[60,-40; 80,-20]);
        Bonds.MultiBond MultiBond5
          annotation (extent=[40,-60; 60,-40],
                                             rotation=270);

        Utilities.toQuaternions toQuaternions1 if useQuaternions     annotation (extent=[20,-100;
              0,-80]);
        Utilities.quaternionRotation quaternionRotation1 if useQuaternions     annotation (extent=[-60,-60;
              -40,-40], rotation=90);
        Utilities.cardanRotation cardanRotation1(
            sequence_angles=sequence_angles) if                                   not useQuaternions
          annotation (extent=[-40,-60; -20,-40], rotation=90);
        Utilities.toCardanAngles toCardanAngles1(sequence_angles=sequence_angles) if
                                                        not useQuaternions
          annotation (extent=[0,-80; -20,-60], rotation=0);
        MultiBondLib.Interfaces.RealSignal S_Q[4]
          annotation (extent=[-84,-100; -64,-80]);
        MultiBondLib.Interfaces.RealSignal S_phi[3]
          annotation (extent=[-82,-80; -62,-60]);
        Junctions.J1 J1_2(n=3) annotation (extent=[22,20; 42,40]);
        Sources.Se Se2(n=3, e0={0}) annotation (extent=[42,60; 22,80],rotation=90);
        Sensors.Dq Dq1(
          n=3,
          stateInitialCondition=false,
          q_start=zeros(3)) annotation (extent=[-18,20; 2,40], rotation=180);
        Bonds.MultiBond MultiBond2      annotation (extent=[60,20; 80,40]);
        Bonds.MultiBond MultiBond1      annotation (extent=[22,20; 2,40]);
        Bonds.MultiBond MultiBond3      annotation (extent=[22,40; 42,60], rotation=270);
        Bonds.Utilities.MultiBondTail MultiBondTail2
                                           annotation (extent=[40,20; 62,40]);
        Sensors.Df Df1(n=3) annotation (extent=[40,-80; 60,-60],
                                                               rotation=270);
      initial equation
        if initType == MB.Types.Init.Position or initType == MB.Types.Init.
            PositionVelocity or initType == MB.Types.Init.PositionVelocityAcceleration then
          // Initialize positional variables
          x = x_start;
          if useQuaternions then
            Q[1:3] = Q_start[1:3];
          else
            phi = phi_start_rad;
          end if;
        end if;

        if initType == MB.Types.Init.PositionVelocity or initType == MB.Types.Init.
            PositionVelocityAcceleration or initType == MB.Types.Init.Velocity or
            initType == MB.Types.Init.VelocityAcceleration then
          // Initialize velocity variables
          v = v_start;
          w = w_start_rad;
        end if;

        if initType == MB.Types.Init.VelocityAcceleration or initType == MB.Types.Init.
            PositionVelocityAcceleration then
          // Initialize acceleration variables
          a = a_start;
          z = z_start_rad;
        end if;

        if initType == MB.Types.Init.SteadyState then
          v = zeros(3);
          a = zeros(3);
          w = zeros(3);
          z = zeros(3);
        end if;

      equation
        defineRoot(frame_b.P);

        x = Dq1.q;
        v = Dq1.MultiBondCon1.f;
        a = der(v);

        Q = S_Q;
        phi = S_phi;
        w = Df1.f_out;
        z = der(w);

        if useQuaternions then
          phi = zeros(3); //dummy
          phi_d = zeros(3);
        else
          Q = {0,0,0,1}; //dummy
          phi_d = der(phi);
        end if;

        f = MBG2Mech1.MultiBondConTrans.e;
        t = MBG2Mech1.MultiBondConRot.e;

        connect(MBG2Mech1.frame_b, frame_b) annotation (points=[99,0; 100,0; 100,-2;
              106,-2; 106,0; 110,0],
                      style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            gradient=2,
            fillColor=71,
            rgbfillColor={85,170,255}));
        connect(toQuaternions1.Q, quaternionRotation1.Q) annotation (points=[0,-90;
              -50,-90; -50,-60], style(
            color=3,
            rgbcolor={0,0,255},
            pattern=4));
        connect(MultiBond5.MultiBondCon1, J1_1.MultiBondCon3) annotation (points=[50,-40;
              50,-40],      style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond4.MultiBondCon2, J1_1.MultiBondCon1) annotation (points=[40,-30;
              40,-30],      style(color=71, rgbcolor={85,170,255}));
        connect(Se1.MultiBondCon1, MultiBond4.MultiBondCon1)
          annotation (points=[20,-30; 20,-30],
                                             style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond7.MultiBondCon2, MBG2Mech1.MultiBondConRot)
          annotation (points=[80,-30; 80,-30],
                                             style(color=71, rgbcolor={85,170,255}));
        connect(toCardanAngles1.phi, cardanRotation1.phi) annotation (points=[-20,-70;
              -30,-70; -30,-60], style(
            color=3,
            rgbcolor={0,0,255},
            pattern=4));
        connect(toQuaternions1.Q, S_Q)
          annotation (points=[0,-90; -74,-90], style(
            color=3,
            rgbcolor={0,0,255},
            pattern=4));
        connect(toCardanAngles1.phi, S_phi)
          annotation (points=[-20,-70; -72,-70], style(
            color=3,
            rgbcolor={0,0,255},
            pattern=4));
        connect(J1_1.MultiBondCon2, MultiBond7.MultiBondCon1) annotation (points=[60,
              -30; 60,-30], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(cardanRotation1.Rrel, MBG2Mech1.R) annotation (points=[-30,-40; -30,
              -26; -38,-26; -38,-10; 80,-10], style(
            color=3,
            rgbcolor={0,0,255},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(quaternionRotation1.Rrel, MBG2Mech1.R) annotation (points=[-50,-40;
              -50,-26; -38,-26; -38,-10; 80,-10], style(
            color=3,
            rgbcolor={0,0,255},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(J1_2.MultiBondCon2,MultiBond2. MultiBondCon1)
          annotation (points=[42,30; 60,30],
                                           style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond1.MultiBondCon1,J1_2. MultiBondCon1)
          annotation (points=[22,30; 22,30],
                                           style(color=71, rgbcolor={85,170,255}));
        connect(Dq1.MultiBondCon1,MultiBond1. MultiBondCon2) annotation (points=[2,30; 2,
              30],         style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond3.MultiBondCon1,Se2. MultiBondCon1)
          annotation (points=[32,60; 32,60], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond3.MultiBondCon2,J1_2. MultiBondCon4)
          annotation (points=[32,40; 32,40], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond2.MultiBondCon2, MBG2Mech1.MultiBondConTrans) annotation (
            points=[80,30; 80,30], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(Dq1.q, MBG2Mech1.x) annotation (points=[-18,30; -36,30; -36,10;
              80,10],
            style(
            color=3,
            rgbcolor={0,0,255},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(Df1.MultiBondCon1, MultiBond5.MultiBondCon2) annotation (points=[50,
              -60; 50,-60], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=7));
        connect(Df1.f_out, toQuaternions1.w) annotation (points=[50,-80; 50,-90; 20,
              -90], style(
            color=3,
            rgbcolor={0,0,255},
            pattern=4,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=7));
        connect(Df1.f_out, toCardanAngles1.w) annotation (points=[50,-80; 50,-90; 26,
              -90; 26,-70; 0,-70], style(
            color=3,
            rgbcolor={0,0,255},
            pattern=4,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=7));
      end FreeBodyMovement;

      model PotentialFBM "potential joint with all 6 degrees of freedom"
        import SI = Modelica.SIunits;
        import Cv = Modelica.SIunits.Conversions;

        import MB = Modelica.Mechanics.MultiBody;
        import MultiBondLib;
        annotation (Icon(
            Text(extent=[-116,124; 114,66], string="%name"),
            Ellipse(extent=[-70,70; 70,-70], style(
                color=5,
                rgbcolor={255,0,255},
                pattern=3)),
            Text(
              extent=[-90,-60; 96,-122],
              string="free",
              style(color=3, rgbcolor={0,0,255})),
            Line(points=[98,0; 60,0], style(color=5, rgbcolor={255,0,255})),
            Ellipse(extent=[-20,20; 20,-20], style(
                color=1,
                rgbcolor={255,0,0},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Ellipse(extent=[-58,56; 56,-56], style(color=5, rgbcolor={255,0,255})),
            Ellipse(extent=[-42,40; 40,-42], style(color=79, rgbcolor={170,85,255}))),
                                                              Diagram(
            Text(
              extent=[0,36; -26,54],
              style(
                color=5,
                rgbcolor={255,0,255},
                thickness=4,
                fillColor=83,
                rgbfillColor={255,170,255},
                fillPattern=1),
              string="isRoot?"),
            Text(
              extent=[-18,40; 0,22],
              style(
                color=83,
                rgbcolor={255,170,255},
                pattern=4,
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=7),
              string="Dq"),
            Line(points=[-26,32; -26,10; 76,10; 78,10], style(
                color=5,
                rgbcolor={255,0,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=7)),
            Line(points=[-26,32; -20,32], style(
                color=5,
                rgbcolor={255,0,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=7)),
            Line(points=[-30,-10; -30,-10; 72,-10; 76,-10], style(
                color=5,
                rgbcolor={255,0,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=7)),
            Text(
              extent=[40,-62; 60,-80],
              style(
                color=83,
                rgbcolor={255,170,255},
                pattern=4,
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=7),
              string="Df"),
            Line(points=[48,-78; 48,-82], style(
                color=5,
                rgbcolor={255,0,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=7)),
            Text(
              extent=[88,-80; 62,-62],
              style(
                color=5,
                rgbcolor={255,0,255},
                thickness=4,
                fillColor=83,
                rgbfillColor={255,170,255},
                fillPattern=1),
              string="isRoot?")),
          Documentation(info="<html>
This is a potential joint. It is in principle equal to the free body movement joint, but the differential
equations are only stated if necessary (i. e.: if the body movement can't be derived out of other joints).
This joint is part of every body element. There is actually no further usage of this element.
<h3>General parameter</h3>
There are no general parameters
<h3>Initialization</h3>
In general, you can specify...
<ul>
<li>...the initial position and orientation.
<li>...the initial velocity and angular velocity.
<li>...the initial acceleration and angular acceleration.
</ul>
Which of these variables do effectively appear in the inital equations can be defined by the parameter initType.
<h3>Visualization</h3>
This element isn't visualized.
<h3>Advanced settings</h3>
The activation of enforceStates enforces the joint to explicitely define integrators.
This parameter is useful to choose the state variables in a kinematic loop.
<p>
The orientation can either be expressed by the three cardan angles or by quaternions.
<ul>
<li>The usage of cardan angles leads to a faster computation but contains a singular point. It is therefore of limited applicability.
<li> The usage of quaternions lead to a robust solution, but it generates the need for dynamic state selection and leads to non-linear equations.
</ul>
<p>
Which of these two variants is used, can be specified by the parameter useQuaternions.
If cardan angles are chosen to be used, you can specify the sequence of rotation axis by the parameter sequence_angles.
</html>"));

        parameter MB.Types.Init.Temp initType=MB.Types.Init.Free
          "|Initialization| Type of initialization (defines usage of start values below)";

        parameter SI.Position x_start[3] = {0,0,0}
          "|Initialization|initial position";
        parameter SI.Velocity v_start[3] = {0,0,0}
          "|Initialization|initial velocity";
        parameter SI.Acceleration a_start[3] = {0,0,0}
          "|Initialization|initial acceleration";

        parameter Cv.NonSIunits.Angle_deg phi_start[3] = {0,0,0}
          "|Initialization|initial cardan angles in degree";
        parameter Types.AngularVelocity_deg w_start[3] = {0,0,0}
          "|Initialization|initial angular velocity in deg/s";
        parameter Types.AngularAcceleration_deg z_start[3] = {0,0,0}
          "|Initialization|initial angular acceleration in deg/s2";

        final parameter SI.Angle phi_start_rad[3] = Cv.from_deg(phi_start)
          "initial cardan angles";
        final parameter SI.AngularVelocity w_start_rad[3] = Cv.from_deg(w_start)
          "initial angular velocity";
        final parameter SI.AngularAcceleration z_start_rad[3] = Cv.from_deg(z_start)
          "initial angular acceleration";

        parameter Boolean enforceStates =  false
          "|Advanced||enforce Quaternions or cardan angles and w as states";
        parameter Boolean useQuaternions =  true
          "|Advanced||use Quaternions instead of cardan angles";
        parameter Types.RotationSequence sequence_angles = {1,2,3}
          "|Advanced||sequence of the cardan angles";
        final parameter Types.Quaternion Q_start = Utilities.AxesRotQ(phi_start_rad,sequence_angles);

        SI.Position x[3](stateSelect=if enforceStates then StateSelect.always else StateSelect.prefer)
          "Position of the frame";
        SI.Velocity v[3](stateSelect=if enforceStates then StateSelect.always else StateSelect.prefer)
          "Velocity";
        SI.Acceleration a[3] "Acceleration";
        SI.Force f[3] "force";

        Types.Quaternion Q(stateSelect=if useQuaternions then StateSelect.prefer else StateSelect.never,start = Q_start, fixed = false)
          "quaternions";
        SI.Angle phi[3](stateSelect=if not useQuaternions then (if enforceStates then
                        StateSelect.always else StateSelect.prefer) else  StateSelect.never)
          "cardan angles";
        SI.Angle phi_d[3](stateSelect=if not useQuaternions then (if enforceStates then
                        StateSelect.always else StateSelect.prefer) else  StateSelect.never)
          "cardan angles derivatives";

        SI.AngularVelocity w[3](stateSelect=if useQuaternions then (if enforceStates then
                        StateSelect.always else StateSelect.prefer) else  StateSelect.default)
          "angular velocity";
        SI.AngularAcceleration z[3] "angular acceleration";
        SI.Torque t[3] "torque";

        replaceable Interfaces.Frame_b frame_b
          "|Advanced||replaceable Interface for further extensions"
                                   annotation (extent=[100,-20; 120,20]);

      protected
        outer World3D world3D;
      protected
        inner Defaults MBG_defaults(n=3) annotation (extent=[-100,80; -80,100]);
        replaceable Interfaces.MBG2Mech MBG2Mech1
                                      annotation (extent=[80,-40; 100,40]);
        Junctions.J1 J1_1(n=3) annotation (extent=[40,-40; 60,-20]);
        Sources.Se Se1(     e0={0}, n=3)
                                    annotation (extent=[0,-40; 20,-20],rotation=180);
        Bonds.MultiBond MultiBond4
          annotation (extent=[20,-40; 40,-20],
                                             rotation=0);
        Bonds.MultiBond MultiBond7      annotation (extent=[60,-40; 80,-20]);
        Bonds.MultiBond MultiBond5
          annotation (extent=[40,-60; 60,-40],
                                             rotation=270);

      protected
        Utilities.toQuaternions toQuaternions1 if useQuaternions     annotation (extent=[20,-100;
              0,-80]);
        Utilities.quaternionRotation quaternionRotation1 if useQuaternions     annotation (extent=[-60,-60;
              -40,-40], rotation=90);
        Utilities.cardanRotation cardanRotation1(
            sequence_angles=sequence_angles) if                                   not useQuaternions
          annotation (extent=[-40,-60; -20,-40], rotation=90);
        Utilities.toCardanAngles toCardanAngles1(sequence_angles=sequence_angles) if
                                                        not useQuaternions
          annotation (extent=[0,-80; -20,-60], rotation=0);
        MultiBondLib.Interfaces.RealSignal S_Q[4]
          annotation (extent=[-84,-100; -64,-80]);
        MultiBondLib.Interfaces.RealSignal S_phi[ 3]
          annotation (extent=[-82,-80; -62,-60]);

      protected
        MultiBondLib.Junctions.J1 J1_2(
                          n=3) annotation (extent=[22,20; 42,40]);
        MultiBondLib.Sources.Se Se2(
                       n=3, e0={0}) annotation (extent=[42,60; 22,80],rotation=90);
        MultiBondLib.Bonds.MultiBond MultiBond2
                                        annotation (extent=[60,20; 80,40]);
        MultiBondLib.Bonds.MultiBond MultiBond1
                                        annotation (extent=[22,20; 2,40]);
        MultiBondLib.Bonds.MultiBond MultiBond3
                                        annotation (extent=[22,40; 42,60], rotation=270);
        MultiBondLib.Bonds.Utilities.MultiBondTail MultiBondTail2
                                           annotation (extent=[40,20; 62,40]);
        MultiBondLib.Interfaces.RealSignal Rrel[3,3]
          annotation (extent=[-80,-20; -60,0]);
        MultiBondLib.Interfaces.RealSignal S_w[3]
          annotation (extent=[38,-100; 58,-80]);
      initial equation
        if initType == MB.Types.Init.Position or initType == MB.Types.Init.
            PositionVelocity or initType == MB.Types.Init.PositionVelocityAcceleration then
          // Initialize positional variables
          x = x_start;
          if useQuaternions then
            Q[1:3] = Q_start[1:3];
          else
            phi = phi_start_rad;
          end if;
        end if;

        if initType == MB.Types.Init.PositionVelocity or initType == MB.Types.Init.
            PositionVelocityAcceleration or initType == MB.Types.Init.Velocity or
            initType == MB.Types.Init.VelocityAcceleration then
          // Initialize velocity variables
          v = v_start;
          w = w_start_rad;
        end if;

        if initType == MB.Types.Init.VelocityAcceleration or initType == MB.Types.Init.
            PositionVelocityAcceleration then
          // Initialize acceleration variables
          a = a_start;
          z = z_start_rad;
        end if;

        if initType == MB.Types.Init.SteadyState then
          v = zeros(3);
          a = zeros(3);
          w = zeros(3);
          z = zeros(3);
        end if;

      equation
        if enforceStates then
          defineRoot(frame_b.P);
        else
          definePotentialRoot(frame_b.P);
        end if;

        x = MBG2Mech1.x;
        v = MBG2Mech1.MultiBondConTrans.f;
        a = der(v);

        Q = S_Q;
        phi = S_phi;
        w = MBG2Mech1.MultiBondConRot.f;
        z = der(w);

        f = MBG2Mech1.MultiBondConTrans.e;
        t = MBG2Mech1.MultiBondConRot.e;
        MultiBond1.MultiBondCon2.e = zeros(3);
        MultiBond5.MultiBondCon2.e = zeros(3);

        //replace the differential equations with dummy equations in the root case
        if not isRoot(frame_b.P) then
          phi = zeros(3); //dummy or fixation
          phi_d = zeros(3);
          if useQuaternions then
            Q[1:3] = Q_start[1:3]; //fixation
          else
            Q = {0,0,0,1}; //dummy
          end if;

        else
          der(x) = MultiBond1.MultiBondCon2.f;
          S_w = MultiBond5.MultiBondCon2.f;

          if useQuaternions then
            phi = zeros(3); //dummy
            phi_d = zeros(3);
            Rrel = MBG2Mech1.R;
           else
            Rrel = MBG2Mech1.R;
             Q = {0,0,0,1}; //dummy
            phi_d = der(phi);
          end if;

        end if;

        connect(MBG2Mech1.frame_b, frame_b) annotation (points=[99,0; 100,0; 100,-2;
              106,-2; 106,0; 110,0],
                      style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            gradient=2,
            fillColor=71,
            rgbfillColor={85,170,255}));
        connect(toQuaternions1.Q, quaternionRotation1.Q) annotation (points=[0,-90;
              -50,-90; -50,-60], style(
            color=3,
            rgbcolor={0,0,255},
            pattern=4));
        connect(MultiBond5.MultiBondCon1, J1_1.MultiBondCon3) annotation (points=[50,-40;
              50,-40],      style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond4.MultiBondCon2, J1_1.MultiBondCon1) annotation (points=[40,-30;
              40,-30],      style(color=71, rgbcolor={85,170,255}));
        connect(Se1.MultiBondCon1, MultiBond4.MultiBondCon1)
          annotation (points=[20,-30; 20,-30],
                                             style(color=71, rgbcolor={85,170,255}));
        connect(toCardanAngles1.phi, cardanRotation1.phi) annotation (points=[-20,-70;
              -30,-70; -30,-60], style(
            color=3,
            rgbcolor={0,0,255},
            pattern=4));
        connect(toQuaternions1.Q, S_Q)
          annotation (points=[0,-90; -74,-90], style(
            color=3,
            rgbcolor={0,0,255},
            pattern=4));
        connect(toCardanAngles1.phi, S_phi)
          annotation (points=[-20,-70; -72,-70], style(
            color=3,
            rgbcolor={0,0,255},
            pattern=4));
        connect(J1_1.MultiBondCon2, MultiBond7.MultiBondCon1) annotation (points=[60,-30;
              60,-30],      style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(J1_2.MultiBondCon2,MultiBond2. MultiBondCon1)
          annotation (points=[42,30; 60,30],
                                           style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond1.MultiBondCon1,J1_2. MultiBondCon1)
          annotation (points=[22,30; 22,30],
                                           style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond3.MultiBondCon1,Se2. MultiBondCon1)
          annotation (points=[32,60; 32,60], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond3.MultiBondCon2,J1_2. MultiBondCon4)
          annotation (points=[32,40; 32,40], style(color=71, rgbcolor={85,170,255}));
        connect(quaternionRotation1.Rrel, Rrel) annotation (points=[-50,-40; -50,-10;
              -70,-10],
                    style(
            color=3,
            rgbcolor={0,0,255},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=7));
        connect(cardanRotation1.Rrel, Rrel) annotation (points=[-30,-40; -30,-10; -70,
              -10], style(
            color=3,
            rgbcolor={0,0,255},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=7));
        connect(MultiBond7.MultiBondCon2, MBG2Mech1.MultiBondConRot) annotation (
            points=[80,-30; 80,-30], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=7));
        connect(MultiBond2.MultiBondCon2, MBG2Mech1.MultiBondConTrans) annotation (
            points=[80,30; 80,30], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=7));
        connect(toQuaternions1.w, S_w) annotation (points=[20,-90; 48,-90], style(
            color=3,
            rgbcolor={0,0,255},
            pattern=4,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=7));
        connect(toCardanAngles1.w, S_w) annotation (points=[0,-70; 28,-70; 28,-90; 48,
              -90], style(
            color=3,
            rgbcolor={0,0,255},
            pattern=4,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=7));
      end PotentialFBM;

      model CloseLoop "element to close kinematik loops manualy"
        replaceable Interfaces.Frame_a frame_a
          "|Advanced||replaceable Interface for further extensions"
                                   annotation (extent=[-120,-20; -100,20]);
        replaceable Interfaces.Frame_b frame_b
          "|Advanced||replaceable Interface for further extensions"
                                   annotation (extent=[100,-20; 120,20]);
        annotation (Icon(
            Rectangle(extent=[-100,100; 100,-100], style(
                color=5,
                rgbcolor={255,0,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Ellipse(extent=[-72,74; 70,-70], style(
                color=5,
                rgbcolor={255,0,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Rectangle(extent=[-8,0; 74,-90], style(
                pattern=0,
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Text(
              extent=[-56,46; 54,-34],
              string="%name",
              style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Polygon(points=[70,-16; 64,4; 78,4; 70,-16],
                                                       style(
                color=5,
                rgbcolor={255,0,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1))), Diagram,
          Documentation(info="<html>
This is the CloseLoop element.
<p>
With this element you can cut a kinematic loop manually. Just insert the element into the loop
at the point where you'd like to cut it.
<p>
This element connects its two connectors in a non-redundant way. It must not be used outside a kinematik loop.
</html>"));
      equation
        frame_a.P.x = frame_b.P.x;

        cross(frame_a.P.R[1, :], frame_a.P.R[2, :])*frame_b.P.R[2, :] = 0;
        cross(frame_a.P.R[1, :], frame_a.P.R[2, :])*frame_b.P.R[1, :] = 0;
        frame_a.P.R[2, :]*frame_b.P.R[1, :] = 0;

        frame_a.f = frame_b.f;
        frame_a.t = frame_b.t;

      end CloseLoop;

      package CutJoints "elements to handle kinamitk loops"
        extends Modelica.Icons.Library;
        model PlanarRevolute "revolute cut joint for planar loops"
          import SI = Modelica.SIunits;
          import MB = Modelica.Mechanics.MultiBody;
          annotation (Icon(
              Rectangle(extent=[-100,-60; -20,60], style(
                  color=8,
                  rgbcolor={192,192,192},
                  gradient=2,
                  fillColor=83,
                  rgbfillColor={255,170,255})),
              Rectangle(extent=[20,-60; 100,60], style(
                  color=8,
                  rgbcolor={192,192,192},
                  gradient=2,
                  fillColor=83,
                  rgbfillColor={255,170,255},
                  fillPattern=1)),
              Rectangle(extent=[-20,10; 20,-10], style(
                  color=0,
                  rgbcolor={0,0,0},
                  gradient=0,
                  fillColor=83,
                  rgbfillColor={255,170,255},
                  fillPattern=1)),
              Text(
                extent=[-99,12; -63,-13],
                style(color=10),
                string="a"),
              Text(
                extent=[63,11; 99,-14],
                style(color=10),
                string="b"),
              Text(extent=[-116,-70; 114,-128],
                                              string="%name"),
                 Text(
                extent=[-148,86; 141,125],
                style(color=0),
                string="n=%n"),
              Line(points=[8,60; -12,20; 12,-20; -10,-60], style(
                  color=1,
                  rgbcolor={255,0,0},
                  thickness=2))),                               Diagram(
              Line(points=[8,60; -12,20; 12,-20; -10,-60], style(
                  color=1,
                  rgbcolor={255,0,0},
                  thickness=2))),
            Documentation(info="<html>
This special model of a revolute joint is designed to cut planar loops.
<p>
If a planar loop is cut by a standard revolute joint a singular system of equations results.
<p>
<p>
<img src=\"../Images/Revolute.png\">
</p>
<h3>General parameter</h3>
The rotation axis of the revolute joint can be defined by the parameter n. n can be of arbitrary length, but it must not be zero.
<p>
The parameter phi_offset defines an offset value for the revolute angle phi.
<p>
The parameter animation toggles the visualization of the element.
<h3>Visualization</h3>
This element is visualized by cylinder along the rotation axis. The settings for length, diameter and color can be specified by the animation parameters.
</html>"));

          parameter Boolean animation = true "animate revolute as cylinder";
          parameter SI.Position n[3] = {0,0,1} "direction of revolute axis"    annotation(Evaluate=true);
          final parameter SI.Position eN[3] = n/sqrt(n*n) annotation(Evaluate = true);
          final parameter Real notN[3] = if abs(eN[1]) > 0.1 then {0,1,0} else (if abs(eN[2])
               > 0.1 then {0,0,1} else {1,0,0})
            "Arbitrary vector that is not aligned with eN"   annotation(Evaluate=true);
          final parameter Real vec_a[3] = cross(eN,notN) "vector in loop plane"
                                      annotation(Evaluate=true);
          final parameter Real eA[3] = {1,0,0}
            "normalized vector in loop plane"  annotation(Evaluate=true);
          final parameter Real eB[3] = cross(eA,eN)
            "normalized vector in loop plane orthogonal to eA"
                                               annotation(Evaluate=true);

          parameter SI.Distance cylinderLength=world3D.defaultJointLength
            "|Animation|if animation = true| Length of cylinder representing the joint axis";
          parameter SI.Distance cylinderDiameter=world3D.defaultJointWidth
            "|Animation|if animation = true| Diameter of cylinder representing the joint axis";
          parameter Modelica.Mechanics.MultiBody.Types.Color cylinderColor=world3D.defaultJointColor
            "|Animation|if animation = true| Color of cylinder representing the joint axis";

          Real eA0[3] "eA resolved in inertial frame";
          Real eB0[3] "eB resolved in inertial frame";

            SI.Torque tau=0 "Revolute torque";

          replaceable Interfaces.Frame_a frame_a
                                     annotation (extent=[-120,-20; -100,20]);
          replaceable Interfaces.Frame_b frame_b
                                     annotation (extent=[100,-20; 120,20]);

        protected
          outer World3D world3D;
        protected
          inner Defaults MBG_defaults(n=3) annotation (extent=[-100,80; -80,100]);

          parameter Integer ndim=if world3D.enableAnimation and animation then 1 else 0;
          MB.Visualizers.Advanced.Shape cylinder[ndim](
            each shapeType="cylinder",
            each color=cylinderColor,
            each length=cylinderLength,
            each width=cylinderDiameter,
            each height=cylinderDiameter,
            each lengthDirection=eN,
            each widthDirection={0,1,0},
            each r_shape=-eN*cylinderLength/2,
            each r=frame_a.P.x,
            each R=MB.Frames.Orientation(T=frame_a.P.R,w=zeros(3)));

        equation
          eA0 = transpose(frame_a.P.R)*eA;
          eB0 = transpose(frame_a.P.R)*eB;

          (frame_a.P.x - frame_b.P.x)*eA0  = 0;
          (frame_a.P.x - frame_b.P.x)*eB0  = 0;
          frame_a.f*transpose(frame_a.P.R)*eN = 0;

          frame_a.t = eN*tau;

          frame_a.f + frame_b.f = zeros(3);
          frame_a.t + frame_b.t = zeros(3);

        end PlanarRevolute;
        annotation (preferedView="info", Documentation(info="<html>
This subpackage contains so called cut joints. These are elements, that close kinematic loops.
</html>"));
      end CutJoints;
    end Joints;

    package Parts "parts"
      extends Modelica.Icons.Library;
      model Body "complete body model"
        annotation (Icon(
            Text(
              extent=[133,-101; -127,-51],
              style(color=0),
              string="m=%m"),
            Rectangle(extent=[-100,30; -3,-31], style(
                color=8,
                rgbcolor={192,192,192},
                gradient=2,
                fillColor=71,
                rgbfillColor={85,170,255})),
            Ellipse(extent=[-60,60; 60,-60], style(
                gradient=3,
                fillColor=71,
                rgbfillColor={85,170,255})),
            Text(extent=[-112,110; 118,52], string="%name")), Diagram(
            Rectangle(extent=[-56,10; -36,-10],style(color=3, rgbcolor={0,0,255})),
            Text(
              extent=[-56,4; -36,-4],
              style(color=3, rgbcolor={0,0,255}),
              string="world3D"),
            Line(points=[-76,10; -60,10; -60,0; -56,0; -56,2],    style(color=3,
                  rgbcolor={0,0,255})),
            Line(points=[-36,0; -30,0],   style(color=3, rgbcolor={0,0,255}))),
          Documentation(info="<html>
This is the model of a body representing a point with given mass and inertia tensor.
<p>
If the body model is not connected to any joint, its movement is defined to be free.
Therefore this model includes a potential free-body movement joint and in consequences shares certain joint characterisitcs.
<p>
<img src=\"../Images/Body.png\">
</p>
<h3>General parameter</h3>
The mass can be specified by the parameter m.
<p>
The inertia tensor is a symmetric 3x3 matrix and can be specified by the parameters I11, I12, ...
<p>
A non-zero value for the parameter GPIndex inserts the body into the gravity pool.<br>
Make sure the integer value is unique and does not exceed the size of the gravity pool.
<p>
The parameter animation toggles the visualization
<h3>Initialization</h3>
In general, you can specify...
<ul>
<li>...the initial position and orientation.
<li>...the initial velocity and angular velocity.
<li>...the initial acceleration and angular acceleration.
</ul>
Which of these variables do effectively appear in the inital equations can be defined by the parameter initType.
<h3>Visualization</h3>
The element is visualized by a sphere. Diameter and color of the sphere can be specified by the animation parameters.
<h3>Advanced settings</h3>
The activation of enforceStates enforces the joint to explicitely define integrators.
This parameter is useful to choose the state variables in a kinematic loop.
<p>
The orientation can either be expressed by the three cardan angles or by quaternions.
<ul>
<li>The usage of cardan angles leads to a faster computation but contains a singular point. It is therefore of limited applicability.
<li> The usage of quaternions lead to a robust solution, but it generates the need for dynamic state selection and leads to non-linear equations.
</ul>
<p>
Which of these two variants is used, can be specified by the parameter useQuaternions.
If cardan angles are chosen to be used, you can specify the sequence of rotation axis by the parameter sequence_angles.
</html>"));
        import SI = Modelica.SIunits;
        import Cv = Modelica.SIunits.Conversions;
        import MB = Modelica.Mechanics.MultiBody;
        parameter Boolean animation=true
          "= true, if animation shall be enabled";

        parameter SI.Mass m = 1 "mass of body";

        parameter SI.Inertia I_11=0.001
          "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (1,1) element of inertia tensor"
                                                                                                              annotation(Evaluate=true);
        parameter SI.Inertia I_22=0.001
          "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (2,2) element of inertia tensor"
                                                                                                              annotation(Evaluate=true);
        parameter SI.Inertia I_33=0.001
          "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (3,3) element of inertia tensor"
                                                                                                              annotation(Evaluate=true);
        parameter SI.Inertia I_21=0
          "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (2,1) element of inertia tensor"
                                                                                                              annotation(Evaluate=true);
        parameter SI.Inertia I_31=0
          "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (3,1) element of inertia tensor"
                                                                                                              annotation(Evaluate=true);
        parameter SI.Inertia I_32=0
          "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (3,2) element of inertia tensor"
                                                                                                              annotation(Evaluate=true);
        final parameter SI.Inertia Inert[3, 3]=[I_11, I_21, I_31; I_21, I_22, I_32;
            I_31, I_32, I_33] "inertia tensor"
                                              annotation(Evaluate=true);

        parameter MB.Types.Init.Temp initType=MB.Types.Init.Free
          "|Initialization|| Type of initialization (defines usage of start values below)";

        parameter SI.Position x_start[3] = {0,0,0}
          "|Initialization||initial position";
        parameter SI.Velocity v_start[3] = {0,0,0}
          "|Initialization||initial velocity";
        parameter SI.Acceleration a_start[3] = {0,0,0}
          "|Initialization||initial acceleration";

        parameter Cv.NonSIunits.Angle_deg phi_start[3] = {0,0,0}
          "|Initialization||initial cardan angles in degree";
        parameter Types.AngularVelocity_deg w_start[3] = {0,0,0}
          "|Initialization||initial angular velocity in deg/s";
        parameter Types.AngularAcceleration_deg z_start[3] = {0,0,0}
          "|Initialization||initial angular acceleration in deg/s2";

        parameter Boolean enforceStates =  false
          "|Advanced||enforce Quaternions or cardan angles and w as states";
        parameter Boolean useQuaternions =  true
          "|Advanced||use Quaternions instead of cardan angles";
        parameter Types.RotationSequence sequence_angles = {1,2,3}
          "|Advanced||sequence of the cardan angles";

        parameter SI.Diameter sphereDiameter=world3D.defaultBodyDiameter
          "|Animation|if animation = true| Diameter of sphere"
                               annotation (Dialog(
            tab="Animation",
            group="if animation = true",
            enable=animation));
        parameter MB.Types.Color sphereColor=world3D.defaultBodyColor
          "|Animation|if animation = true| Color of sphere"
                            annotation (Dialog(
            tab="Animation",
            group="if animation = true",
            enable=animation));

        parameter Integer GPIndex = 0
          "Index of element in gravity pool (is zero if element is not in gravity pool)";

        replaceable Interfaces.Frame_a frame_a
          "|Advanced||replaceable Interface for further extensions"
                                   annotation (extent=[-120,-20; -100,20]);

        SI.Force gF[3];

      protected
        outer World3D world3D;
      protected
        inner Defaults MBG_defaults(n=3) annotation (extent=[-100,80; -80,100]);
        replaceable Interfaces.Mech2MBG Mech2MBG1
                                      annotation (extent=[-100,-40; -80,40]);
        Junctions.J1 J1_1(n=3) annotation (extent=[0,20; 20,40]);
        Passive.I I1(n=3, I={m})     annotation (extent=[40,20; 60,40],   rotation=0);
        Junctions.J1 J1_2(n=3) annotation (extent=[-60,-40; -40,-20]);
        Passive.IF IF1(n=3, I=Inert)
                                 annotation (extent=[-60,-80; -40,-60],
                                                                     rotation=270);
        AdditionalMBG.MGY MGY1(I=Inert)
                                    annotation (extent=[-20,-40; 0,-20]);
        Bonds.MultiBond MultiBond7      annotation (extent=[-20,20; 0,40]);
        Bonds.MultiBond MultiBond6
          annotation (extent=[-60,-60; -40,-40],
                                               rotation=270);
        Bonds.MultiBond MultiBond5      annotation (extent=[-80,-40; -60,-20]);
        Bonds.MultiBond MultiBond1      annotation (extent=[0,0; 20,20],   rotation=
              90);
        Bonds.MultiBond MultiBond8      annotation (extent=[-40,-40; -20,-20]);
        Bonds.MultiBond MultiBond9      annotation (extent=[20,20; 40,40]);
        Sources.mSe mSe1(n=3) annotation (extent=[-8,-10; -28,10]);
        Bonds.Utilities.MultiBondTail MultiBondTail1
          annotation (extent=[-8,-10; 8,10], rotation=0);
        Bonds.Utilities.MultiBondTail MultiBondTail2
          annotation (extent=[-80,20; -18,40],
                                             rotation=0);

        parameter Integer ndim=if world3D.enableAnimation and animation then 1 else 0;
        MB.Visualizers.Advanced.Shape sphere[ndim](
          each shapeType="sphere",
          each color=sphereColor,
          each length=sphereDiameter,
          each width=sphereDiameter,
          each height=sphereDiameter,
          each lengthDirection={1,0,0},
          each widthDirection={0,1,0},
          each r_shape=-{1,0,0}*sphereDiameter/2,
          each r=Mech2MBG1.x,
          each R=MB.Frames.Orientation(T=Mech2MBG1.R,w=zeros(3)));

      public
        replaceable Joints.PotentialFBM PotentialFBM1(
          initType=initType,
          x_start=x_start,
          v_start=v_start,
          a_start=a_start,
          phi_start=phi_start,
          w_start=w_start,
          z_start=z_start,
          enforceStates=enforceStates,
          useQuaternions=useQuaternions,
          sequence_angles=sequence_angles)
          "|Advanced||replaceable Interface for further extensions"
                                           annotation (extent=[-60,40; -80,60]);
      equation
         if GPIndex > 0 then
           world3D.gravityPool.pos[GPIndex,:] = frame_a.P.x;
           world3D.gravityPool.mass[GPIndex] = m;
         end if;
         gF = world3D.gravityPool.gravityForce(GPIndex);
         mSe1.s = m*world3D.gravityAcceleration(Mech2MBG1.x)+gF;

        connect(Mech2MBG1.frame_a, frame_a) annotation (points=[-99,0; -110,0],
                       style(
            color=0,
            rgbcolor={0,0,0},
            pattern=0,
            thickness=2,
            fillColor=9,
            rgbfillColor={175,175,175},
            fillPattern=1));
        connect(J1_2.MultiBondCon1, MultiBond5.MultiBondCon2) annotation (points=[-60,-30;
              -60,-30],    style(
            color=71,
            rgbcolor={85,170,255},
            pattern=0,
            fillColor=9,
            rgbfillColor={175,175,175},
            fillPattern=1));
        connect(MultiBond6.MultiBondCon1, J1_2.MultiBondCon3) annotation (points=[-50,-40;
              -50,-40],     style(
            color=71,
            rgbcolor={85,170,255},
            pattern=0,
            fillColor=9,
            rgbfillColor={175,175,175},
            fillPattern=1));
        connect(IF1.MultiBondCon1, MultiBond6.MultiBondCon2) annotation (points=[-50,-60;
              -50,-60],     style(
            color=71,
            rgbcolor={85,170,255},
            pattern=0,
            fillColor=9,
            rgbfillColor={175,175,175},
            fillPattern=1));
        connect(MultiBond8.MultiBondCon1, J1_2.MultiBondCon2) annotation (points=[-40,-30;
              -40,-30],     style(
            color=71,
            rgbcolor={85,170,255},
            pattern=0,
            fillColor=9,
            rgbfillColor={175,175,175},
            fillPattern=1));
        connect(MultiBond8.MultiBondCon2, MGY1.MultiBondCon1) annotation (points=[-20,-30;
              -20,-30],     style(
            color=71,
            rgbcolor={85,170,255},
            pattern=0,
            fillColor=9,
            rgbfillColor={175,175,175},
            fillPattern=1));
        connect(MultiBond9.MultiBondCon1, J1_1.MultiBondCon2) annotation (points=[20,30;
              20,30],     style(
            color=71,
            rgbcolor={85,170,255},
            pattern=0,
            fillColor=9,
            rgbfillColor={175,175,175},
            fillPattern=1));
        connect(MultiBond9.MultiBondCon2, I1.MultiBondCon1) annotation (points=[40,30;
              40,30], style(
            color=71,
            rgbcolor={85,170,255},
            pattern=0,
            fillColor=9,
            rgbfillColor={175,175,175},
            fillPattern=1));
        connect(MultiBond7.MultiBondCon2, J1_1.MultiBondCon1)
          annotation (points=[0,30; 0,30],   style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond1.MultiBondCon2, J1_1.MultiBondCon3)
          annotation (points=[10,20; 10,20], style(color=71, rgbcolor={85,170,255}));
        connect(mSe1.MultiBondCon1, MultiBond1.MultiBondCon1)
          annotation (points=[-8,0; 10,0], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond7.MultiBondCon1, Mech2MBG1.MultiBondConTrans) annotation (points=[-20,30;
              -80,30],                       style(color=71, rgbcolor={85,170,255}));
        connect(Mech2MBG1.MultiBondConRot, MultiBond5.MultiBondCon1) annotation (
            points=[-79.8,-30; -80,-30], style(color=71, rgbcolor={85,170,255}));
        connect(PotentialFBM1.frame_b, frame_a) annotation (points=[-81,50; -100,50;
              -100,0; -110,0], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
      end Body;

      model SimpleBody "simple body element "
        annotation (Icon(
            Text(
              extent=[133,-101; -127,-51],
              style(color=0),
              string="m=%m"),
            Rectangle(extent=[-100,30; -3,-31], style(
                color=8,
                rgbcolor={192,192,192},
                gradient=2,
                fillColor=71,
                rgbfillColor={85,170,255})),
            Ellipse(extent=[-60,60; 60,-60], style(
                gradient=3,
                fillColor=71,
                rgbfillColor={85,170,255})),
            Text(extent=[-112,110; 118,52], string="%name")), Diagram(
            Rectangle(extent=[-56,10; -36,-10],style(color=3, rgbcolor={0,0,255})),
            Text(
              extent=[-56,4; -36,-4],
              style(color=3, rgbcolor={0,0,255}),
              string="world3D"),
            Line(points=[-76,10; -60,10; -60,0; -56,0; -56,2],    style(color=3,
                  rgbcolor={0,0,255})),
            Line(points=[-36,0; -30,0],   style(color=3, rgbcolor={0,0,255}))),
          Documentation(info="<html>
This is the model of a body representing a point with given mass and inertia tensor.
<p>
Different from the standard body model, this model does not contain a potential joint and therefore
needs to be connected to a joint or fixation element.
<p>
<img src=\"../Images/Body.png\">
</p>
<h3>General parameter</h3>
The mass can be specified by the parameter m.
<p>
The inertia tensor is a symmetric 3x3 matrix and can be specified by the parameters I11, I12, ...
<p>
A non-zero value for the parameter GPIndex inserts the body into the gravity pool.<br>
Make sure the integer value is unique and does not exceed the size of the gravity pool.
<p>
The parameter animation toggles the visualization
<h3>Visualization</h3>
The element is visualized by a sphere. Diameter and color of the sphere can be specified by the animation parameters.
</html>"));
        import SI = Modelica.SIunits;
        import MB = Modelica.Mechanics.MultiBody;
        parameter Boolean animation=true
          "= true, if animation shall be enabled";

        parameter SI.Mass m = 1 "mass of body";

        parameter SI.Inertia I_11=0.001
          "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (1,1) element of inertia tensor"
                                                                                                              annotation(Evaluate=true);
        parameter SI.Inertia I_22=0.001
          "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (2,2) element of inertia tensor"
                                                                                                              annotation(Evaluate=true);
        parameter SI.Inertia I_33=0.001
          "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (3,3) element of inertia tensor"
                                                                                                              annotation(Evaluate=true);
        parameter SI.Inertia I_21=0
          "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (2,1) element of inertia tensor"
                                                                                                              annotation(Evaluate=true);
        parameter SI.Inertia I_31=0
          "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (3,1) element of inertia tensor"
                                                                                                              annotation(Evaluate=true);
        parameter SI.Inertia I_32=0
          "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (3,2) element of inertia tensor"
                                                                                                              annotation(Evaluate=true);
        final parameter SI.Inertia Inert[3, 3]=[I_11, I_21, I_31; I_21, I_22, I_32;
            I_31, I_32, I_33] "inertia tensor"
                                              annotation(Evaluate=true);

        parameter SI.Diameter sphereDiameter=world3D.defaultBodyDiameter
          "|Animation|if animation = true| Diameter of sphere"
                               annotation (Dialog(
            tab="Animation",
            group="if animation = true",
            enable=animation));
        parameter MB.Types.Color sphereColor=world3D.defaultBodyColor
          "|Animation|if animation = true| Color of sphere"
                            annotation (Dialog(
            tab="Animation",
            group="if animation = true",
            enable=animation));

        parameter Integer GPIndex = 0
          "Index of element in gravity pool (is zero if element is not in gravity pool)";

        replaceable Interfaces.Frame_a frame_a
          "|Advanced||replaceable Interface for further extensions"
                                   annotation (extent=[-120,-20; -100,20]);

        SI.Force gF[3];

      protected
        outer World3D world3D;
      protected
        inner Defaults MBG_defaults(n=3) annotation (extent=[-100,80; -80,100]);
        replaceable Interfaces.Mech2MBG Mech2MBG1
                                      annotation (extent=[-100,-40; -80,40]);
        Junctions.J1 J1_1(n=3) annotation (extent=[0,20; 20,40]);
        Passive.I I1(n=3, I={m})     annotation (extent=[40,20; 60,40],   rotation=0);
        Junctions.J1 J1_2(n=3) annotation (extent=[-60,-40; -40,-20]);
        Passive.IF IF1(n=3, I=Inert)
                                 annotation (extent=[-60,-80; -40,-60],
                                                                     rotation=270);
        AdditionalMBG.MGY MGY1(I=Inert)
                                    annotation (extent=[-20,-40; 0,-20]);
        Bonds.MultiBond MultiBond7      annotation (extent=[-20,20; 0,40]);
        Bonds.MultiBond MultiBond6
          annotation (extent=[-60,-60; -40,-40],
                                               rotation=270);
        Bonds.MultiBond MultiBond5      annotation (extent=[-80,-40; -60,-20]);
        Bonds.MultiBond MultiBond1      annotation (extent=[0,0; 20,20],   rotation=
              90);
        Bonds.MultiBond MultiBond8      annotation (extent=[-40,-40; -20,-20]);
        Bonds.MultiBond MultiBond9      annotation (extent=[20,20; 40,40]);
        Sources.mSe mSe1(n=3) annotation (extent=[-8,-10; -28,10]);
        Bonds.Utilities.MultiBondTail MultiBondTail1
          annotation (extent=[-8,-10; 8,10], rotation=0);
        Bonds.Utilities.MultiBondTail MultiBondTail2
          annotation (extent=[-80,20; -18,40],
                                             rotation=0);

        parameter Integer ndim=if world3D.enableAnimation and animation then 1 else 0;
        MB.Visualizers.Advanced.Shape sphere[ndim](
          each shapeType="sphere",
          each color=sphereColor,
          each length=sphereDiameter,
          each width=sphereDiameter,
          each height=sphereDiameter,
          each lengthDirection={1,0,0},
          each widthDirection={0,1,0},
          each r_shape=-{1,0,0}*sphereDiameter/2,
          each r=Mech2MBG1.x,
          each R=MB.Frames.Orientation(T=Mech2MBG1.R,w=zeros(3)));

      equation
         if GPIndex > 0 then
           world3D.gravityPool.pos[GPIndex,:] = frame_a.P.x;
           world3D.gravityPool.mass[GPIndex] = m;
         end if;
         gF = world3D.gravityPool.gravityForce(GPIndex);

         mSe1.s = m*world3D.gravityAcceleration(Mech2MBG1.x)+gF;

        connect(Mech2MBG1.frame_a, frame_a) annotation (points=[-99,0; -110,0],
                       style(
            color=0,
            rgbcolor={0,0,0},
            pattern=0,
            thickness=2,
            fillColor=9,
            rgbfillColor={175,175,175},
            fillPattern=1));
        connect(J1_2.MultiBondCon1, MultiBond5.MultiBondCon2) annotation (points=[-60,-30;
              -60,-30],    style(
            color=71,
            rgbcolor={85,170,255},
            pattern=0,
            fillColor=9,
            rgbfillColor={175,175,175},
            fillPattern=1));
        connect(MultiBond6.MultiBondCon1, J1_2.MultiBondCon3) annotation (points=[-50,-40;
              -50,-40],     style(
            color=71,
            rgbcolor={85,170,255},
            pattern=0,
            fillColor=9,
            rgbfillColor={175,175,175},
            fillPattern=1));
        connect(IF1.MultiBondCon1, MultiBond6.MultiBondCon2) annotation (points=[-50,-60;
              -50,-60],     style(
            color=71,
            rgbcolor={85,170,255},
            pattern=0,
            fillColor=9,
            rgbfillColor={175,175,175},
            fillPattern=1));
        connect(MultiBond8.MultiBondCon1, J1_2.MultiBondCon2) annotation (points=[-40,-30;
              -40,-30],     style(
            color=71,
            rgbcolor={85,170,255},
            pattern=0,
            fillColor=9,
            rgbfillColor={175,175,175},
            fillPattern=1));
        connect(MultiBond8.MultiBondCon2, MGY1.MultiBondCon1) annotation (points=[-20,-30;
              -20,-30],     style(
            color=71,
            rgbcolor={85,170,255},
            pattern=0,
            fillColor=9,
            rgbfillColor={175,175,175},
            fillPattern=1));
        connect(MultiBond9.MultiBondCon1, J1_1.MultiBondCon2) annotation (points=[20,30;
              20,30],     style(
            color=71,
            rgbcolor={85,170,255},
            pattern=0,
            fillColor=9,
            rgbfillColor={175,175,175},
            fillPattern=1));
        connect(MultiBond9.MultiBondCon2, I1.MultiBondCon1) annotation (points=[40,30;
              40,30], style(
            color=71,
            rgbcolor={85,170,255},
            pattern=0,
            fillColor=9,
            rgbfillColor={175,175,175},
            fillPattern=1));
        connect(MultiBond7.MultiBondCon2, J1_1.MultiBondCon1)
          annotation (points=[0,30; 0,30],   style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond1.MultiBondCon2, J1_1.MultiBondCon3)
          annotation (points=[10,20; 10,20], style(color=71, rgbcolor={85,170,255}));
        connect(mSe1.MultiBondCon1, MultiBond1.MultiBondCon1)
          annotation (points=[-8,0; 10,0], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond7.MultiBondCon1, Mech2MBG1.MultiBondConTrans) annotation (points=[-20,30;
              -80,30],                       style(color=71, rgbcolor={85,170,255}));
        connect(Mech2MBG1.MultiBondConRot, MultiBond5.MultiBondCon1) annotation (
            points=[-79.8,-30; -80,-30], style(color=71, rgbcolor={85,170,255}));
      end SimpleBody;

      model Fixed "wall element"
        annotation (Diagram, Icon(
            Line(points=[0,100; 0,-100],   style(color=0)),
            Line(points=[0,-80; -100,-20],   style(color=0)),
            Line(points=[0,-40; -100,20],   style(color=0)),
            Line(points=[0,0; -100,60],   style(color=0)),
            Line(points=[0,40; -100,100],   style(color=0)),
            Line(points=[0,0; 100,0],   style(color=0)),
            Text(extent=[-116,146; 114,88], string="%name"),
            Text(
              extent=[112,-130; -120,-90],
              style(color=0),
              string="r=%r"),
            Ellipse(extent=[-20,20; 20,-20], style(
                color=1,
                rgbcolor={255,0,0},
                fillColor=1,
                rgbfillColor={255,0,0},
                fillPattern=1))),
          Documentation(info="<html>
This is the model of a fixation point. It models a full translational and rotational fixation.
<h3>General parameter</h3>
The position of the fixation point can be specified by the parameter r.
<h3>Visualization</h3>
The element isn't visualized.
</html>"));
        import SI = Modelica.SIunits;

        parameter SI.Position r[3] = {0,0,0} "position of frame_b"
                                             annotation(Evaluate=true);

        replaceable Interfaces.Frame_b frame_b
          "|Advanced||replaceable Interface for further extensions"
                                   annotation (extent=[100,-20; 120,20]);

      protected
        inner Defaults MBG_defaults(n=3) annotation (extent=[-80,60; -60,80]);
        replaceable Interfaces.MBG2Mech MBG2Mech1
                                      annotation (extent=[80,-40; 100,40]);
        Sources.Sf Sf1(     f0={0}) annotation (extent=[40,20; 20,40]);
        Modelica.Blocks.Sources.Constant x0[3](k=r)
          annotation (extent=[-12,0; 8,20]);
        Modelica.Blocks.Sources.Constant R0[3,3](k=identity(3))
          annotation (extent=[-40,-20; -20,0]);
        Sources.Sf Sf2(     f0={0}) annotation (extent=[40,-40; 20,-20]);
        Bonds.MultiBond MultiBond1      annotation (extent=[60,20; 80,40]);
        Bonds.MultiBond MultiBond2      annotation (extent=[60,-40; 80,-20]);
        Bonds.Utilities.MultiBondTail MultiBondTail1 annotation (extent=[40,20; 62,40]);
        Bonds.Utilities.MultiBondTail MultiBondTail2 annotation (extent=[40,-40; 62,
              -20]);
      equation
        defineRoot(frame_b.P);
        connect(MBG2Mech1.frame_b, frame_b) annotation (points=[99,0; 110,0],
                      style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Sf1.MultiBondCon1, MultiBond1.MultiBondCon1)
          annotation (points=[40,30; 60,30], style(color=71, rgbcolor={85,170,255}));
        connect(x0.y, MBG2Mech1.x) annotation (points=[9,10; 80,10],
            style(color=74, rgbcolor={0,0,127}));
        connect(R0.y, MBG2Mech1.R) annotation (points=[-19,-10; 80,-10],
            style(color=74, rgbcolor={0,0,127}));
        connect(MultiBond1.MultiBondCon2, MBG2Mech1.MultiBondConTrans)
          annotation (points=[80,30; 80,30], style(color=71, rgbcolor={85,170,255}));
        connect(Sf2.MultiBondCon1, MultiBond2.MultiBondCon1) annotation (points=[40,-30;
              60,-30],      style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond2.MultiBondCon2, MBG2Mech1.MultiBondConRot) annotation (
            points=[80,-30; 80,-30], style(color=71, rgbcolor={85,170,255}));
      end Fixed;

      model FixedRotation "fixed rotational element"
        import SI = Modelica.SIunits;
        import MB = Modelica.Mechanics.MultiBody;
        import Cv = Modelica.SIunits.Conversions;

        parameter SI.Position n[3] = {1,0,0} "rotation axis"
                                           annotation(Evaluate=true);
        final parameter Real eN[3] = n/sqrt(n*n)
          "unit vector pointing along rotation axis"
        annotation (Icon(
            Text(
              extent=[-100,40; -60,10],
              style(color=10),
              string="a"),
            Text(
              extent=[60,40; 100,10],
              style(color=10),
              string="b"),
            Text(
              extent=[124,-108; -108,-68],
              style(color=0),
              string="n=%n"),
            Text(extent=[-116,120; 114,62], string="%name"),
            Ellipse(extent=[-100,70; 40,-70], style(
                color=0,
                rgbcolor={0,0,0},
                fillColor=30,
                rgbfillColor={215,215,215})),
            Ellipse(extent=[-36,70; 100,-70], style(
                color=0,
                rgbcolor={0,0,0},
                fillColor=10,
                rgbfillColor={135,135,135})),
            Ellipse(extent=[24,10; 44,-10], style(
                color=0,
                rgbcolor={0,0,0},
                fillColor=10,
                rgbfillColor={95,95,95}))),                   Diagram);

        parameter Cv.NonSIunits.Angle_deg angle=0 "angle";
        final parameter SI.Angle phi = Cv.from_deg(angle);

        replaceable Interfaces.Frame_a frame_a
          "|Advanced||replaceable Interface for further extensions"
                                   annotation (extent=[-120,-20; -100,20]);
        replaceable Interfaces.Frame_b frame_b
          "|Advanced||replaceable Interface for further extensions"
                                   annotation (extent=[100,-20; 120,20]);
      protected
        outer World3D world3D;
        inner Defaults MBG_defaults(n=3) annotation (extent=[60,60; 80,80]);
        replaceable Interfaces.Mech2MBG Mech2MBG1
                                      annotation (extent=[-100,-40; -80,40]);
        replaceable Interfaces.MBG2Mech MBG2Mech1
                                      annotation (extent=[80,-40; 100,40]);
        Utilities.planarRotation planarRotation1(n=eN)
          annotation (extent=[-40,-90; -20,-70]);
        Bonds.MultiBond MultiBond3      annotation (extent=[60,20; 80,40]);
        Bonds.MultiBond MultiBond1      annotation (extent=[0,-40; 20,-20]);
        Bonds.MultiBond MultiBond2      annotation (extent=[60,-40; 80,-20]);
        Bonds.Utilities.MultiBondTail MultiBondTail1
                                           annotation (extent=[-80,-40; 2,-20]);
        Bonds.Utilities.MultiBondTail MultiBondTail2
                                           annotation (extent=[-80,20; 62,40]);
        Bonds.Utilities.MultiBondTail MultiBondTail3
                                           annotation (extent=[40,-40; 62,-20]);
        AdditionalMBG.mTF mTF1 annotation (extent=[20,-40; 40,-20]);
        Modelica.Blocks.Sources.Constant Constant1(k=phi)
          annotation (extent=[-80,-90; -60,-70]);
        Utilities.Rotation Rotation1     annotation (extent=[-22,0; -2,-20]);
      equation
        defineBranch(frame_a.P,frame_b.P);

        if rooted(frame_a.P) then
          Rotation1.dirForward = true;
          mTF1.transformFlow = true;
        else
          Rotation1.dirForward = false;
          mTF1.transformFlow = false;
        end if;

        connect(MBG2Mech1.frame_b, frame_b) annotation (points=[99,0; 110,0],
                         style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(Mech2MBG1.frame_a, frame_a) annotation (points=[-99,0; -110,0],
                                style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(Mech2MBG1.x, MBG2Mech1.x) annotation (points=[-80,10; 80,10],
                                   style(
            color=3,
            rgbcolor={0,0,255},
            fillColor=10,
            rgbfillColor={95,95,95},
            fillPattern=1));
        connect(planarRotation1.phi, Constant1.y) annotation (points=[-40,-80; -59,
              -80],
            style(
            color=3,
            rgbcolor={0,0,255},
            fillColor=10,
            rgbfillColor={95,95,95},
            fillPattern=1));
        connect(planarRotation1.Rrel, Rotation1.Rrel) annotation (points=[-20,-80;
              -12,-80; -12,-20],
                            style(
            color=3,
            rgbcolor={0,0,255},
            fillColor=10,
            rgbfillColor={95,95,95},
            fillPattern=1));
        connect(Mech2MBG1.R, Rotation1.R1) annotation (points=[-80,-10; -22,-10],
                    style(
            color=3,
            rgbcolor={0,0,255},
            fillColor=10,
            rgbfillColor={95,95,95},
            fillPattern=1));
        connect(Rotation1.R2, MBG2Mech1.R) annotation (points=[-2,-10; 80,-10],
            style(
            color=3,
            rgbcolor={0,0,255},
            fillColor=10,
            rgbfillColor={95,95,95},
            fillPattern=1));
        annotation (Icon(
            Text(extent=[-120,108; 110,50], string="%name"),
            Text(
              extent=[114,-102; -118,-62],
              style(color=0),
              string="n=%n"),
            Ellipse(extent=[-20,60; 100,-60], style(
                color=0,
                rgbcolor={0,0,0},
                fillColor=10,
                rgbfillColor={135,135,135},
                fillPattern=1)),
            Ellipse(extent=[-100,60; 20,-60], style(
                color=0,
                rgbcolor={0,0,0},
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1)),
            Ellipse(extent=[-16,16; 16,-16], style(
                color=0,
                rgbcolor={0,0,0},
                fillColor=10,
                rgbfillColor={135,135,135},
                fillPattern=1))), Diagram(
            Rectangle(extent=[-80,-40; -60,-60],
                                               style(color=5, rgbcolor={255,0,255})),
            Text(
              extent=[-80,-44; -60,-56],
              style(color=5, rgbcolor={255,0,255}),
              string="root?"),
            Line(points=[-100,-16; -92,-16; -92,-52; -80,-52], style(color=5,
                  rgbcolor={255,0,255})),
            Line(points=[-16,-24; -16,-50; -60,-50; -58,-50], style(color=5, rgbcolor=
                   {255,0,255})),
            Line(points=[-16,-50; 24,-50; 24,-44], style(color=5, rgbcolor={255,0,255}))),
          Documentation(info="<html>
This component defines a fixed rotation between the two connected frames.
<h3>General parameter</h3>
The rotation can be specified by the rotation axis n and the rotation anlge phi.
The rotation axis is resolved in the body system.
<h3>Visualization</h3>
The element isn't visualized.
</html>"));
        connect(MultiBond2.MultiBondCon2, MBG2Mech1.MultiBondConRot) annotation (
            points=[80,-30; 80,-30], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond1.MultiBondCon1, Mech2MBG1.MultiBondConRot) annotation (
            points=[0,-30; -79.8,-30], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond3.MultiBondCon2, MBG2Mech1.MultiBondConTrans)
          annotation (points=[80,30; 80,30], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond3.MultiBondCon1, Mech2MBG1.MultiBondConTrans) annotation (
            points=[60,30; -80,30], style(color=71, rgbcolor={85,170,255}));
        connect(mTF1.MultiBondCon1, MultiBond1.MultiBondCon2) annotation (points=[20,
              -30; 20,-30], style(color=71, rgbcolor={85,170,255}));
        connect(mTF1.MultiBondCon2, MultiBond2.MultiBondCon1) annotation (points=[40,
              -30; 60,-30], style(color=71, rgbcolor={85,170,255}));
        connect(planarRotation1.Rrel, mTF1.M) annotation (points=[-20,-80; 30,-80; 30,
              -40], style(color=3, rgbcolor={0,0,255}));
      end FixedRotation;

      model FixedTranslation "fixed translational element (massles rod)"
        import SI = Modelica.SIunits;
        import MB = Modelica.Mechanics.MultiBody;
        parameter Boolean animation=true
          "= true, if animation shall be enabled";
        parameter SI.Position r[3] = {1,0,0}
          "translational vector from frame a to b"
                                           annotation(Evaluate=true);
        annotation (Icon(
            Rectangle(extent=[-100,10; 100,-1],  style(color=0, fillColor=0)),
            Text(
              extent=[-100,40; -60,10],
              style(color=10),
              string="a"),
            Text(
              extent=[60,40; 100,10],
              style(color=10),
              string="b"),
            Text(
              extent=[112,-70; -120,-30],
              style(color=0),
              string="r=%r"),
            Text(extent=[-114,100; 116,42], string="%name")), Diagram,
          Documentation(info="<html>
This is the model of a massless rod. It defines a fixed translation between the two connected frames.
<p>
<img src=\"../Images/Transl.png\">
</p>
<h3>General parameter</h3>
The rod can be specified by a parameter vector r.
r is resolved in the body system and points from frame a to frame b.
<h3>Visualization</h3>
The element is normally visualized as cylinder. Anyhow the visualization can be changed by the according parameters.
</html>"));

        parameter Modelica.Mechanics.MultiBody.Types.ShapeType shapeType="cylinder"
          "|Animation|if animation = true| Type of shape";
        parameter SI.Length length=sqrt(r*r)
          "|Animation|if animation = true| Length of shape";
        parameter SI.Distance width=length/world3D.defaultWidthFraction
          "|Animation|if animation = true| Width of shape";
        parameter SI.Distance height=width
          "|Animation|if animation = true| Height of shape.";
        parameter Real extra=0.0
          "|Animation|if animation = true| Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).";
        parameter Modelica.Mechanics.MultiBody.Types.Color color=world3D.defaultRodColor
          "|Animation|if animation = true| Color of shape";

        replaceable Interfaces.Frame_a frame_a
          "|Advanced||replaceable Interface for further extensions"
                                   annotation (extent=[-120,-20; -100,20]);
        replaceable Interfaces.Frame_b frame_b
          "|Advanced||replaceable Interface for further extensions"
                                   annotation (extent=[100,-20; 120,20]);
      protected
        outer World3D world3D;
        inner Defaults MBG_defaults(n=3) annotation (extent=[-78,60; -58,80]);
        replaceable Interfaces.Mech2MBG Mech2MBG1
                                      annotation (extent=[-100,-40; -80,40]);
        replaceable Interfaces.MBG2Mech MBG2Mech1
                                      annotation (extent=[80,-40; 100,40]);
        AdditionalMBG.translationalTF translationalTF1(r=r)
          annotation (extent=[-30,-10; -10,10]);
        Junctions.J0 J0_1 annotation (extent=[40,20; 60,40]);
        Junctions.J1 J1_1 annotation (extent=[-60,-40; -40,-20]);
        Passive.mTF_effort mTF_effort1 annotation (extent=[30,-10; 10,10]);
        Bonds.MultiBond MultiBond1      annotation (extent=[20,20; 40,40]);
        Bonds.MultiBond MultiBond2      annotation (extent=[60,20; 80,40]);
        Bonds.MultiBond MultiBond3      annotation (extent=[-80,-40; -60,-20]);
        Bonds.MultiBond MultiBond4      annotation (extent=[60,-40; 80,-20]);
        Bonds.MultiBond MultiBond5      annotation (extent=[-10,-10; 10,10], rotation=
             0);
        Bonds.MultiBond MultiBond6      annotation (extent=[-50,-10; -30,10],
            rotation=0);
        Bonds.MultiBond MultiBond7      annotation (extent=[40,0; 60,20], rotation=90);
        Bonds.Utilities.MultiBondTail MultiBondTail1
                                           annotation (extent=[-80,20; 24,40]);
        Bonds.Utilities.MultiBondTail MultiBondTail2
                                           annotation (extent=[48,-10; 30,10],
            rotation=180);
        Bonds.Utilities.MultiBondTail MultiBondTail3
                                           annotation (extent=[-40,-20; -60,-2],
            rotation=90);
        Bonds.Utilities.MultiBondTail MultiBondTail4
                                           annotation (extent=[-40,-40; 62,-20]);
        Utilities.Translation Translation1(r=r)
          annotation (extent=[-74,0; -54,20]);

        parameter Integer ndim=if world3D.enableAnimation and animation then 1 else 0;
        MB.Visualizers.Advanced.Shape rod[ndim](
          each shapeType="cylinder",
          each color=color,
          each length=length,
          each width=width,
          each height=height,
          each lengthDirection=r,
          each widthDirection={0,0,1},
          each r_shape={0,0,0},
          each r=Mech2MBG1.x,
          each R=MB.Frames.Orientation(T=Mech2MBG1.R,w=zeros(3)));

      equation
        defineBranch(frame_a.P,frame_b.P);
        connect(MBG2Mech1.frame_b, frame_b) annotation (points=[99,0; 110,0],
                         style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(Mech2MBG1.frame_a, frame_a) annotation (points=[-99,0; -110,0],
                                style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(MultiBond2.MultiBondCon2, MBG2Mech1.MultiBondConTrans)
          annotation (points=[80,30; 80,30], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond1.MultiBondCon1, Mech2MBG1.MultiBondConTrans) annotation (
            points=[20,30; -80,30], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond3.MultiBondCon1, Mech2MBG1.MultiBondConRot) annotation (
            points=[-80,-30; -79.8,-30], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond4.MultiBondCon2, MBG2Mech1.MultiBondConRot) annotation (
            points=[80,-30; 80,-30], style(color=71, rgbcolor={85,170,255}));
        connect(Mech2MBG1.R, MBG2Mech1.R) annotation (points=[-80,-10; -74,-10; -74,
              -14; 72,-14; 72,-10; 80,-10], style(color=3, rgbcolor={0,0,255}));
        connect(Mech2MBG1.x, Translation1.x1)
          annotation (points=[-80,10; -74,10], style(color=3, rgbcolor={0,0,255}));
        connect(Mech2MBG1.R, Translation1.R) annotation (points=[-80,-10; -74,-10;
              -74,-14; -64,-14; -64,0], style(color=3, rgbcolor={0,0,255}));
        connect(J0_1.MultiBondCon2, MultiBond2.MultiBondCon1)
          annotation (points=[60,30; 60,30], style(color=71, rgbcolor={85,170,255}));
        connect(MBG2Mech1.x, Translation1.x2) annotation (points=[80,10; 76,10; 76,14;
              -48,14; -48,10; -54,10], style(color=3, rgbcolor={0,0,255}));
        connect(MultiBond1.MultiBondCon2, J0_1.MultiBondCon1)
          annotation (points=[40,30; 40,30], style(color=71, rgbcolor={85,170,255}));
        connect(mTF_effort1.MultiBondCon2, MultiBond5.MultiBondCon2)
          annotation (points=[10,0; 10,0], style(color=71, rgbcolor={85,170,255}));
        connect(mTF_effort1.MultiBondCon1, MultiBond7.MultiBondCon1)
          annotation (points=[30,0; 50,0], style(color=71, rgbcolor={85,170,255}));
        connect(mTF_effort1.M, Mech2MBG1.R) annotation (points=[20,-10; 20,-14; -74,
              -14; -74,-10; -80,-10], style(color=3, rgbcolor={0,0,255}));
        connect(translationalTF1.MultiBondCon2, MultiBond5.MultiBondCon1)
          annotation (points=[-10,0; -10,0], style(color=71, rgbcolor={85,170,255}));
        connect(translationalTF1.MultiBondCon1, MultiBond6.MultiBondCon2)
          annotation (points=[-30,0; -30,0], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond6.MultiBondCon1, J1_1.MultiBondCon4) annotation (points=[-50,
              0; -50,-20], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond7.MultiBondCon2, J0_1.MultiBondCon3)
          annotation (points=[50,20; 50,20], style(color=71, rgbcolor={85,170,255}));
        connect(J1_1.MultiBondCon1, MultiBond3.MultiBondCon2) annotation (points=[-60,
              -30; -60,-30], style(color=71, rgbcolor={85,170,255}));
        connect(J1_1.MultiBondCon2, MultiBond4.MultiBondCon1) annotation (points=[-40,
              -30; 60,-30], style(color=71, rgbcolor={85,170,255}));
      end FixedTranslation;

      annotation (preferedView="info", Documentation(info="<html>
This package contains completely rigid components.
<p>
These components are either define a mass and inertia or they define a fixed relationship.
</html>"));
    end Parts;

    package RollingObjects
      "part and joint elements of ideal rolling wheels and marbles"
      extends Modelica.Icons.Library;

      model WheelJoint "models the joint characteristics of a wheel"
        import SI = Modelica.SIunits;
        import MB = Modelica.Mechanics.MultiBody;

        parameter Boolean animation = true "animate wheel";

        parameter SI.Radius r=1 "radius of wheel";
        parameter Real n[3] = {0,1,0}
          "vector normal to rolling plane, pointing upwards"                             annotation(Evaluate=true);
        parameter SI.Distance d=0 "distance of rolling plane o origin";

        parameter SI.Radius rRim = 0.9*r "|Animation|| radius of rim";
        parameter SI.Diameter wWheel = 0.1*r "|Animation|| width of the wheel";
        parameter MB.Types.Color tireColor= {64,64,64}
          "|Animation|| Color of the tire";
        parameter MB.Types.Color rodColor= {128,0,0}
          "|Animation|| Color of the rods";
        parameter MB.Types.Color contactColor= {128,128,128}
          "|Animation|| Color of the contactpoint";

        final parameter Real eN[3] = n/sqrt(n*n) "normalization of n"
                                             annotation(Evaluate=true);
        final parameter Real notN[3] = if abs(eN[1]) > 0.1 then {0,1,0} else (if abs(eN[2])
             > 0.1 then {0,0,1} else {1,0,0})
          "Arbitrary vector that is not aligned with eN"   annotation(Evaluate=true);
        final parameter Real vec_a[3] = cross(eN,notN)
          "vector in rolling plane" annotation(Evaluate=true);
        final parameter Real eA[3] = {1,0,0}
          "normalized vector in rolling plane"
                                             annotation(Evaluate=true);
        final parameter Real eB[3] = cross(eA,eN)
          "normalized vector in rolling plane orthogonal to eA"
                                             annotation(Evaluate=true);

        SI.AngularVelocity w[3] "angular velocity";
        SI.AngularAcceleration z[3] "angular acceleration";

        SI.Position x[3] "Position of the frame";
        SI.Velocity v[3] "Velocity";
        SI.Acceleration a[3] "Acceleration";

        Real d_cp[3]
          "vector pointing in direction of the contact point from wheel center res. in inertial frame";

        SI.Force fN;

      protected
        Real eAxis[3] "unit vector aligned to wheel Axis in inertial frame";
        SI.Position r_cp[3]
          "Vector from wheel center to contact point res. in inertial frame";

      public
        Interfaces.Frame_b frame_b annotation (extent=[100,-20; 120,20]);

      protected
        Interfaces.MBG2Mech MBG2Mech1 annotation (extent=[80,-60; 100,20]);
        inner Defaults MBG_defaults(n=3) annotation (extent=[40,60; 60,80]);
        Junctions.J0 J0_1 annotation (extent=[-60,0; -40,20]);
        Bonds.MultiBond MultiBond2 annotation (extent=[60,0; 80,20]);
        Bonds.MultiBond MultiBond5 annotation (extent=[60,-60; 80,-40], rotation=0);
        Bonds.MultiBond MultiBond13 annotation (extent=[-40,-60; -20,-40], rotation=0);
        Bonds.MultiBond MultiBond14 annotation (extent=[0,-60; 20,-40], rotation=0);
        Bonds.Utilities.MultiBondTail MultiBondTail2
          annotation (extent=[-60,-48; -40,0], rotation=90);
        Bonds.Utilities.MultiBondTail MultiBondTail3
          annotation (extent=[-48,-60; -38,-40], rotation=0);
        Bonds.Utilities.MultiBondTail MultiBondTail4
          annotation (extent=[40,-60; 62,-40]);
        Passive.mTF_effort mTF_effort1 annotation (extent=[20,-60; 40,-40]);

      protected
        outer World3D world3D;

       parameter Integer ndim=if world3D.enableAnimation and animation then 1 else 0;
      MB.Visualizers.Advanced.Shape tirePipe[ndim](
          each shapeType="pipe",
          each color=tireColor,
          each length= wWheel,
          each width=2*r,
          each height=2*r,
          each lengthDirection={0,0,1},
          each widthDirection={0,1,0},
          each extra=rRim/r,
          each r_shape=-{0,0,1}*(2*r/40),
          each r=MBG2Mech1.x,
          each R=MB.Frames.Orientation(T=MBG2Mech1.R,w=zeros(3)));

      MB.Visualizers.Advanced.Shape cylindery[ndim](
          each shapeType="cylinder",
          each color=rodColor,
          each length= 2*rRim,
          each width=wWheel,
          each height=wWheel,
          each lengthDirection={0,1,0},
          each widthDirection={0,0,1},
          each r_shape=-{0,1,0}*rRim,
          each r=MBG2Mech1.x,
          each R=MB.Frames.Orientation(T=MBG2Mech1.R,w=zeros(3)));

      MB.Visualizers.Advanced.Shape cylinderx[ndim](
          each shapeType="cylinder",
          each color=rodColor,
          each length= 2*rRim,
          each width=wWheel,
          each height=wWheel,
          each lengthDirection={1,0,0},
          each widthDirection={0,0,1},
          each r_shape=-{1,0,0}*rRim,
          each r=MBG2Mech1.x,
          each R=MB.Frames.Orientation(T=MBG2Mech1.R,w=zeros(3)));

      MB.Visualizers.Advanced.Shape cylinderxy[ndim](
          each shapeType="cylinder",
          each color=rodColor,
          each length= 2*rRim,
          each width=wWheel,
          each height=wWheel,
          each lengthDirection={1,1,0},
          each widthDirection={0,0,1},
          each r_shape=-{0.706,0.706,0}*rRim,
          each r=MBG2Mech1.x,
          each R=MB.Frames.Orientation(T=MBG2Mech1.R,w=zeros(3)));

      MB.Visualizers.Advanced.Shape cylinderyx[ndim](
          each shapeType="cylinder",
          each color=rodColor,
          each length= 2*rRim,
          each width=wWheel,
          each height=wWheel,
          each lengthDirection={1,-1,0},
          each widthDirection={0,0,1},
          each r_shape=-{0.706,-0.706,0}*rRim,
          each r=MBG2Mech1.x,
          each R=MB.Frames.Orientation(T=MBG2Mech1.R,w=zeros(3)));

      MB.Visualizers.Advanced.Shape contactPoint[ndim](
          each shapeType="cylinder",
          each color=contactColor,
          each length= r/20,
          each width=wWheel*3,
          each height=wWheel*3,
          each lengthDirection=eN,
          each widthDirection=eA,
          each r=MBG2Mech1.x,
          each r_shape=r_cp,
          each specularCoefficient = 0.1);

       annotation (Diagram(
            Rectangle(extent=[0,-70; 20,-90],style(
                color=10,
                rgbcolor={135,135,135},
                fillColor=7,
                rgbfillColor={255,255,255})),
            Text(
              extent=[18,-86; 2,-80],
              style(
                color=10,
                rgbcolor={135,135,135},
                gradient=3),
              string="point"),
            Text(
              extent=[2,-72; 18,-82],
              style(
                color=10,
                rgbcolor={135,135,135},
                gradient=3),
              string="contact"),
            Line(points=[-10,-64; -10,-80; 0,-80],   style(color=10, rgbcolor={135,
                    135,135})),
            Line(points=[20,-80; 72,-80; 72,-30],    style(color=10, rgbcolor={135,
                    135,135})),
            Rectangle(extent=[20,0; 40,-20], style(
                color=10,
                rgbcolor={135,135,135},
                fillColor=7,
                rgbfillColor={255,255,255})),
            Text(
              extent=[40,-16; 20,-10],
              style(
                color=10,
                rgbcolor={135,135,135},
                gradient=3),
              string="constraint"),
            Text(
              extent=[20,-2; 40,-10],
              style(
                color=10,
                rgbcolor={135,135,135},
                gradient=3),
              string="holonomic"),
            Line(points=[40,-10; 68,-10; 78,-10],    style(color=10, rgbcolor={135,
                    135,135})),
            Line(points=[-46,100; 30,56; 30,0],  style(color=10, rgbcolor={135,135,
                    135}))),      Icon(
            Ellipse(extent=[-70,68; 70,-70], style(
                color=3,
                rgbcolor={0,0,255},
                gradient=3,
                fillColor=83,
                rgbfillColor={255,170,255})),
            Line(points=[-100,-70; 100,-70], style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2)),
            Text(extent=[-114,130; 116,72], string="%name"),
            Text(
              extent=[128,-116; -104,-76],
              style(color=0),
              string="r=%r"),
            Line(points=[98,0; 20,0], style(
                color=0,
                rgbcolor={0,0,0},
                gradient=3,
                fillColor=5,
                rgbfillColor={255,0,255})),
            Ellipse(extent=[-42,42; 42,-42], style(
                pattern=0,
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Ellipse(extent=[-18,18; 18,-18], style(
                pattern=0,
                fillColor=10,
                rgbfillColor={95,95,95},
                fillPattern=1))),
          Documentation(info="<html>
This component models the movement constraints for an ideal rolling wheel.
<p>
<img src=\"../Images/Wheel.png\">
</p>
<h3>General parameter</h3>
The radius of the wheel can be defined by the parameter r.
<p>
The rolling plane can be specified by the vector n (pointing upwards) and the distance of the  plane
from the origin d.
<p>
The parameter animation toggles the visualization
<h3>Visualization</h3>
A full animation of the wheel is supported.
Color and basic geometry can be changed by the corresponding parameters.
<h3>Remarks</h3>
Ideal rolling establishes one holonomic constraint and two non-holonomic constraints.
A freely rolling wheel therefore has 3 degrees of freedom on the level of velocity
on five degrees of freedom on the level of position.
</html>"));

        AdditionalMBG.translational_mTF2 translational_mTF2_1
          annotation (extent=[-20,-60; 0,-40], rotation=180);
        Bonds.Utilities.MultiBondTail MultiBondTail5 annotation (extent=[-40,0; 62,20]);
        Bonds.MultiBond MultiBond4(n=1)
                                   annotation (extent=[-60,60; -40,80],
                                                                      rotation=270);
        Bonds.MultiBond MultiBond6 annotation (extent=[-60,20; -40,40], rotation=270);
      public
        Sources.mSe mSe1(n=1) annotation (extent=[-60,80; -40,100], rotation=90);

        Passive.TF2_effort projectiveTF(
          nA=3,
          nB=1,
          M={eN}) annotation (extent=[-60,40; -40,60], rotation=90);
      equation

        w = MBG2Mech1.MultiBondConRot.f;
        z = der(w);

        x = MBG2Mech1.x;
        v = MBG2Mech1.MultiBondConTrans.f;
        a = der(v);

      // holonomic constraint
        x*eN  = (d - r_cp*eN);
          fN = mSe1.s[1];

      // contact point computation
        eAxis = transpose(MBG2Mech1.R)*{0,0,1};
        d_cp = (-eN) - ((-eN)*eAxis)*eAxis;
        r_cp = r* d_cp/sqrt(d_cp*d_cp);
        translational_mTF2_1.r = r_cp;

        connect(MBG2Mech1.frame_b,frame_b)  annotation (points=[99,-20; 104,-20; 104,
              0; 110,0],
                      style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(MultiBond2.MultiBondCon2, MBG2Mech1.MultiBondConTrans) annotation (
            points=[80,10; 80,10], style(
            color=71,
            rgbcolor={85,170,255},
            thickness=2,
            gradient=3,
            fillColor=83,
            rgbfillColor={255,170,255}));
        connect(MultiBond13.MultiBondCon1, J0_1.MultiBondCon3) annotation (points=[-40,-50;
              -50,-50; -50,0],          style(
            color=71,
            rgbcolor={85,170,255},
            gradient=3,
            fillColor=83,
            rgbfillColor={255,170,255}));
        connect(mTF_effort1.MultiBondCon2, MultiBond5.MultiBondCon1) annotation (
            points=[40,-50; 60,-50], style(color=71, rgbcolor={85,170,255}));
        connect(mTF_effort1.MultiBondCon1, MultiBond14.MultiBondCon2) annotation (
            points=[20,-50; 20,-50], style(color=71, rgbcolor={85,170,255}));
        connect(translational_mTF2_1.MultiBondCon1, MultiBond14.MultiBondCon1)
          annotation (points=[0,-50; 0,-50], style(color=71, rgbcolor={85,170,255}));
        connect(translational_mTF2_1.MultiBondCon2, MultiBond13.MultiBondCon2)
          annotation (points=[-20,-50; -20,-50], style(color=71, rgbcolor={85,170,255}));
        connect(mTF_effort1.M, MBG2Mech1.R) annotation (points=[30,-60; 30,-70; 76,
              -70; 76,-30; 80,-30], style(color=3, rgbcolor={0,0,255}));
        connect(MultiBond5.MultiBondCon2, MBG2Mech1.MultiBondConRot) annotation (
            points=[80,-50; 80,-50], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond2.MultiBondCon1, J0_1.MultiBondCon2) annotation (points=[60,10;
              -40,10],     style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond6.MultiBondCon2, J0_1.MultiBondCon4) annotation (points=[-50,20;
              -50,20],     style(color=71, rgbcolor={85,170,255}));
        connect(mSe1.MultiBondCon1, MultiBond4.MultiBondCon1) annotation (points=[-50,
              80; -50,80], style(color=71, rgbcolor={85,170,255}));
        connect(projectiveTF.MultiBondConB, MultiBond4.MultiBondCon2)
          annotation (points=[-50,60; -50,60], style(color=71, rgbcolor={85,170,
                255}));
        connect(projectiveTF.MultiBondConA, MultiBond6.MultiBondCon1)
          annotation (points=[-50,40; -50,40], style(color=71, rgbcolor={85,170,
                255}));
      end WheelJoint;

      model MarbleJoint "models the joint characteristics of a marble"
        import SI = Modelica.SIunits;
        import MB = Modelica.Mechanics.MultiBody;

        parameter Boolean animation = true "animate marble";

        parameter SI.Radius r=1 "radius of marble";
        parameter Real n[3] = {0,1,0}
          "vector normal to rolling plane, pointing upwards"                             annotation(Evaluate=true);
        parameter SI.Distance d=0 "distance of rolling plane o origin";

        final parameter Real eN[3] = n/sqrt(n*n) "normalization of n"
                                             annotation(Evaluate=true);
        final parameter Real notN[3] = if abs(eN[1]) > 0.1 then {0,1,0} else (if abs(eN[2])
             > 0.1 then {0,0,1} else {1,0,0})
          "Arbitrary vector that is not aligned with eN"   annotation(Evaluate=true);
        final parameter Real vec_a[3] = cross(eN,notN)
          "vector in rolling plane" annotation(Evaluate=true);
        final parameter Real eA[3] = {1,0,0}
          "normalized vector in rolling plane"
                                             annotation(Evaluate=true);
        final parameter Real eB[3] = cross(eA,eN)
          "normalized vector in rolling plane orthogonal to eA"
                                             annotation(Evaluate=true);

        SI.AngularVelocity w[3] "angular velocity";
        SI.AngularAcceleration z[3] "angular acceleration";

        SI.Position x[3] "Position of the frame";
        SI.Velocity v[3] "Velocity";
        SI.Acceleration a[3] "Acceleration";

        SI.Force fN;

      public
        Interfaces.Frame_b frame_b annotation (extent=[100,-20; 120,20]);

      protected
        Interfaces.MBG2Mech MBG2Mech1 annotation (extent=[80,-60; 100,20]);
        inner Defaults MBG_defaults(n=3) annotation (extent=[40,60; 60,80]);
        Junctions.J0 J0_1 annotation (extent=[-60,0; -40,20]);
        Bonds.MultiBond MultiBond2 annotation (extent=[60,0; 80,20]);
        Bonds.MultiBond MultiBond5 annotation (extent=[60,-60; 80,-40], rotation=0);
        Bonds.MultiBond MultiBond13 annotation (extent=[-40,-60; -20,-40], rotation=0);
        Bonds.MultiBond MultiBond14 annotation (extent=[0,-60; 20,-40], rotation=0);
        Bonds.Utilities.MultiBondTail MultiBondTail2
          annotation (extent=[-60,-48; -40,0], rotation=90);
        Bonds.Utilities.MultiBondTail MultiBondTail3
          annotation (extent=[-48,-60; -38,-40], rotation=0);
        Bonds.Utilities.MultiBondTail MultiBondTail4
          annotation (extent=[40,-60; 62,-40]);
        Passive.mTF_effort mTF_effort1 annotation (extent=[20,-60; 40,-40]);

      protected
        outer World3D world3D;

       parameter Integer ndim=if world3D.enableAnimation and animation then 1 else 0;

      MB.Visualizers.Advanced.Shape cylinderz[ndim](
          each shapeType="cylinder",
          each color={192,0,192},
          each length= 2*r/10,
          each width=2*r,
          each height=2*r,
          each lengthDirection={0,0,1},
          each widthDirection={0,1,0},
          each r_shape=-{0,0,1}*(2*r/20),
          each r=MBG2Mech1.x,
          each R=MB.Frames.Orientation(T=MBG2Mech1.R,w=zeros(3)));

      MB.Visualizers.Advanced.Shape cylindery[ndim](
          each shapeType="cylinder",
          each color={192,0,192},
          each length= 2*r/10,
          each width=2*r,
          each height=2*r,
          each lengthDirection={0,1,0},
          each widthDirection={0,0,1},
          each r_shape=-{0,1,0}*(2*r/20),
          each r=MBG2Mech1.x,
          each R=MB.Frames.Orientation(T=MBG2Mech1.R,w=zeros(3)));

      MB.Visualizers.Advanced.Shape cylinderx[ndim](
          each shapeType="cylinder",
          each color={192,0,192},
          each length= 2*r/10,
          each width=2*r,
          each height=2*r,
          each lengthDirection={1,0,0},
          each widthDirection={0,1,0},
          each r_shape=-{1,0,0}*(2*r/20),
          each r=MBG2Mech1.x,
          each R=MB.Frames.Orientation(T=MBG2Mech1.R,w=zeros(3)));

        MB.Visualizers.Advanced.Shape sphere[ndim](
          each shapeType="sphere",
          each color={0,0,255},
          each length=1.8*r,
          each width=1.8*r,
          each height=1.8*r,
          each lengthDirection={1,0,0},
          each widthDirection={0,1,0},
          each r_shape=-{1,0,0}*1.8*r/2,
          each r=MBG2Mech1.x,
          each R=MB.Frames.Orientation(T=MBG2Mech1.R,w=zeros(3)));

       annotation (Diagram(
            Rectangle(extent=[20,0; 40,-20], style(
                color=10,
                rgbcolor={135,135,135},
                fillColor=7,
                rgbfillColor={255,255,255})),
            Text(
              extent=[40,-16; 20,-10],
              style(
                color=10,
                rgbcolor={135,135,135},
                gradient=3),
              string="constraint"),
            Text(
              extent=[20,-2; 40,-10],
              style(
                color=10,
                rgbcolor={135,135,135},
                gradient=3),
              string="holonomic"),
            Line(points=[40,-10; 68,-10; 78,-10],    style(color=10, rgbcolor={135,
                    135,135})),
            Line(points=[-46,100; 30,56; 30,0],  style(color=10, rgbcolor={135,135,
                    135}))),      Icon(
            Ellipse(extent=[-70,68; 70,-70], style(
                color=3,
                rgbcolor={0,0,255},
                gradient=3,
                fillColor=83,
                rgbfillColor={255,170,255})),
            Line(points=[-100,-70; 100,-70], style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2)),
            Text(extent=[-118,146; 112,88], string="%name"),
            Text(
              extent=[128,-116; -104,-76],
              style(color=0),
              string="r=%r"),
            Line(points=[98,0; 20,0], style(
                color=0,
                rgbcolor={0,0,0},
                gradient=3,
                fillColor=5,
                rgbfillColor={255,0,255})),
            Ellipse(extent=[-18,18; 18,-18], style(
                pattern=0,
                fillColor=10,
                rgbfillColor={95,95,95},
                fillPattern=1))),
          Documentation(info="<html>
This component models the movement constraints for an ideal rolling marble.
<p>
<img src=\"../Images/Marble.png\">
</p>
<h3>General parameter</h3>
The radius of the marble can be defined by the parameter r.
<p>
The rolling plane can be specified by the vector n (pointing upwards) and the distance of the  plane
from the origin d.
<p>
The parameter animation toggles the visualization
<h3>Visualization</h3>
The element is visualized by a blue sphere with magenta stripes.
<h3>Remarks</h3>
Ideal rolling establishes one holonomic constraint and two non-holonomic constraints.
A freely rolling marble therefore has 3 degrees of freedom on the level of velocity
on five degrees of freedom on the level of position.
</html>"));

        Bonds.Utilities.MultiBondTail MultiBondTail5 annotation (extent=[-40,0; 62,20]);
        Bonds.MultiBond MultiBond4(n=1)
                                   annotation (extent=[-60,60; -40,80],
                                                                      rotation=270);
        Bonds.MultiBond MultiBond6 annotation (extent=[-60,20; -40,40], rotation=270);
      public
        Sources.mSe mSe1(n=1) annotation (extent=[-60,80; -40,100], rotation=90);
      protected
        AdditionalMBG.translationalTF translationalTF1(r=-r*eN)
          annotation (extent=[0,-60; -20,-40]);

      public
        Passive.TF2_effort projectiveTF(
          nA=3,
          nB=1,
          M={eN}) annotation (extent=[-60,40; -40,60], rotation=90);
      equation
        w = MBG2Mech1.MultiBondConRot.f;
        z = der(w);

        x = MBG2Mech1.x;
        v = MBG2Mech1.MultiBondConTrans.f;
        a = der(v);

      // holonomic constraint
        -x*eN  = (d - r);
          fN = mSe1.s[1];

        connect(MBG2Mech1.frame_b,frame_b)  annotation (points=[99,-20; 104,-20; 104,
              0; 110,0],
                      style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(MultiBond2.MultiBondCon2, MBG2Mech1.MultiBondConTrans) annotation (
            points=[80,10; 80,10], style(
            color=71,
            rgbcolor={85,170,255},
            thickness=2,
            gradient=3,
            fillColor=83,
            rgbfillColor={255,170,255}));
        connect(MultiBond13.MultiBondCon1, J0_1.MultiBondCon3) annotation (points=[-40,-50;
              -50,-50; -50,0],          style(
            color=71,
            rgbcolor={85,170,255},
            gradient=3,
            fillColor=83,
            rgbfillColor={255,170,255}));
        connect(mTF_effort1.MultiBondCon2, MultiBond5.MultiBondCon1) annotation (
            points=[40,-50; 60,-50], style(color=71, rgbcolor={85,170,255}));
        connect(mTF_effort1.MultiBondCon1, MultiBond14.MultiBondCon2) annotation (
            points=[20,-50; 20,-50], style(color=71, rgbcolor={85,170,255}));
        connect(mTF_effort1.M, MBG2Mech1.R) annotation (points=[30,-60; 30,-70; 76,
              -70; 76,-30; 80,-30], style(color=3, rgbcolor={0,0,255}));
        connect(MultiBond5.MultiBondCon2, MBG2Mech1.MultiBondConRot) annotation (
            points=[80,-50; 80,-50], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond2.MultiBondCon1, J0_1.MultiBondCon2) annotation (points=[60,
              10; -40,10], style(color=71, rgbcolor={85,170,255}));
        connect(MultiBond6.MultiBondCon2, J0_1.MultiBondCon4) annotation (points=[-50,
              20; -50,20], style(color=71, rgbcolor={85,170,255}));
        connect(mSe1.MultiBondCon1, MultiBond4.MultiBondCon1) annotation (points=[-50,
              80; -50,80], style(color=71, rgbcolor={85,170,255}));
        connect(translationalTF1.MultiBondCon1, MultiBond14.MultiBondCon1)
          annotation (points=[0,-50; 0,-50], style(color=71, rgbcolor={85,170,
                255}));
        connect(translationalTF1.MultiBondCon2, MultiBond13.MultiBondCon2)
          annotation (points=[-20,-50; -20,-50], style(color=71, rgbcolor={85,
                170,255}));
        connect(projectiveTF.MultiBondConB, MultiBond4.MultiBondCon2)
          annotation (points=[-50,60; -50,60], style(color=71, rgbcolor={85,170,
                255}));
        connect(projectiveTF.MultiBondConA, MultiBond6.MultiBondCon1)
          annotation (points=[-50,40; -50,40], style(color=71, rgbcolor={85,170,
                255}));
      end MarbleJoint;

      model Wheel "complete model of a wheel"
        import SI = Modelica.SIunits;
        import MB = Modelica.Mechanics.MultiBody;
        import Cv = Modelica.SIunits.Conversions;

        parameter Boolean animation = true "animate wheel";

        parameter SI.Radius r=1 "radius of wheel";
        parameter Real n[3] = {0,1,0}
          "vector normal to rolling plane, pointing upwards"                             annotation(Evaluate=true);
        parameter SI.Distance d=0 "distance of rolling plane o origin";

        parameter SI.Mass m = 1 "mass of body";

        parameter SI.Inertia I_11=0.001
          "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (1,1) element of inertia tensor"
                                                                                                              annotation(Evaluate=true);
        parameter SI.Inertia I_22=0.001
          "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (2,2) element of inertia tensor"
                                                                                                              annotation(Evaluate=true);
        parameter SI.Inertia I_33=0.001
          "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (3,3) element of inertia tensor"
                                                                                                              annotation(Evaluate=true);
        parameter SI.Inertia I_21=0
          "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (2,1) element of inertia tensor"
                                                                                                              annotation(Evaluate=true);
        parameter SI.Inertia I_31=0
          "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (3,1) element of inertia tensor"
                                                                                                              annotation(Evaluate=true);
        parameter SI.Inertia I_32=0
          "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (3,2) element of inertia tensor"
                                                                                                              annotation(Evaluate=true);
        final parameter SI.Inertia Inert[3, 3]=[I_11, I_21, I_31; I_21, I_22, I_32;
            I_31, I_32, I_33] "inertia tensor"
                                              annotation(Evaluate=true);

        parameter MB.Types.Init.Temp initType=MB.Types.Init.Free
          "|Initialization|| Type of initialization (defines usage of start values below)";
        parameter Boolean useTransVelocities = false
          "|Initialization|| use the translational velocities (defines usage of start values below)";
        parameter Cv.NonSIunits.Angle_deg phi_start[3] = {0,0,0}
          "|Initialization||initial cardan angles in degree";
        parameter Types.AngularVelocity_deg w_start[3] = {0,0,0}
          "|Initialization||initial angular velocity in deg/s";
        parameter Types.AngularAcceleration_deg z_start[3] = {0,0,0}
          "|Initialization||initial angular acceleration in deg/s2";
        parameter SI.Position x_start[3] = {0,0,0}
          "|Initialization||initial position";
        parameter SI.Velocity v_start[3] = {0,0,0}
          "|Initialization||initial velocity";
        parameter SI.Acceleration a_start[3] = {0,0,0}
          "|Initialization||initial acceleration";

        final parameter SI.Angle phi_start_rad[3] = Cv.from_deg(phi_start)
          "initial cardan angles";
        final parameter SI.AngularVelocity w_start_rad[3] = Cv.from_deg(w_start)
          "initial angular velocity";
        final parameter SI.AngularAcceleration z_start_rad[3] = Cv.from_deg(z_start)
          "initial angular acceleration";

        parameter SI.Radius rRim = 0.9*r "|Animation|| radius of rim";
        parameter SI.Diameter wWheel = 0.1*r "|Animation|| width of the wheel";
        parameter MB.Types.Color tireColor= {64,64,64}
          "|Animation|| Color of the tire";
        parameter MB.Types.Color rodColor= {128,0,0}
          "|Animation|| Color of the rods";
        parameter MB.Types.Color contactColor= {128,128,128}
          "|Animation|| Color of the contactpoint";

        parameter Boolean enforceStates =  false
          "|Advanced||enforce Quaternions or cardan angles and w as states";
        parameter Boolean useQuaternions =  false
          "|Advanced||use Quaternions instead of cardan angles";
        final parameter Types.RotationSequence sequence_angles = {2,1,3}
          "|Advanced||sequence of the cardan angles";
        final parameter Types.Quaternion Q_start = Utilities.AxesRotQ(phi_start_rad,sequence_angles);

        SI.Position xA(stateSelect=if enforceStates then StateSelect.always else StateSelect.prefer)
          "Position in direction of eA";

        SI.Position xB(stateSelect=if enforceStates then StateSelect.always else StateSelect.prefer)
          "Position in direction of eB";

        SI.Position x[3] "Position of the frame";
        SI.Velocity v[3] "Velocity";

        Types.Quaternion Q(stateSelect=if useQuaternions then StateSelect.prefer else StateSelect.never,start = Q_start, fixed = false)
          "quaternions";
        SI.Angle phi[3](stateSelect=if not useQuaternions then (if enforceStates then
                        StateSelect.always else StateSelect.prefer) else  StateSelect.never)
          "cardan angles";
        SI.Angle phi_d[3](stateSelect=if not useQuaternions then (if enforceStates then
                        StateSelect.always else StateSelect.prefer) else  StateSelect.never)
          "cardan angles derivatives";
        SI.AngularVelocity w[3](stateSelect=if useQuaternions then (if enforceStates then
                        StateSelect.always else StateSelect.prefer) else  StateSelect.default)
          "angular velocity";

        SI.Acceleration a[3] "Acceleration";
        SI.AngularAcceleration z[3] "angular acceleration";

      public
        Interfaces.Frame_b frame_b annotation (extent=[100,-20; 120,20]);
        annotation (Icon(
            Text(extent=[-114,130; 116,72], string="%name"),
            Ellipse(extent=[-70,68; 70,-70], style(
                color=3,
                rgbcolor={0,0,255},
                gradient=3,
                fillColor=71,
                rgbfillColor={85,170,255})),
            Ellipse(extent=[-18,18; 18,-18], style(
                pattern=0,
                fillColor=10,
                rgbfillColor={95,95,95},
                fillPattern=1)),
            Ellipse(extent=[-42,42; 42,-42], style(
                pattern=0,
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[-100,-70; 100,-70], style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2)),
            Text(
              extent=[128,-116; -104,-76],
              style(color=0),
              string="r=%r"),
            Line(points=[98,0; 20,0], style(
                color=0,
                rgbcolor={0,0,0},
                gradient=3,
                fillColor=5,
                rgbfillColor={255,0,255})),
            Ellipse(extent=[-18,18; 18,-18], style(
                pattern=0,
                fillColor=10,
                rgbfillColor={95,95,95},
                fillPattern=1))), Diagram,
          Documentation(info="<html>
This is the model of a wheel.
The movement of the wheel is restricted to be ideally rolling on a straight plane.
The model is composed out of the corresponding rudimental joint model and the body model.
<p>
<img src=\"../Images/Wheel.png\">
</p>
<h3>General parameter</h3>
The mass of the wheel can be specified by the parameter m.
<p>
The inertia tensor of the wheel is a symmetric 3x3 matrix and can be specified by the parameters I11, I12, ...
<p>
The radius of the wheel can be defined by the parameter r.
<p>
The rolling plane can be specified by the vector n (pointing upwards) and the distance of the  plane
from the origin d.
<p>
The parameter animation toggles the visualization
<h3>Initialization</h3>
In general, you can specify...
<ul>
<li>...the initial position and orientation.
<li>...the initial velocity and angular velocity.
<li>...the initial acceleration and angular acceleration.
</ul>
Which of these variables do effectively appear in the inital equations can be defined by the parameter initType and useTransVelocity.
<p>
The ideal rolling restricts the wheel's position on the plane and the statement of the initial position is overdetermined. Therefore the initial position is automatically projected on the rolling plane.
<p>
The ideal rolling restricts the wheel's movement. The initial velocities and angular velocities form an overdetermined initial statement.<br>
By the activation of useTransVelocity, all velocities are defined by the translational movement on the plane and the rotation around the plane's normal vector.
Otherwise all initial angular velocities are taken to define the initial movement.
<h3>Visualization</h3>
A full animation of the wheel is supported.
Color and basic geometry can be changed by the corresponding parameters.
<h3>Advanced settings</h3>
The activation of enforceStates enforces the model to explicitely define integrators.
This parameter is useful to choose the state variables in a kinematic loop.
<p>
The orientation can either be expressed by the three cardan angles or by quaternions.
<ul>
<li>The usage of cardan angles leads to a faster computation but contains a singular point. It is therefore of limited applicability.
<li> The usage of quaternions leads to a robust solution, but it generates the need for a dynamic state selection and leads to non-linear equations.
</ul>
<p>
Which of these two variants is used, can be specified by the parameter useQuaternions.
</html>"));
        WheelJoint WheelJoint1(
          animation=animation,
          r=r,
          n=n,
          d=d,
          rRim=rRim,
          wWheel=wWheel,
          tireColor=tireColor,
          rodColor=rodColor,
          contactColor=contactColor)
               annotation (extent=[20,-28; 40,-8]);
        Parts.Body WheelBody(
          animation=false,
          m=m,
          I_11=I_11,
          I_22=I_22,
          I_33=I_33,
          I_21=I_21,
          I_31=I_31,
          I_32=I_32,
          initType=Modelica.Mechanics.MultiBody.Types.Init.Free,
          enforceStates=false,
          useQuaternions=useQuaternions,
          sequence_angles={2,1,3})
                         annotation (extent=[40,12; 20,32]);
      initial equation
        if initType == MB.Types.Init.Position or initType == MB.Types.Init.
            PositionVelocity or initType == MB.Types.Init.PositionVelocityAcceleration then
          // Initialize positional variables
          xA = x_start*WheelJoint1.eA;
          xB = x_start*WheelJoint1.eB;
          if useQuaternions then
            Q[1:3] = Q_start[1:3];
          else
            phi = phi_start_rad;
          end if;
        end if;

        if initType == MB.Types.Init.PositionVelocity or initType == MB.Types.Init.
            PositionVelocityAcceleration or initType == MB.Types.Init.Velocity or
            initType == MB.Types.Init.VelocityAcceleration then
          // Initialize velocity variables
          if useTransVelocities then
            v*WheelJoint1.eA = v_start*WheelJoint1.eA;
            v*WheelJoint1.eB = v_start*WheelJoint1.eB;
            w*WheelJoint1.eN = w_start_rad*WheelJoint1.eN;
          else
            w = w_start_rad;
          end if;
        end if;

        if initType == MB.Types.Init.VelocityAcceleration or initType == MB.Types.Init.
            PositionVelocityAcceleration then
          // Initialize acceleration variables
          if useTransVelocities then
            a*WheelJoint1.eA = a_start*WheelJoint1.eA;
            a*WheelJoint1.eB = a_start*WheelJoint1.eB;
            z*WheelJoint1.eN = z_start_rad*WheelJoint1.eN;
          else
            z = z_start_rad;
          end if;
        end if;

        if initType == MB.Types.Init.SteadyState then
          w = zeros(3);
          z = zeros(3);
        end if;

      equation
        x = WheelBody.PotentialFBM1.x;
        v = WheelBody.PotentialFBM1.v;
        a = WheelBody.PotentialFBM1.a;
        phi = WheelBody.PotentialFBM1.phi;
        phi_d = WheelBody.PotentialFBM1.phi_d;
        Q = WheelBody.PotentialFBM1.Q;
        w = WheelBody.PotentialFBM1.w;
        z = WheelBody.PotentialFBM1.z;

        xA = x*WheelJoint1.eA;
        xB = x*WheelJoint1.eB;

        connect(WheelBody.frame_a, frame_b)
                                        annotation (points=[41,22; 72,22; 72,0;
              110,0],
            style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=71,
            rgbfillColor={85,170,255},
            fillPattern=1));
        connect(WheelJoint1.frame_b, frame_b) annotation (points=[41,-18; 72,
              -18; 72,0; 110,0],            style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=71,
            rgbfillColor={85,170,255},
            fillPattern=1));
      end Wheel;

      model Marble "complete model of a marble"
        import SI = Modelica.SIunits;
        import MB = Modelica.Mechanics.MultiBody;
        import Cv = Modelica.SIunits.Conversions;

        parameter Boolean animation = true "animate marble";

        parameter SI.Radius r=1 "radius of wheel";
        parameter Real n[3] = {0,1,0}
          "vector normal to rolling plane, pointing upwards"                             annotation(Evaluate=true);
        parameter SI.Distance d=0 "distance of rolling plane o origin";

        parameter SI.Mass m = 1 "mass of body";

        parameter SI.Inertia I_11=0.001
          "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (1,1) element of inertia tensor"
                                                                                                              annotation(Evaluate=true);
        parameter SI.Inertia I_22=0.001
          "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (2,2) element of inertia tensor"
                                                                                                              annotation(Evaluate=true);
        parameter SI.Inertia I_33=0.001
          "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (3,3) element of inertia tensor"
                                                                                                              annotation(Evaluate=true);
        parameter SI.Inertia I_21=0
          "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (2,1) element of inertia tensor"
                                                                                                              annotation(Evaluate=true);
        parameter SI.Inertia I_31=0
          "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (3,1) element of inertia tensor"
                                                                                                              annotation(Evaluate=true);
        parameter SI.Inertia I_32=0
          "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (3,2) element of inertia tensor"
                                                                                                              annotation(Evaluate=true);
        final parameter SI.Inertia Inert[3, 3]=[I_11, I_21, I_31; I_21, I_22, I_32;
            I_31, I_32, I_33] "inertia tensor"
                                              annotation(Evaluate=true);

        parameter MB.Types.Init.Temp initType=MB.Types.Init.Free
          "|Initialization|| Type of initialization (defines usage of start values below)";
        parameter Boolean useTransVelocities = false
          "|Initialization|| use the translational velocities (defines usage of start values below)";
        parameter Cv.NonSIunits.Angle_deg phi_start[3] = {0,0,0}
          "|Initialization||initial cardan angles in degree";
        parameter Types.AngularVelocity_deg w_start[3] = {0,0,0}
          "|Initialization||initial angular velocity in deg/s";
        parameter Types.AngularAcceleration_deg z_start[3] = {0,0,0}
          "|Initialization||initial angular acceleration in deg/s2";
        parameter SI.Position x_start[3] = {0,0,0}
          "|Initialization||initial position";
        parameter SI.Velocity v_start[3] = {0,0,0}
          "|Initialization||initial velocity";
        parameter SI.Acceleration a_start[3] = {0,0,0}
          "|Initialization||initial acceleration";

        final parameter SI.Angle phi_start_rad[3] = Cv.from_deg(phi_start)
          "initial cardan angles";
        final parameter SI.AngularVelocity w_start_rad[3] = Cv.from_deg(w_start)
          "initial angular velocity";
        final parameter SI.AngularAcceleration z_start_rad[3] = Cv.from_deg(z_start)
          "initial angular acceleration";

        parameter Boolean enforceStates =  false
          "|Advanced||enforce Quaternions or cardan angles and w as states";
        parameter Boolean useQuaternions =  false
          "|Advanced||use Quaternions instead of cardan angles";
        final parameter Types.RotationSequence sequence_angles = {2,1,3}
          "|Advanced||sequence of the cardan angles";
        final parameter Types.Quaternion Q_start = Utilities.AxesRotQ(phi_start_rad,sequence_angles);

        SI.Position xA(stateSelect=if enforceStates then StateSelect.always else StateSelect.prefer)
          "Position in direction of eA";

        SI.Position xB(stateSelect=if enforceStates then StateSelect.always else StateSelect.prefer)
          "Position in direction of eB";

        SI.Position x[3] "Position of the frame";
        SI.Velocity v[3] "Velocity";

        Types.Quaternion Q(stateSelect=if useQuaternions then StateSelect.prefer else StateSelect.never,start = Q_start, fixed = false)
          "quaternions";
        SI.Angle phi[3](stateSelect=if not useQuaternions then (if enforceStates then
                        StateSelect.always else StateSelect.prefer) else  StateSelect.never)
          "cardan angles";
        SI.Angle phi_d[3](stateSelect=if not useQuaternions then (if enforceStates then
                        StateSelect.always else StateSelect.prefer) else  StateSelect.never)
          "cardan angles derivatives";
        SI.AngularVelocity w[3](stateSelect=if useQuaternions then (if enforceStates then
                        StateSelect.always else StateSelect.prefer) else  StateSelect.default)
          "angular velocity";

        SI.Acceleration a[3] "Acceleration";
        SI.AngularAcceleration z[3] "angular acceleration";

      public
        Interfaces.Frame_b frame_b annotation (extent=[100,-20; 120,20]);
        annotation (Icon(
            Text(extent=[-114,130; 116,72], string="%name"),
            Ellipse(extent=[-70,68; 70,-70], style(
                color=3,
                rgbcolor={0,0,255},
                gradient=3,
                fillColor=71,
                rgbfillColor={85,170,255})),
            Ellipse(extent=[-18,18; 18,-18], style(
                pattern=0,
                fillColor=10,
                rgbfillColor={95,95,95},
                fillPattern=1)),
            Line(points=[-100,-70; 100,-70], style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2)),
            Text(
              extent=[128,-116; -104,-76],
              style(color=0),
              string="r=%r"),
            Line(points=[98,0; 20,0], style(
                color=0,
                rgbcolor={0,0,0},
                gradient=3,
                fillColor=5,
                rgbfillColor={255,0,255})),
            Ellipse(extent=[-18,18; 18,-18], style(
                pattern=0,
                fillColor=10,
                rgbfillColor={95,95,95},
                fillPattern=1))), Diagram,
          Documentation(info="<html>
This is the model of a marble.
The movement of the marble is restricted to be ideally rolling on a straight plane.
The model is composed out of the corresponding rudimental joint model and the body model.
<p>
<img src=\"../Images/Marble.png\">
</p>
<h3>General parameter</h3>
The mass of the marble can be specified by the parameter m.
<p>
The inertia tensor of the marble is a symmetric 3x3 matrix and can be specified by the parameters I11, I12, ...
<p>
The radius of the marble can be defined by the parameter r.
<p>
The rolling plane can be specified by the vector n (pointing upwards) and the distance of the  plane
from the origin d.
<p>
The parameter animation toggles the visualization
<h3>Initialization</h3>
In general, you can specify...
<ul>
<li>...the initial position and orientation.
<li>...the initial velocity and angular velocity.
<li>...the initial acceleration and angular acceleration.
</ul>
Which of these variables do effectively appear in the inital equations can be defined by the parameter initType and useTransVelocity.
<p>
The ideal rolling restricts the marble's position on the plane and the statement of the initial position is overdetermined. Therefore the initial position is automatically projected on the rolling plane.
<p>
The ideal rolling restricts the marble's movement. The initial velocities and angular velocities form an overdetermined initial statement.<br>
By the activation of useTransVelocity, all velocities are defined by the translational movement on the plane and the rotation around the plane's normal vector.
Otherwise all initial angular velocities are taken to define the initial movement.
<h3>Visualization</h3>
The element is visualized by a blue sphere with magenta stripes.
<h3>Advanced settings</h3>
The activation of enforceStates enforces the model to explicitely define integrators.
This parameter is useful to choose the state variables in a kinematic loop.
<p>
The orientation can either be expressed by the three cardan angles or by quaternions.
<ul>
<li>The usage of cardan angles leads to a faster computation but contains a singular point. It is therefore of limited applicability.
<li> The usage of quaternions leads to a robust solution, but it generates the need for a dynamic state selection and leads to non-linear equations.
</ul>
<p>
Which of these two variants is used, can be specified by the parameter useQuaternions.
</html>"));
        Parts.Body WheelBody(
          animation=false,
          m=m,
          I_11=I_11,
          I_22=I_22,
          I_33=I_33,
          I_21=I_21,
          I_31=I_31,
          I_32=I_32,
          initType=Modelica.Mechanics.MultiBody.Types.Init.Free,
          enforceStates=false,
          useQuaternions=useQuaternions,
          sequence_angles={2,1,3})
                         annotation (extent=[40,12; 20,32]);
        MarbleJoint MarbleJoint1 annotation (extent=[20,-28; 40,-8]);
      initial equation
        if initType == MB.Types.Init.Position or initType == MB.Types.Init.
            PositionVelocity or initType == MB.Types.Init.PositionVelocityAcceleration then
          // Initialize positional variables
          xA = x_start*MarbleJoint1.eA;
          xB = x_start*MarbleJoint1.eB;
          if useQuaternions then
            Q[1:3] = Q_start[1:3];
          else
            phi = phi_start_rad;
          end if;
        end if;

        if initType == MB.Types.Init.PositionVelocity or initType == MB.Types.Init.
            PositionVelocityAcceleration or initType == MB.Types.Init.Velocity or
            initType == MB.Types.Init.VelocityAcceleration then
          // Initialize velocity variables
          if useTransVelocities then
            v*MarbleJoint1.eA = v_start*MarbleJoint1.eA;
            v*MarbleJoint1.eB = v_start*MarbleJoint1.eB;
            w*MarbleJoint1.eN = w_start_rad*MarbleJoint1.eN;
          else
            w = w_start_rad;
          end if;
        end if;

        if initType == MB.Types.Init.VelocityAcceleration or initType == MB.Types.Init.
            PositionVelocityAcceleration then
          // Initialize acceleration variables
          if useTransVelocities then
            a*MarbleJoint1.eA = a_start*MarbleJoint1.eA;
            a*MarbleJoint1.eB = a_start*MarbleJoint1.eB;
            z*MarbleJoint1.eN = z_start_rad*MarbleJoint1.eN;
          else
            z = z_start_rad;
          end if;
        end if;

        if initType == MB.Types.Init.SteadyState then
          w = zeros(3);
          z = zeros(3);
        end if;

      equation
        x = WheelBody.PotentialFBM1.x;
        v = WheelBody.PotentialFBM1.v;
        a = WheelBody.PotentialFBM1.a;
        phi = WheelBody.PotentialFBM1.phi;
        phi_d = WheelBody.PotentialFBM1.phi_d;
        Q = WheelBody.PotentialFBM1.Q;
        w = WheelBody.PotentialFBM1.w;
        z = WheelBody.PotentialFBM1.z;

        xA = x*MarbleJoint1.eA;
        xB = x*MarbleJoint1.eB;

        connect(WheelBody.frame_a, frame_b)
                                        annotation (points=[41,22; 72,22; 72,0;
              110,0],
            style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=71,
            rgbfillColor={85,170,255},
            fillPattern=1));
        connect(MarbleJoint1.frame_b, frame_b) annotation (points=[41,-18; 54,
              -18; 54,-16; 72,-16; 72,0; 110,0], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
      end Marble;
      annotation (preferedView="info", Documentation(info="<html>
This package contains models of ideal rolling marbles and wheels.
<p>
The models exist in two variants: as complete models or as rudimental joint models.
<p>
The complete models, represent the wheel or marble as complete object with mass and potential movement joints.
They also contain all parameters for initialization.
<p>
The rudimental joint models just model the movement constraints of the ideal rolling.
They have to be connected to body and joint models.
</html>"));
    end RollingObjects;

    package MechSensors "Sensor elements"
                                     extends Modelica.Icons.Library;
      model CutForce "Measures the cut force"

        import SI = Modelica.SIunits;

        Interfaces.Frame_a frame_a annotation (extent=[-120,-20; -100,20]);
        Interfaces.Frame_b frame_b annotation (extent=[100,-20; 120,20]);
        Modelica.Blocks.Interfaces.RealOutput force[3](redeclare each type
            SignalType = SI.Force) "Cut force"
             annotation (extent=[-10,-100; 10,-120],    rotation=90);
        annotation (Icon(
            Ellipse(extent=[-70,70; 70,-70],   style(color=0, fillColor=7)),
            Line(points=[0,70; 0,46], style(color=10, rgbcolor={95,95,95})),
            Line(points=[26,38; 40.2,57.3], style(color=10, rgbcolor={95,95,95})),
            Line(points=[-26,38; -40.2,57.3], style(color=10, rgbcolor={95,95,
                    95})),
            Line(points=[44,16; 65.8,23.9], style(color=10, rgbcolor={95,95,95})),
            Line(points=[-46,16; -65.8,23.9], style(color=10, rgbcolor={95,95,
                    95})),
            Line(points=[0,0; 9.02,28.6],   style(color=0)),
            Polygon(points=[2,32; 16,26; 20,58; 2,32], style(
                color=0,
                rgbcolor={0,0,0},
                fillColor=10,
                rgbfillColor={95,95,95},
                fillPattern=1)),
            Ellipse(extent=[-5,5; 5,-5],   style(
                color=0,
                gradient=0,
                fillColor=0,
                fillPattern=1)),
            Line(points=[-70,0; -101,0],   style(color=0)),
            Line(points=[70,0; 100,0],   style(color=0)),
            Text(extent=[-128,78; 133,126],   string="%name"),
               Text(
              extent=[-58,-68; 58,-94],
              string="force",
              style(color=10, rgbcolor={95,95,95}))), Diagram,
          Documentation(info="<html>
This sensor element measures the force that acts from frame a to frame b.
<p>
The force is resolved in the inertial system.
</html>"));
        Sensors.De de annotation (extent=[-10,-20; 10,0], rotation=270);
        Bonds.MultiBond multiBond annotation (extent=[-30,20; -10,40]);
        Bonds.MultiBond multiBond1 annotation (extent=[40,20; 60,40]);
        Interfaces.MBG2Mech mBG2Mech annotation (extent=[60,-40; 80,40]);
        Interfaces.Mech2MBG mech2MBG annotation (extent=[-80,-40; -60,40]);
        inner Defaults MBG_defaults(n=3) annotation (extent=[-80,60; -60,80]);
        Bonds.Utilities.MultiBondTail multiBondTail
          annotation (extent=[-58,20; -28,40]);
        Bonds.Utilities.MultiBondTail multiBondTail1
          annotation (extent=[10,20; 42,40]);
        Bonds.MultiBond multiBond2
          annotation (extent=[-10,0; 10,20], rotation=270);
        Bonds.MultiBond multiBond3 annotation (extent=[40,-40; 60,-20]);
        Junctions.J0 j0_1 annotation (extent=[-10,20; 10,40]);
        Bonds.Utilities.MultiBondTail multiBondTail2
          annotation (extent=[-60,-40; 42,-20]);
      equation
        defineBranch(frame_a.P,frame_b.P);
        connect(mech2MBG.frame_a, frame_a) annotation (points=[-79,0; -110,0],
            style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=10,
            rgbfillColor={95,95,95},
            fillPattern=1));
        connect(mBG2Mech.frame_b, frame_b) annotation (points=[79,0; 110,0],
            style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=10,
            rgbfillColor={95,95,95},
            fillPattern=1));
        connect(multiBond.MultiBondCon1, mech2MBG.MultiBondConTrans)
          annotation (points=[-30,30; -60,30], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=10,
            rgbfillColor={95,95,95},
            fillPattern=1));
        connect(multiBond1.MultiBondCon2, mBG2Mech.MultiBondConTrans)
          annotation (points=[60,30; 60,30], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=10,
            rgbfillColor={95,95,95},
            fillPattern=1));
        connect(de.MultiBondCon1, multiBond2.MultiBondCon2) annotation (points=[
              1.83691e-015,0; -1.83691e-015,0],  style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=10,
            rgbfillColor={95,95,95},
            fillPattern=1));
        connect(de.e_out, force) annotation (points=[-1.83691e-015,-20; 0,-20;
              0,-110], style(
            color=3,
            rgbcolor={0,0,255},
            fillColor=10,
            rgbfillColor={95,95,95},
            fillPattern=1));
        connect(multiBond3.MultiBondCon2, mBG2Mech.MultiBondConRot) annotation (
           points=[60,-30; 60,-30], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=10,
            rgbfillColor={95,95,95},
            fillPattern=1));
        connect(mech2MBG.R, mBG2Mech.R) annotation (points=[-60,-10; -22,-10;
              -22,-24; 22,-24; 22,-10; 60,-10], style(color=3, rgbcolor={0,0,
                255}));
        connect(mech2MBG.x, mBG2Mech.x) annotation (points=[-60,10; -20,10; -20,
              -22; 20,-22; 20,10; 60,10], style(color=3, rgbcolor={0,0,255}));
        connect(multiBond3.MultiBondCon1, mech2MBG.MultiBondConRot) annotation (
           points=[40,-30; -59.8,-30], style(color=71, rgbcolor={85,170,255}));
        connect(j0_1.MultiBondCon2, multiBond1.MultiBondCon1) annotation (
            points=[10,30; 40,30], style(color=71, rgbcolor={85,170,255}));
        connect(j0_1.MultiBondCon1, multiBond.MultiBondCon2) annotation (points=
             [-10,30; -10,30], style(color=71, rgbcolor={85,170,255}));
        connect(j0_1.MultiBondCon3, multiBond2.MultiBondCon1) annotation (
            points=[0,20; 0,22; -4.69266e-022,22; -4.69266e-022,20;
              1.83691e-015,20], style(color=71, rgbcolor={85,170,255}));
      end CutForce;

      model CutTorque "Measures the cut torque"

        import SI = Modelica.SIunits;

        Interfaces.Frame_a frame_a annotation (extent=[-120,-20; -100,20]);
        Interfaces.Frame_b frame_b annotation (extent=[100,-20; 120,20]);
        Modelica.Blocks.Interfaces.RealOutput torque[3](redeclare each type
            SignalType = SI.Force) "Cut torque"
             annotation (extent=[-10,-100; 10,-120],    rotation=90);
        annotation (Icon(
            Ellipse(extent=[-70,70; 70,-70],   style(color=0, fillColor=7)),
            Line(points=[0,70; 0,46], style(color=10, rgbcolor={95,95,95})),
            Line(points=[26,38; 40.2,57.3], style(color=10, rgbcolor={95,95,95})),
            Line(points=[-26,38; -40.2,57.3], style(color=10, rgbcolor={95,95,
                    95})),
            Line(points=[44,16; 65.8,23.9], style(color=10, rgbcolor={95,95,95})),
            Line(points=[-46,16; -65.8,23.9], style(color=10, rgbcolor={95,95,
                    95})),
            Line(points=[0,0; 9.02,28.6],   style(color=0)),
            Polygon(points=[2,32; 16,26; 20,58; 2,32], style(
                color=0,
                rgbcolor={0,0,0},
                fillColor=10,
                rgbfillColor={95,95,95},
                fillPattern=1)),
            Ellipse(extent=[-5,5; 5,-5],   style(
                color=0,
                gradient=0,
                fillColor=0,
                fillPattern=1)),
            Line(points=[-70,0; -101,0],   style(color=0)),
            Line(points=[70,0; 100,0],   style(color=0)),
            Text(extent=[-128,78; 133,126],   string="%name"),
               Text(
              extent=[-58,-68; 58,-94],
              style(color=10, rgbcolor={95,95,95}),
              string="torque")), Diagram,
          Documentation(info="<html>
This sensor element measures the torque that acts from frame a to frame b.
<p>
The torque is resolved in the inertial system.
</html>"));
        Sensors.De de annotation (extent=[-10,-80; 10,-60], rotation=270);
        Bonds.MultiBond multiBond annotation (extent=[-30,-40; -10,-20]);
        Bonds.MultiBond multiBond1 annotation (extent=[40,-40; 60,-20]);
        Junctions.J0 j0_1 annotation (extent=[-10,-40; 10,-20]);
        Interfaces.MBG2Mech mBG2Mech annotation (extent=[60,-40; 80,40]);
        Interfaces.Mech2MBG mech2MBG annotation (extent=[-80,-40; -60,40]);
        inner Defaults MBG_defaults(n=3) annotation (extent=[-80,60; -60,80]);
        Bonds.Utilities.MultiBondTail multiBondTail1
          annotation (extent=[-60,-40; -28,-20]);
        Bonds.MultiBond multiBond2
          annotation (extent=[-10,-60; 10,-40], rotation=270);
        Bonds.MultiBond multiBond3 annotation (extent=[40,20; 60,40]);
        Bonds.Utilities.MultiBondTail multiBondTail2
          annotation (extent=[10,-40; 42,-20]);
        Bonds.Utilities.MultiBondTail multiBondTail3
          annotation (extent=[-60,20; 42,40]);
      equation
        defineBranch(frame_a.P,frame_b.P);
        connect(mech2MBG.frame_a, frame_a) annotation (points=[-79,0; -110,0],
            style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=10,
            rgbfillColor={95,95,95},
            fillPattern=1));
        connect(mBG2Mech.frame_b, frame_b) annotation (points=[79,0; 110,0],
            style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=10,
            rgbfillColor={95,95,95},
            fillPattern=1));
        connect(multiBond1.MultiBondCon1, j0_1.MultiBondCon2) annotation (
            points=[40,-30; 10,-30], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=10,
            rgbfillColor={95,95,95},
            fillPattern=1));
        connect(multiBond.MultiBondCon2, j0_1.MultiBondCon1) annotation (points=[-10,-30;
              -10,-30],          style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=10,
            rgbfillColor={95,95,95},
            fillPattern=1));
        connect(de.MultiBondCon1, multiBond2.MultiBondCon2) annotation (points=[
              1.83691e-015,-60; -1.83691e-015,-60],  style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=10,
            rgbfillColor={95,95,95},
            fillPattern=1));
        connect(de.e_out, torque) annotation (points=[-1.83691e-015,-80; 0,-80;
              0,-110], style(
            color=3,
            rgbcolor={0,0,255},
            fillColor=10,
            rgbfillColor={95,95,95},
            fillPattern=1));
        connect(multiBond2.MultiBondCon1, j0_1.MultiBondCon3) annotation (
            points=[1.83691e-015,-40; 0,-40], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=10,
            rgbfillColor={95,95,95},
            fillPattern=1));
        connect(multiBond.MultiBondCon1, mech2MBG.MultiBondConRot) annotation (
            points=[-30,-30; -59.8,-30], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=10,
            rgbfillColor={95,95,95},
            fillPattern=1));
        connect(multiBond3.MultiBondCon2, mBG2Mech.MultiBondConTrans)
          annotation (points=[60,30; 60,30], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=10,
            rgbfillColor={95,95,95},
            fillPattern=1));
        connect(multiBond1.MultiBondCon2, mBG2Mech.MultiBondConRot) annotation (
           points=[60,-30; 60,-30], style(color=71, rgbcolor={85,170,255}));
        connect(mech2MBG.x, mBG2Mech.x) annotation (points=[-60,10; 60,10],
            style(color=3, rgbcolor={0,0,255}));
        connect(mBG2Mech.R, mech2MBG.R) annotation (points=[60,-10; -60,-10],
            style(color=3, rgbcolor={0,0,255}));
        connect(multiBond3.MultiBondCon1, mech2MBG.MultiBondConTrans)
          annotation (points=[40,30; -60,30], style(color=71, rgbcolor={85,170,
                255}));
      end CutTorque;

      model Power "Measures the power flow"

        import SI = Modelica.SIunits;

        Interfaces.Frame_a frame_a annotation (extent=[-120,-20; -100,20]);
        Interfaces.Frame_b frame_b annotation (extent=[100,-20; 120,20]);
        Modelica.Blocks.Interfaces.RealOutput power(redeclare each type
            SignalType = SI.Force) "power"
             annotation (extent=[-10,-100; 10,-120],    rotation=90);
        annotation (Icon(
            Ellipse(extent=[-70,70; 70,-70],   style(color=0, fillColor=7)),
            Line(points=[0,70; 0,46], style(color=10, rgbcolor={95,95,95})),
            Line(points=[26,38; 40.2,57.3], style(color=10, rgbcolor={95,95,95})),
            Line(points=[-26,38; -40.2,57.3], style(color=10, rgbcolor={95,95,
                    95})),
            Line(points=[44,16; 65.8,23.9], style(color=10, rgbcolor={95,95,95})),
            Line(points=[-46,16; -65.8,23.9], style(color=10, rgbcolor={95,95,
                    95})),
            Line(points=[0,0; 9.02,28.6],   style(color=0)),
            Polygon(points=[2,32; 16,26; 20,58; 2,32], style(
                color=0,
                rgbcolor={0,0,0},
                fillColor=10,
                rgbfillColor={95,95,95},
                fillPattern=1)),
            Ellipse(extent=[-5,5; 5,-5],   style(
                color=0,
                gradient=0,
                fillColor=0,
                fillPattern=1)),
            Line(points=[-70,0; -101,0],   style(color=0)),
            Line(points=[70,0; 100,0],   style(color=0)),
            Text(extent=[-128,78; 133,126],   string="%name"),
               Text(
              extent=[-58,-68; 58,-94],
              style(color=10, rgbcolor={95,95,95}),
              string="power")),  Diagram,
          Documentation(info="<html>
This sensor element measures the power that virtually flows from frame a to frame b.
</html>"));
        Bonds.MultiBond multiBond annotation (extent=[-88,-26; -76,-6]);
        Bonds.MultiBond multiBond1 annotation (extent=[76,-26; 88,-6]);
        Interfaces.MBG2Mech mBG2Mech annotation (extent=[88,-22; 100,22]);
        Interfaces.Mech2MBG mech2MBG annotation (extent=[-100,-22; -88,22]);
        inner Defaults MBG_defaults(n=3) annotation (extent=[-80,60; -60,80]);
        Bonds.MultiBond multiBond3 annotation (extent=[70,6; 88,26]);
        Bonds.MultiBond multiBond4 annotation (extent=[-58,6; -40,26]);
        Compositions.Composition composition
          annotation (extent=[-40,32; -30,-32]);
        Compositions.Composition composition1
          annotation (extent=[40,32; 30,-32]);
        Bonds.MultiBond multiBond5(n=6) annotation (extent=[10,-26; 30,-6]);
        Sensors.PMultiBond pMultiBond(n=6)
          annotation (extent=[-10,-6; -30,-26],rotation=180);
      public
        Passive.mTF_flow mTF_flow
          annotation (extent=[-76,-26; -58,-6],
                                              rotation=180);
      public
        Passive.mTF_effort mTF_effort annotation (extent=[58,-6; 76,-26]);
        Bonds.Utilities.MultiBondTail multiBondTail2
          annotation (extent=[42,6; 72,26]);
        Bonds.Utilities.MultiBondTail multiBondTail3
          annotation (extent=[-86,6; -56,26]);
        Bonds.MultiBond multiBond2 annotation (extent=[-58,-26; -40,-6]);
        Bonds.MultiBond multiBond6 annotation (extent=[40,-26; 58,-6]);
        Junctions.J1 j1_1(n=6) annotation (extent=[-10,-26; 10,-6]);
      equation
        defineBranch(frame_a.P,frame_b.P);
        connect(mech2MBG.frame_a, frame_a) annotation (points=[-99.4,0; -110,0],
                                                                style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=10,
            rgbfillColor={95,95,95},
            fillPattern=1));
        connect(mBG2Mech.frame_b, frame_b) annotation (points=[99.4,0; 110,0],
                                              style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=10,
            rgbfillColor={95,95,95},
            fillPattern=1));
        connect(multiBond1.MultiBondCon2, mBG2Mech.MultiBondConRot) annotation (
           points=[88,-16; 88,-16.5], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=10,
            rgbfillColor={95,95,95},
            fillPattern=1));
        connect(multiBond3.MultiBondCon2, mBG2Mech.MultiBondConTrans)
          annotation (points=[88,16; 88,16.5], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=10,
            rgbfillColor={95,95,95},
            fillPattern=1));
        connect(mech2MBG.MultiBondConTrans, multiBond4.MultiBondCon1)
          annotation (points=[-88,16.5; -88,16; -58,16],
                                                 style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=10,
            rgbfillColor={95,95,95},
            fillPattern=1));
        connect(composition1.MultiBondCon2, multiBond3.MultiBondCon1)
          annotation (points=[40,16; 70,16], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=10,
            rgbfillColor={95,95,95},
            fillPattern=1));
        connect(multiBond5.MultiBondCon2, composition1.MultiBondCon3)
          annotation (points=[30,-16; 30,-16], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=10,
            rgbfillColor={95,95,95},
            fillPattern=1));
        connect(pMultiBond.MultiBondCon1, composition.MultiBondCon3)
          annotation (points=[-30,-16; -30,-16],                   style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=10,
            rgbfillColor={95,95,95},
            fillPattern=1));
        connect(pMultiBond.P, power) annotation (points=[-20,-10; -20,-70; 0,
              -70; 0,-110],   style(
            color=3,
            rgbcolor={0,0,255},
            fillColor=10,
            rgbfillColor={95,95,95},
            fillPattern=1));
        connect(multiBond.MultiBondCon1, mech2MBG.MultiBondConRot) annotation (
            points=[-88,-16; -88,-16.5; -87.88,-16.5], style(color=71, rgbcolor=
               {85,170,255}));
        connect(multiBond4.MultiBondCon2, composition.MultiBondCon2)
          annotation (points=[-40,16; -40,16], style(color=71, rgbcolor={85,170,
                255}));
        connect(mTF_flow.MultiBondCon2, multiBond.MultiBondCon2) annotation (
            points=[-76,-16; -76,-16], style(color=71, rgbcolor={85,170,255}));
        connect(mech2MBG.R, mTF_flow.M) annotation (points=[-88,-5.5; -88,-6;
              -67,-6],         style(color=3, rgbcolor={0,0,255}));
        connect(multiBond2.MultiBondCon2, composition.MultiBondCon1)
          annotation (points=[-40,-16; -40.1,-16], style(color=71, rgbcolor={85,
                170,255}));
        connect(mTF_flow.MultiBondCon1, multiBond2.MultiBondCon1) annotation (
            points=[-58,-16; -58,-16], style(color=71, rgbcolor={85,170,255}));
        connect(mTF_effort.MultiBondCon2, multiBond1.MultiBondCon1) annotation (
           points=[76,-16; 76,-16], style(color=71, rgbcolor={85,170,255}));
        connect(multiBond6.MultiBondCon1, composition1.MultiBondCon1)
          annotation (points=[40,-16; 40.1,-16], style(color=71, rgbcolor={85,
                170,255}));
        connect(mTF_effort.MultiBondCon1, multiBond6.MultiBondCon2) annotation (
           points=[58,-16; 58,-16], style(color=71, rgbcolor={85,170,255}));
        connect(mTF_effort.M, mBG2Mech.R) annotation (points=[67,-6; 88,-6; 88,
              -5.5],               style(color=3, rgbcolor={0,0,255}));
        connect(j1_1.MultiBondCon2, multiBond5.MultiBondCon1) annotation (
            points=[10,-16; 10,-16], style(color=71, rgbcolor={85,170,255}));
        connect(j1_1.MultiBondCon1, pMultiBond.MultiBondCon2) annotation (
            points=[-10,-16; -10,-16], style(color=71, rgbcolor={85,170,255}));
        connect(mech2MBG.x, mBG2Mech.x) annotation (points=[-88,5.5; 0,5.5; 0,
              5.5; 88,5.5], style(color=3, rgbcolor={0,0,255}));
        connect(mech2MBG.R, mBG2Mech.R) annotation (points=[-88,-5.5; 88,-5.5],
            style(color=3, rgbcolor={0,0,255}));
      end Power;

      model AbsoluteSensor "Measures the absolute position and motion"

        import SI = Modelica.SIunits;

        parameter Boolean get_r_abs=true
          "= true, to measure the position vector from the origin of the world frame to the origin of frame_a in [m]";
        parameter Boolean get_v_abs=false
          "= true, to measure the absolute velocity of the origin of frame_a in [m/s]";
        parameter Boolean get_a_abs=false
          "= true, to measure the absolute acceleration of the origin of frame_a in [m/s^2]";
        parameter Boolean get_R=false
          "= true, to measure the 3 rotation angles to rotate the world frame into frame_a along the axes defined in 'sequence' below in [rad]";
        parameter Boolean get_w_abs=false
          "= true, to measure the absolute angular velocity of frame_a in [rad/s]";
        parameter Boolean get_z_abs=false
          "= true, to measure the absolute angular acceleration to frame_a in [rad/s^2]";

        final parameter Integer n_out = ((if get_r_abs then 3 else
                      0) + (if get_v_abs then 3 else 0) + (if get_a_abs then 3 else
                      0) + (if get_R then 9 else 0) + (if get_w_abs then 3 else
                      0) + (if get_z_abs then 3 else 0));

        Interfaces.Frame_a frame_a annotation (extent=[-120,-20; -100,20]);
        Modelica.Blocks.Interfaces.RealOutput out[n_out](redeclare each type
            SignalType =
              SI.Force)
             annotation (extent=[100,10; 120,-10],      rotation=0);
        annotation (Icon(
            Ellipse(extent=[-70,70; 70,-70],   style(color=0, fillColor=7)),
            Line(points=[0,70; 0,46], style(color=10, rgbcolor={95,95,95})),
            Line(points=[26,38; 40.2,57.3], style(color=10, rgbcolor={95,95,95})),
            Line(points=[-26,38; -40.2,57.3], style(color=10, rgbcolor={95,95,
                    95})),
            Line(points=[44,16; 65.8,23.9], style(color=10, rgbcolor={95,95,95})),
            Line(points=[-46,16; -65.8,23.9], style(color=10, rgbcolor={95,95,
                    95})),
            Line(points=[0,0; 9.02,28.6],   style(color=0)),
            Polygon(points=[2,32; 16,26; 20,58; 2,32], style(
                color=0,
                rgbcolor={0,0,0},
                fillColor=10,
                rgbfillColor={95,95,95},
                fillPattern=1)),
            Ellipse(extent=[-5,5; 5,-5],   style(
                color=0,
                gradient=0,
                fillColor=0,
                fillPattern=1)),
            Line(points=[-70,0; -101,0],   style(color=0)),
            Line(points=[70,0; 100,0],   style(color=0)),
            Text(extent=[-128,78; 133,126],   string="%name"),
               Text(
              extent=[-58,-68; 58,-94],
              string="force",
              style(color=10, rgbcolor={95,95,95}))), Diagram(
            Line(points=[-60,10; 20,10; 20,2; 100,2], style(
                color=3,
                rgbcolor={0,0,255},
                pattern=4)),
            Line(points=[-20,30; 40,30; 40,4; 100,4], style(
                color=3,
                rgbcolor={0,0,255},
                pattern=4)),
            Line(points=[22,50; 42,50; 60,50; 60,6; 100,6], style(
                color=3,
                rgbcolor={0,0,255},
                pattern=4)),
            Line(points=[-60,-10; 20,-10; 20,-2; 100,-2; 96,-2], style(
                color=3,
                rgbcolor={0,0,255},
                pattern=4)),
            Line(points=[20,-30; 40,-30; 40,-4; 102,-4], style(
                color=3,
                rgbcolor={0,0,255},
                pattern=4)),
            Line(points=[60,-50; 70,-50; 70,-6; 100,-6], style(
                color=3,
                rgbcolor={0,0,255},
                pattern=4))),
          Documentation(info="<html>
This sensor element measures the positional variables and their derivatives.
All these variables are resolved with respect to the inertial system.
<p>
The quantities are provided at the output signal connector <b>y</b>
in packed format in the order
</p>
<ol>
<li> absolute position vector (= r_abs)</li>
<li> absolute velocity vectory (= v_abs)</li>
<li> absolute acceleration vector (= a_abs)</li>
<li> 3 angles to rotate the world frame into frame_a (= angles)</li>
<li> absolute angular velocity vector (= w_abs)</li>
<li> absolute angular acceleration vector (= z_abs)</li>
</ol>
<p>
For example, if parameters <b>get_v</b> and <b>get_w</b>
are <b>true</b> and all other get_XXX parameters are <b>false</b>, then
y contains 6 elements:
</p>
<pre>
 y[1:3] = absolute velocity
 y[4:6] = absolute angular velocity
</pre>
</html>"));
      protected
        parameter Integer i1=1;
        parameter Integer i2=if get_r_abs then i1 + 3 else i1;
        parameter Integer i3=if get_v_abs then i2 + 3 else i2;
        parameter Integer i4=if get_a_abs then i3 + 3 else i3;
        parameter Integer i5=if get_R then i4 + 9 else i4;
        parameter Integer i6=if get_w_abs then i5 + 3 else i5;

        Bonds.MultiBond multiBond annotation (extent=[-60,20; -40,40]);
        Interfaces.Mech2MBG mech2MBG annotation (extent=[-80,-40; -60,40]);
        inner Defaults MBG_defaults(n=3) annotation (extent=[-80,60; -60,80]);
        Modelica.Blocks.Continuous.Der der_v[3]
          annotation (extent=[0,40; 20,60]);
        Bonds.MultiBond multiBond1
                                  annotation (extent=[-60,-40; -40,-20]);
        Modelica.Blocks.Continuous.Der der_w[3]
          annotation (extent=[40,-60; 60,-40]);
        Bonds.MultiBond multiBond2
                                  annotation (extent=[-20,-40; 0,-20]);
        Sensors.Df Df_v annotation (extent=[-40,20; -20,40]);
        Sensors.Df Df_w annotation (extent=[0,-40; 20,-20]);
        Passive.mTF_effort mTF_effort
          annotation (extent=[-40,-40; -20,-20], rotation=180);
      equation

        if get_r_abs then
          out[i1:i1 + 2] = mech2MBG.x;
        end if;

        if get_v_abs then
          out[i2:i2 + 2] = Df_v.f_out;
        end if;

        if get_a_abs then
          out[i3:i3 + 2] = der_v.y;
        end if;

        if get_R then
          out[i4:i4 + 2] = mech2MBG.R[1,1:3];
          out[i4+3:i4+5] = mech2MBG.R[2,1:3];
          out[i4+6:i4+8] = mech2MBG.R[3,1:3];
        end if;

        if get_w_abs then
          out[i5:i5 + 2] = Df_w.f_out;
        end if;

        if get_z_abs then
          out[i6:i6 + 2] = der_w.y;
        end if;

        connect(mech2MBG.frame_a, frame_a) annotation (points=[-79,0; -110,0],
            style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=10,
            rgbfillColor={95,95,95},
            fillPattern=1));
        connect(multiBond.MultiBondCon1, mech2MBG.MultiBondConTrans)
          annotation (points=[-60,30; -60,30], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=10,
            rgbfillColor={95,95,95},
            fillPattern=1));
        connect(multiBond1.MultiBondCon1, mech2MBG.MultiBondConRot) annotation (
           points=[-60,-30; -59.8,-30], style(color=71, rgbcolor={85,170,255}));
        connect(Df_v.f_out, der_v.u) annotation (points=[-20,30; -12,30; -12,50;
              -2,50], style(
            color=3,
            rgbcolor={0,0,255},
            pattern=0));
        connect(Df_w.MultiBondCon1, multiBond2.MultiBondCon2) annotation (
            points=[0,-30; 0,-30], style(
            color=71,
            rgbcolor={85,170,255},
            pattern=0));
        connect(Df_w.f_out, der_w.u) annotation (points=[20,-30; 28,-30; 28,-50;
              38,-50], style(
            color=3,
            rgbcolor={0,0,255},
            pattern=0));
        connect(mTF_effort.MultiBondCon2, multiBond1.MultiBondCon2) annotation (
           points=[-40,-30; -40,-30], style(
            color=71,
            rgbcolor={85,170,255},
            pattern=0));
        connect(mTF_effort.MultiBondCon1, multiBond2.MultiBondCon1) annotation (
           points=[-20,-30; -20,-30], style(
            color=71,
            rgbcolor={85,170,255},
            pattern=0));
        connect(mech2MBG.R, mTF_effort.M) annotation (points=[-60,-10; -30,-10;
              -30,-20], style(
            color=3,
            rgbcolor={0,0,255},
            pattern=0));
        connect(Df_v.MultiBondCon1, multiBond.MultiBondCon2) annotation (points=
             [-40,30; -40,30], style(
            color=71,
            rgbcolor={85,170,255},
            pattern=0));
      end AbsoluteSensor;

      model RelativeSensor "Measures the relative position and motion"

        import SI = Modelica.SIunits;

        parameter Boolean get_r_abs=true
          "= true, to measure the position vector from the origin of the world frame to the origin of frame_a in [m]";
        parameter Boolean get_v_abs=false
          "= true, to measure the absolute velocity of the origin of frame_a in [m/s]";
        parameter Boolean get_a_abs=false
          "= true, to measure the absolute acceleration of the origin of frame_a in [m/s^2]";
        parameter Boolean get_R=false
          "= true, to measure the 3 rotation angles to rotate the world frame into frame_a along the axes defined in 'sequence' below in [rad]";
        parameter Boolean get_w_abs=false
          "= true, to measure the absolute angular velocity of frame_a in [rad/s]";
        parameter Boolean get_z_abs=false
          "= true, to measure the absolute angular acceleration to frame_a in [rad/s^2]";

        final parameter Integer n_out = ((if get_r_abs then 3 else
                      0) + (if get_v_abs then 3 else 0) + (if get_a_abs then 3 else
                      0) + (if get_R then 9 else 0) + (if get_w_abs then 3 else
                      0) + (if get_z_abs then 3 else 0));

        Interfaces.Frame_a frame_a annotation (extent=[-120,-20; -100,20]);
        Modelica.Blocks.Interfaces.RealOutput out[n_out](redeclare each type
            SignalType =
              SI.Force)
             annotation (extent=[-10,-100; 10,-120],    rotation=90);
        annotation (Icon(
            Ellipse(extent=[-70,70; 70,-70],   style(color=0, fillColor=7)),
            Line(points=[0,70; 0,46], style(color=10, rgbcolor={95,95,95})),
            Line(points=[26,38; 40.2,57.3], style(color=10, rgbcolor={95,95,95})),
            Line(points=[-26,38; -40.2,57.3], style(color=10, rgbcolor={95,95,
                    95})),
            Line(points=[44,16; 65.8,23.9], style(color=10, rgbcolor={95,95,95})),
            Line(points=[-46,16; -65.8,23.9], style(color=10, rgbcolor={95,95,
                    95})),
            Line(points=[0,0; 9.02,28.6],   style(color=0)),
            Polygon(points=[2,32; 16,26; 20,58; 2,32], style(
                color=0,
                rgbcolor={0,0,0},
                fillColor=10,
                rgbfillColor={95,95,95},
                fillPattern=1)),
            Ellipse(extent=[-5,5; 5,-5],   style(
                color=0,
                gradient=0,
                fillColor=0,
                fillPattern=1)),
            Line(points=[-70,0; -101,0],   style(color=0)),
            Line(points=[70,0; 100,0],   style(color=0)),
            Text(extent=[-128,78; 133,126],   string="%name"),
               Text(
              extent=[-58,-68; 58,-94],
              string="force",
              style(color=10, rgbcolor={95,95,95}))), Diagram,
          Documentation(info="<html>
This sensor element measures the relative positional variables and their derivatives between
the two frames. All these variables are resolved with respect to the inertial system.
<p>
The quantities are provided at the output signal connector <b>y</b>
in packed format in the order
</p>
<ol>
<li> absolute position vector (= r_abs)</li>
<li> absolute velocity vectory (= v_abs)</li>
<li> absolute acceleration vector (= a_abs)</li>
<li> 3 angles to rotate the world frame into frame_a (= angles)</li>
<li> absolute angular velocity vector (= w_abs)</li>
<li> absolute angular acceleration vector (= z_abs)</li>
</ol>
<p>
For example, if parameters <b>get_v</b> and <b>get_w</b>
are <b>true</b> and all other get_XXX parameters are <b>false</b>, then
y contains 6 elements:
</p>
<pre>
 y[1:3] = absolute velocity
 y[4:6] = absolute angular velocity
</pre>
</html>"));
                                   annotation (extent=[100,-20; 120,20]);
      protected
        parameter Integer i1=1;
        parameter Integer i2=if get_r_abs then i1 + 3 else i1;
        parameter Integer i3=if get_v_abs then i2 + 3 else i2;
        parameter Integer i4=if get_a_abs then i3 + 3 else i3;
        parameter Integer i5=if get_R then i4 + 9 else i4;
        parameter Integer i6=if get_w_abs then i5 + 3 else i5;

        Bonds.MultiBond multiBond annotation (extent=[-30,20; -10,40]);
        Interfaces.Mech2MBG mech2MBG annotation (extent=[-100,-40; -80,40]);
        inner Defaults MBG_defaults(n=3) annotation (extent=[-80,60; -60,80]);
        Modelica.Blocks.Continuous.Der der_v[3]
          annotation (extent=[20,70; 40,90]);
        Bonds.MultiBond multiBond1
                                  annotation (extent=[-80,-40; -60,-20]);
        Modelica.Blocks.Continuous.Der der_w[3]
          annotation (extent=[-30,-90; -10,-70]);
        Bonds.MultiBond multiBond2
                                  annotation (extent=[60,-40; 80,-20]);
        Sensors.Df Df_v annotation (extent=[-10,60; 10,80], rotation=90);
        Sensors.Df Df_w annotation (extent=[-60,-80; -40,-60], rotation=270);
        Passive.mTF_effort mTF_effort
          annotation (extent=[0,-40; 20,-20],    rotation=180);
        Interfaces.MBG2Mech mBG2Mech annotation (extent=[80,-40; 100,40]);
      public
        Interfaces.Frame_b frame_b annotation (extent=[100,-20; 120,20]);
      protected
        Junctions.J0 j0_1 annotation (extent=[-10,20; 10,40]);
        Junctions.J0 j0_2 annotation (extent=[-60,-40; -40,-20]);

        Bonds.MultiBond multiBond3
                                  annotation (extent=[-10,40; 10,60], rotation=
              90);
        Bonds.MultiBond multiBond4
                                  annotation (extent=[60,20; 80,40]);
        Bonds.Utilities.MultiBondTail multiBondTail
          annotation (extent=[-80,20; -28,40]);
        Bonds.Utilities.MultiBondTail multiBondTail1
          annotation (extent=[12,20; 62,40]);

        Bonds.MultiBond multiBond5
                                  annotation (extent=[-20,-40; 0,-20]);
        Bonds.MultiBond multiBond6
                                  annotation (extent=[20,-40; 40,-20]);
        Passive.mTF_flow mTF_flow
          annotation (extent=[60,-40; 40,-20],rotation=180);
        Bonds.MultiBond multiBond7
                                  annotation (extent=[-60,-60; -40,-40],
            rotation=270);
        Bonds.Utilities.MultiBondTail multiBondTail2
          annotation (extent=[-40,-40; -18,-20]);
        Real Rrel[3,3];
      equation

        Rrel = mBG2Mech.R*transpose(mech2MBG.R);

        if get_r_abs then
          out[i1:i1 + 2] = mech2MBG.x-mBG2Mech.x;
        end if;

        if get_v_abs then
          out[i2:i2 + 2] = Df_v.f_out;
        end if;

        if get_a_abs then
          out[i3:i3 + 2] = der_v.y;
        end if;

        if get_R then
          out[i4:i4 + 2] = Rrel[1,1:3];
          out[i4+3:i4+5] = Rrel[2,1:3];
          out[i4+6:i4+8] = Rrel[3,1:3];
        end if;

        if get_w_abs then
          out[i5:i5 + 2] = Df_w.f_out;
        end if;

        if get_z_abs then
          out[i6:i6 + 2] = der_w.y;
        end if;

        connect(mech2MBG.frame_a, frame_a) annotation (points=[-99,0; -110,0],
            style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=10,
            rgbfillColor={95,95,95},
            fillPattern=1));
        connect(multiBond.MultiBondCon1, mech2MBG.MultiBondConTrans)
          annotation (points=[-30,30; -80,30], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=10,
            rgbfillColor={95,95,95},
            fillPattern=1));
        connect(multiBond1.MultiBondCon1, mech2MBG.MultiBondConRot) annotation (
           points=[-80,-30; -79.8,-30], style(color=71, rgbcolor={85,170,255}));
        connect(Df_v.f_out, der_v.u) annotation (points=[6.12303e-016,80; 18,80],
                      style(
            color=3,
            rgbcolor={0,0,255},
            pattern=0));
        connect(Df_w.f_out, der_w.u) annotation (points=[-50,-80; -32,-80],
                       style(
            color=3,
            rgbcolor={0,0,255},
            pattern=0));
        connect(mech2MBG.R, mTF_effort.M) annotation (points=[-80,-10; 10,-10;
              10,-20],  style(
            color=3,
            rgbcolor={0,0,255},
            pattern=0));
        connect(mBG2Mech.frame_b,frame_b)  annotation (points=[99,0; 110,0],
            style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=10,
            rgbfillColor={95,95,95},
            fillPattern=1));
        connect(multiBond3.MultiBondCon1, j0_1.MultiBondCon4) annotation (
            points=[-6.12303e-016,40; 0,40], style(color=71, rgbcolor={85,170,
                255}));
        connect(Df_v.MultiBondCon1, multiBond3.MultiBondCon2) annotation (
            points=[-6.12303e-016,60; 6.12303e-016,60], style(color=71,
              rgbcolor={85,170,255}));
        connect(multiBond4.MultiBondCon2, mBG2Mech.MultiBondConTrans)
          annotation (points=[80,30; 80,30], style(color=71, rgbcolor={85,170,
                255}));
        connect(multiBond4.MultiBondCon1, j0_1.MultiBondCon2) annotation (
            points=[60,30; 10,30], style(color=71, rgbcolor={85,170,255}));
        connect(multiBond2.MultiBondCon2, mBG2Mech.MultiBondConRot) annotation (
           points=[80,-30; 80,-30], style(color=71, rgbcolor={85,170,255}));
        connect(j0_2.MultiBondCon1, multiBond1.MultiBondCon2) annotation (
            points=[-60,-30; -60,-30], style(color=71, rgbcolor={85,170,255}));
        connect(multiBond5.MultiBondCon1, j0_2.MultiBondCon2) annotation (
            points=[-20,-30; -40,-30], style(color=71, rgbcolor={85,170,255}));
        connect(multiBond5.MultiBondCon2, mTF_effort.MultiBondCon2) annotation (
           points=[0,-30; 0,-30], style(color=71, rgbcolor={85,170,255}));
        connect(multiBond6.MultiBondCon1, mTF_effort.MultiBondCon1) annotation (
           points=[20,-30; 20,-30], style(color=71, rgbcolor={85,170,255}));
        connect(mTF_flow.MultiBondCon1, multiBond6.MultiBondCon2) annotation (
            points=[40,-30; 40,-30], style(color=71, rgbcolor={85,170,255}));
        connect(mTF_flow.MultiBondCon2, multiBond2.MultiBondCon1) annotation (
            points=[60,-30; 60,-30], style(color=71, rgbcolor={85,170,255}));
        connect(mTF_flow.M, mBG2Mech.R) annotation (points=[50,-20; 50,-10; 80,
              -10], style(color=3, rgbcolor={0,0,255}));
        connect(multiBond7.MultiBondCon1, j0_2.MultiBondCon3) annotation (
            points=[-50,-40; -50,-40], style(color=71, rgbcolor={85,170,255}));
        connect(Df_w.MultiBondCon1, multiBond7.MultiBondCon2) annotation (
            points=[-50,-60; -50,-60], style(color=71, rgbcolor={85,170,255}));
      end RelativeSensor;
    end MechSensors;

    package Types "additional type definitions specific for 3D-Mechanics"
        type Quaternion = Real[4];

        type RotationSequence = Integer[3] (min={1,1,1}, max={3,3,3})
        "Sequence of planar frame rotations with choices for menus"   annotation (
          preferedView="text",
          Evaluate=true,
          choices(
            choice={1,2,3} "{1,2,3} \"Cardan/Tait-Bryan angles\"",
            choice={3,1,3} "{3,1,3} \"Euler angles\"",
            choice={3,2,1} "{3,2,1}"));

      type AngularVelocity_deg = Real (final quantity="AngularVelocity", final unit
            =    "deg/s");

      type AngularAcceleration_deg = Real (final quantity="AngularAcceleration",
            final unit="deg/s2");

      annotation (Icon(
          Text(
            extent=[-120,122; 120,73],
            string="%name",
            style(color=45, rgbcolor={255,128,0})),
          Polygon(points=[-100,50; -80,70; 100,70; 80,50; -100,50], style(
              color=45,
              rgbcolor={255,128,0},
              fillColor=30,
              rgbfillColor={235,235,235},
              fillPattern=1)),
          Polygon(points=[100,70; 100,-80; 80,-100; 80,50; 100,70], style(
              color=45,
              rgbcolor={255,128,0},
              fillColor=30,
              rgbfillColor={235,235,235},
              fillPattern=1)),
          Rectangle(extent=[-100,-100; 80,50], style(
              color=45,
              rgbcolor={255,128,0},
              fillColor=30,
              rgbfillColor={235,235,235},
              fillPattern=1)),
          Text(
            extent=[-85,35; 65,-85],
            string="Library",
            style(color=45, rgbcolor={255,128,0}))), preferedView="info", Documentation(info="<html>
This package constains type definitions.
</html>"));
    end Types;

    package Utilities
      "useful internal elements and functions to create models of 3D-Mechanics"
      model GravityPool "gravity pool"

        import SI = Modelica.SIunits;

        annotation (
          Coordsys(
            extent=[-100, -100; 100, 100],
            grid=[2, 2],
            component=[20, 20]),
          Window(
            x=0.13,
            y=0.1,
            width=0.81,
            height=0.83),
          Icon(
            Rectangle(extent=[-100,102; 100,-98], style(
                pattern=0,
                fillColor=7,
                rgbfillColor={255,255,255})),
            Text(extent=[-140, 165; 140, 103], string="%name"),
            Line(points=[-56, 78; -56, -26], style(color=2, rgbcolor={0,255,0})),
            Line(points=[-40,-44; 30,-62], style(color=2, rgbcolor={0,255,0})),
            Line(points=[42,44; 42,-62], style(color=2, rgbcolor={0,255,0})),
            Text(
              extent=[-76,-104; 72,-128],
              string="%poolSize",
              style(color=0, rgbcolor={0,0,0})),
            Line(points=[-42,64; 28,46], style(color=2, rgbcolor={0,255,0})),
            Line(points=[-50,52; 34,-54], style(color=2, rgbcolor={0,255,0})),
            Line(points=[-52,-34; 40,26], style(color=2, rgbcolor={0,255,0})),
            Ellipse(extent=[-80,-22; -38,-62], style(
                pattern=0,
                gradient=3,
                fillColor=69,
                rgbfillColor={1,128,255})),
            Ellipse(extent=[22,-46; 64,-86], style(
                pattern=0,
                gradient=3,
                fillColor=69,
                rgbfillColor={1,128,255})),
            Ellipse(extent=[20,58; 62,18], style(
                pattern=0,
                gradient=3,
                fillColor=69,
                rgbfillColor={1,128,255})),
            Ellipse(extent=[-80,82; -38,42], style(
                pattern=0,
                gradient=3,
                fillColor=69,
                rgbfillColor={1,128,255}))),
          Diagram,
          Documentation(preferedView="info", info="<html>
This is the model of the gravity pool.
<p>
The gravity pool contains a finite set of bodies and applies the law of mutual
gravitational attraction on them.
<h3>Usage</h3>
To use the the gravity pool, set the parameter gravityPoolSize to the number
of bodies you'd like to have in your pool. Then give each body in the pool
a different index number from 1 to gravityPoolSize.
The index number can be set by the parameter GPindex of the body element.
<h3>Important note</h3>
The gravity pool is included in the world model. Don't use it from here! Use the world model!
</html>"));

        parameter Integer poolSize = 0;
        SI.Position pos[poolSize,3];
        SI.Mass mass[poolSize];

      public
        function gravityForce =
            gravityForce2 (poolSize=poolSize,
                                      pos=pos,
                                      mass=mass) annotation (Documentation(info=
               "<html>
An element of the gravity pool can call this function to find out the gravitational force at its position.
Therefore it has to call this function with its GPIndex as single parameter.
</html>"));

      protected
        function gravityForce2
          "Gravity field acceleration depending on field type and position"

          extends Modelica.Icons.Function;
          input Integer gravityPoolIndex
            "Index of the object the gravity is acting on";
          input Integer poolSize;
          input SI.Position pos[poolSize,3] "Pool of all positions";
          input SI.Mass mass[poolSize] "Pool of all masses";
          output SI.Force gF[3]
            "Gravity force for indeed object, resolved in world frame";
        protected
          SI.Position curPos[3];
          SI.Position myPos[3];
          SI.Position r[3];
          SI.Mass curMass;
          SI.Mass myMass;
          Real G = Modelica.Constants.G;
        algorithm
          gF := zeros(3);

         if gravityPoolIndex > 0 then
            curPos := zeros(3);
            r := zeros(3);
            myPos := pos[gravityPoolIndex,:];
            curMass := 0;
            myMass := mass[gravityPoolIndex];
            for i in 1:poolSize loop
               if i == gravityPoolIndex then
                 gF := gF + zeros(3);
              else
                 curMass := mass[i];
                 curPos := pos[i,:];
                 r := myPos-curPos;
                 gF := gF + ((G*curMass*myMass)/(r*r))*(-r/sqrt(r*r));
              end if;
            end for;
          end if;
        end gravityForce2;

      end GravityPool;
    annotation (Icon(
          Text(
            extent=[-120,120; 120,71],
            string="%name",
            style(color=42, rgbcolor={127,0,0})),
          Polygon(points=[-100,48; -80,68; 100,68; 80,48; -100,48],style(
              color=42,
              rgbcolor={127,0,0},
              fillColor=30,
              rgbfillColor={235,235,235},
              fillPattern=1)),
          Polygon(points=[100,68; 100,-82; 80,-102; 80,48; 100,68],
                                                                 style(
              color=42,
              rgbcolor={127,0,0},
              fillColor=30,
              rgbfillColor={235,235,235},
              fillPattern=1)),
          Rectangle(extent=[-100,-102; 80,48], style(
              color=42,
              rgbcolor={127,0,0},
              fillColor=30,
              rgbfillColor={235,235,235},
              fillPattern=1)),
          Text(
            extent=[-85,33; 65,-87],
            string="Library",
            style(color=42, rgbcolor={127,0,0}))), preferedView="info", Documentation(info="<html>
This package contains various elements of usage.
All these components are intented for internal usage only. Most of them care about the processing of the signals in the bondgraphic models.
</html>"));
      function AxesRotQ "computes a quaternion out of axes rotations"
          extends Modelica.Icons.Function;
        import SI = Modelica.SIunits;
        input SI.Angle phi[3] "3 cardan angles";
        input Types.RotationSequence seq_angles "sequence of axes";
        output Types.Quaternion Q
          "resulting quaternion describing the rotation";
      protected
        Types.Quaternion Q1;
        Types.Quaternion Q2;
        Types.Quaternion Q3;
      algorithm
        if seq_angles[1] == 1 then
          Q1 := {sin(phi[1]/2),0,0, cos(phi[1]/2)};
        end if;
        if seq_angles[2] == 1 then
          Q2 := {sin(phi[2]/2),0,0, cos(phi[2]/2)};
        end if;
        if seq_angles[3] == 1 then
          Q3 := {sin(phi[3]/2),0,0, cos(phi[3]/2)};
        end if;

        if seq_angles[1] == 2 then
          Q1 := {0,sin(phi[1]/2),0, cos(phi[1]/2)};
        end if;
        if seq_angles[2] == 2 then
          Q2 := {0,sin(phi[2]/2),0, cos(phi[2]/2)};
        end if;
        if seq_angles[3] == 2 then
          Q3 := {0,sin(phi[3]/2),0, cos(phi[3]/2)};
        end if;

        if seq_angles[1] == 3 then
          Q1 := {0,0,sin(phi[1]/2),cos(phi[1]/2)};
        end if;
        if seq_angles[2] == 3 then
          Q2 := {0,0,sin(phi[2]/2),cos(phi[2]/2)};
        end if;
        if seq_angles[3] == 3 then
          Q3 := {0,0,sin(phi[3]/2),cos(phi[3]/2)};
        end if;

        Q := MulQ(MulQ(Q1,Q2),Q3);

        annotation (Documentation(info="<html>
This function rotates around the three main axes and returns the resulting orientation as quaternion.
</html>"));
      end AxesRotQ;

      function MulQ "multiplies (rotates) quaternions"
          extends Modelica.Icons.Function;
        input Types.Quaternion Q1 "Q1";
        input Types.Quaternion Q2 "Q2";
        output Types.Quaternion Q "Product = Q1*Q2";
      algorithm
        Q[4] := (Q1[4]*Q2[4]) - (Q1[1:3]*Q2[1:3]);
        Q[1:3] := cross(Q1[1:3],Q2[1:3]) + (Q1[4]*Q2[1:3]) + (Q2[4]*Q1[1:3]);
        annotation (Documentation(info="<html>
This function multiplies (rotates) two quaternions.
</html>"));
      end MulQ;

      model cardanRotation
        "defines relation between the rotational matrix and the cardan angles"

        annotation (Icon(
            Rectangle(extent=[-80,80; 80,-80], style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
                         Text(
              extent=[-78,0; 80,80],
              style(color=3, rgbcolor={0,0,255}),
              string="cardan"),
            Line(points=[-92,0; -80,0], style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[92,0; 80,0], style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
                         Text(
              extent=[-80,-80; 80,0],
              style(color=3, rgbcolor={0,0,255}),
              string="Rotation"),
            Line(points=[-72,0; 68,0; 50,12], style(color=3, rgbcolor={0,0,255})),
            Line(points=[68,0; 50,-12], style(color=3, rgbcolor={0,0,255}))),
                                      Diagram,
          Documentation(info="<html>
This model transforms an orientation specified by three cardan angles phi into a rotation matrix Rrel.
<p>
The three rotation axes can be specified by the parameter sequence_angles
</html>"));
        MultiBondLib.Interfaces.RealSignal phi[3]
          annotation (extent=[-110,-10; -90,10]);
        MultiBondLib.Interfaces.RealSignal Rrel[3,3]
                                               annotation (extent=[90,-10; 110,10]);

        parameter Integer[3] sequence_angles(min={1,1,1}, max={3,3,3}) = {1,2,3};

      protected
        Real R1[3,3];
        Real R2[3,3];
        Real R3[3,3];

      equation
      //  Rx = [1,0,0;0,cos(phi[1]),sin(phi[1]);0,-sin(phi[1]),cos(phi[1])];
      //  Ry = [cos(phi[2]),0,-sin(phi[2]);0,1,0;sin(phi[2]),0,cos(phi[2])];
      //  Rz = [cos(phi[3]),sin(phi[3]),0;-sin(phi[3]),cos(phi[3]),0;0,0,1];
      //  Rrel = Rz*Ry*Rx;

        if sequence_angles[1] == 1 then
          R1 = [1,0,0;0,cos(phi[1]),sin(phi[1]);0,-sin(phi[1]),cos(phi[1])];
        end if;
        if sequence_angles[2] == 1 then
          R2 = [1,0,0;0,cos(phi[2]),sin(phi[2]);0,-sin(phi[2]),cos(phi[2])];
        end if;
        if sequence_angles[3] == 1 then
          R3 = [1,0,0;0,cos(phi[3]),sin(phi[3]);0,-sin(phi[3]),cos(phi[3])];
        end if;

        if sequence_angles[1] == 2 then
          R1 = [cos(phi[1]),0,-sin(phi[1]);0,1,0;sin(phi[1]),0,cos(phi[1])];
        end if;
        if sequence_angles[2] == 2 then
          R2 = [cos(phi[2]),0,-sin(phi[2]);0,1,0;sin(phi[2]),0,cos(phi[2])];
        end if;
        if sequence_angles[3] == 2 then
          R3 = [cos(phi[3]),0,-sin(phi[3]);0,1,0;sin(phi[3]),0,cos(phi[3])];
        end if;

        if sequence_angles[1] == 3 then
          R1 = [cos(phi[1]),sin(phi[1]),0;-sin(phi[1]),cos(phi[1]),0;0,0,1];
        end if;
        if sequence_angles[2] == 3 then
          R2 = [cos(phi[2]),sin(phi[2]),0;-sin(phi[2]),cos(phi[2]),0;0,0,1];
        end if;
        if sequence_angles[3] == 3 then
          R3 = [cos(phi[3]),sin(phi[3]),0;-sin(phi[3]),cos(phi[3]),0;0,0,1];
        end if;

        Rrel = R3*R2*R1;

      end cardanRotation;

      model planarRotation
        "defines relation between the rotational matrix and a planar rotation angle"

        annotation (Icon(
            Rectangle(extent=[-80,80; 80,-80], style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
                         Text(
              extent=[-60,0; 60,80],
              style(color=3, rgbcolor={0,0,255}),
              string="planar"),
            Line(points=[-92,0; -80,0], style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[92,0; 80,0], style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
                         Text(
              extent=[-80,-80; 80,0],
              style(color=3, rgbcolor={0,0,255}),
              string="Rotation"),
            Line(points=[-72,0; 68,0; 50,12], style(color=3, rgbcolor={0,0,255})),
            Line(points=[68,0; 50,-12], style(color=3, rgbcolor={0,0,255}))),
                                      Diagram,
          Documentation(info="<html>
This model transforms a planar rotation angle phi into a rotation matrix Rrel.
<p>
The rotation axis can be specified by the parameter n.
</html>"));
        MultiBondLib.Interfaces.RealSignal phi
          annotation (extent=[-110,-10; -90,10]);
        MultiBondLib.Interfaces.RealSignal Rrel[3,3]
                                               annotation (extent=[90,-10; 110,10]);

        parameter Real n[3] = {0,0,1} annotation(Evaluate=true);
      equation

       Rrel = [n]*transpose([n]) + (identity(3) - [n]*transpose([n]))*cos(phi) - skew(n)*sin(phi);

      end planarRotation;

      model quaternionRotation
        "defines relation between the rotational matrix and quaternions"

        annotation (Icon(
            Rectangle(extent=[-80,80; 80,-80], style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
                         Text(
              extent=[-78,0; 80,80],
              style(color=3, rgbcolor={0,0,255}),
              string="quaternion"),
            Line(points=[-92,0; -80,0], style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[92,0; 80,0], style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
                         Text(
              extent=[-80,-80; 80,0],
              style(color=3, rgbcolor={0,0,255}),
              string="Rotation"),
            Line(points=[-72,0; 68,0; 50,12], style(color=3, rgbcolor={0,0,255})),
            Line(points=[68,0; 50,-12], style(color=3, rgbcolor={0,0,255}))),
                                      Diagram,
          Documentation(info="<html>
This elements transforms an orientation specified by a quaternion Q into a transformation matrix Rrel.
</html>"));
        MultiBondLib.Interfaces.RealSignal Q[4]
          annotation (extent=[-110,-10; -90,10]);
        MultiBondLib.Interfaces.RealSignal Rrel[3,3]
                                               annotation (extent=[90,-10; 110,10]);

      protected
        Real u[3] = Q[1:3];
        Real c = Q[4];

      equation
       Rrel = 2*( ([u]*transpose([u])) -  c*skew(u) + (c*c*identity(3)))  - identity(3);

      //(identity(3) - [n]*transpose([n]))*cos(phi) - skew(n)*sin(phi);

      end quaternionRotation;

      model Rotation "rotates R1 by Rrel o R2 or the other way round"

        annotation (Icon(
            Rectangle(extent=[-80,80; 80,-80], style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
                         Text(
              extent=[-80,-80; 80,80],
              style(color=3, rgbcolor={0,0,255}),
              string="Rotation"),
            Line(points=[-92,0; -80,0], style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[92,0; 80,0], style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[-72,-40; 68,-40; 50,-28], style(color=3, rgbcolor={0,0,255})),
            Line(points=[68,-40; 50,-52], style(color=3, rgbcolor={0,0,255})),
            Line(points=[0,92; 0,80],     style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1))),     Diagram,
          Documentation(info="<html>
This model implements a relative rotation Rrel between the two orientations R1 and R2.
<p>
The boolean input signal dirForward determines the form of the statement.
<ul>
<li>R2 = Rrel*R1, if dirForward == true
<li>R1 = transpose(Rrel)*R1, if dirForward == false
</ul>
This influences the effiency of the resulting code.
</html>"));

        MultiBondLib.Interfaces.RealSignal R1[3,3]
          annotation (extent=[-110,-10; -90,10]);
        MultiBondLib.Interfaces.RealSignal R2[3,3]
          annotation (extent=[90,-10; 110,10]);
        MultiBondLib.Interfaces.RealSignal Rrel[3,3]
                                               annotation (extent=[-10,90; 10,110]);
        Modelica.Blocks.Interfaces.BooleanInput dirForward
          annotation (extent=[-50,94; -30,114], rotation=270);
      equation

        if dirForward then
            R2 = Rrel*R1;
        else
            R1 = transpose(Rrel)*R2;
        end if;

      end Rotation;

      model toCardanAngles
        "integrates the angular velocity into the cardan angles"
        import SI = Modelica.SIunits;

        annotation (Icon(
            Rectangle(extent=[-80,80; 80,-80], style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
                         Text(
              extent=[-80,28; 80,88],
              style(color=3, rgbcolor={0,0,255}),
              string="phi (x,y,z)"),
            Line(points=[-92,0; -80,0], style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[92,0; 80,0], style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[-70,-58; 70,-58; 52,-46],
                                              style(color=3, rgbcolor={0,0,255})),
            Line(points=[70,-58; 52,-70],
                                        style(color=3, rgbcolor={0,0,255})),
            Bitmap(extent=[-64,36; 64,-56], name="Images/Integral.gif")),
                                      Diagram,
          Documentation(info="<html>
This model implements the differential equations relating the angular velocity w and the three cardan angles phi.
<p>
The three rotation axes can be specified by the parameter sequence_angles
</html>"));
        MultiBondLib.Interfaces.RealSignal phi[3]
          annotation (extent=[90,-10; 110,10]);
        MultiBondLib.Interfaces.RealSignal w[3]
                                               annotation (extent=[-110,-10; -90,10]);
        parameter Integer[3] sequence_angles(min={1,1,1}, max={3,3,3}) = {1,2,3};

      protected
        Real R2[3,3];
        Real R3[3,3];
        SI.AngularVelocity w1[3];
        SI.AngularVelocity w2[3];
        SI.AngularVelocity w3[3];

      equation
        if sequence_angles[1] == 1 then
          w1 = {der(phi[1]),0,0};
        end if;
        if sequence_angles[2] == 1 then
          R2 = [1,0,0;0,cos(phi[2]),sin(phi[2]);0,-sin(phi[2]),cos(phi[2])];
          w2 = {der(phi[2]),0,0};
        end if;
        if sequence_angles[3] == 1 then
          R3 = [1,0,0;0,cos(phi[3]),sin(phi[3]);0,-sin(phi[3]),cos(phi[3])];
          w3 = {der(phi[3]),0,0};
        end if;

        if sequence_angles[1] == 2 then
          w1 = {0,der(phi[1]),0};
        end if;
        if sequence_angles[2] == 2 then
          R2 = [cos(phi[2]),0,-sin(phi[2]);0,1,0;sin(phi[2]),0,cos(phi[2])];
          w2 = {0,der(phi[2]),0};
        end if;
        if sequence_angles[3] == 2 then
          R3 = [cos(phi[3]),0,-sin(phi[3]);0,1,0;sin(phi[3]),0,cos(phi[3])];
          w3 = {0,der(phi[3]),0};
        end if;

        if sequence_angles[1] == 3 then
          w1 = {0,0,der(phi[1])};
        end if;
        if sequence_angles[2] == 3 then
          R2 = [cos(phi[2]),sin(phi[2]),0;-sin(phi[2]),cos(phi[2]),0;0,0,1];
          w2 = {0,0,der(phi[2])};
        end if;
        if sequence_angles[3] == 3 then
          R3 = [cos(phi[3]),sin(phi[3]),0;-sin(phi[3]),cos(phi[3]),0;0,0,1];
          w3 = {0,0,der(phi[3])};
        end if;

        w = w3 + R3*w2 + R3*R2*w1;

      // w = {0,0,der(phi[3])} + {sin(phi[3])*der(phi[2]),cos(phi[3])*der(phi[2]),0} +
      //     {cos(phi[3])*cos(phi[2])*der(phi[1]),-sin(phi[3])*cos(phi[2])*der(phi[1]),sin(phi[2])*der(phi[1])};

      end toCardanAngles;

      model toQuaternions
        "integrates the angular velocity into the quaternions"

        annotation (Icon(
            Rectangle(extent=[-80,80; 80,-80], style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
                         Text(
              extent=[-80,28; 80,88],
              style(color=3, rgbcolor={0,0,255}),
              string="quaternions"),
            Line(points=[-92,0; -80,0], style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[92,0; 80,0], style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[-70,-58; 70,-58; 52,-46],
                                              style(color=3, rgbcolor={0,0,255})),
            Line(points=[70,-58; 52,-70],
                                        style(color=3, rgbcolor={0,0,255})),
            Bitmap(extent=[-64,36; 64,-56], name="Images/Integral.gif")),
                                      Diagram,
          Documentation(info="<html>
This model implements the differential equations relating the angular velocity w and the quaternion Q.
</html>"));
        MultiBondLib.Interfaces.RealSignal Q[4]
          annotation (extent=[90,-10; 110,10]);
        MultiBondLib.Interfaces.RealSignal w[3]
                                               annotation (extent=[-110,-10; -90,10]);

      equation
      //   w= 2*[Q[4], -Q[3], Q[2], - Q[1]; Q[3], Q[4], -Q[1], -Q[2]; -Q[2], Q[1], Q[4], -Q[3]] *der(Q);

         w= 2*[Q[4], Q[3], -Q[2], - Q[1]; -Q[3], Q[4], Q[1], -Q[2]; Q[2], -Q[1], Q[4], -Q[3]] *der(Q);
         Q*Q = 1;

      end toQuaternions;

      model Translation "translates the position"

        annotation (Icon(
            Rectangle(extent=[-80,80; 80,-80], style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
                         Text(
              extent=[-80,-80; 80,80],
              style(color=3, rgbcolor={0,0,255}),
              string="Translation"),
            Line(points=[0,-80; 0,-92],   style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[-92,0; -80,0], style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[92,0; 80,0], style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[-72,-40; 68,-40; 50,-28], style(color=3, rgbcolor={0,0,255})),
            Line(points=[68,-40; 50,-52], style(color=3, rgbcolor={0,0,255})),
            Line(points=[0,92; 0,80],     style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1))),     Diagram,
          Documentation(info="<html>
This model implements a translation between the two positional signals x1 and x2.
<p>
The translation is specified by the parameter r, which is resolved in the body system specified by the signal
R.
<p>
The translation can optionally be amplified by the signal ampl.
</html>"));

        MultiBondLib.Interfaces.RealSignal x1[3]
          annotation (extent=[-110,-10; -90,10]);
        MultiBondLib.Interfaces.RealSignal x2[3]
          annotation (extent=[90,-10; 110,10]);
        MultiBondLib.Interfaces.RealSignal R[3,3]
                                               annotation (extent=[-10,-110; 10,-90]);

        parameter Real r[3] = {1,0,0}
                                    annotation(Evaluate=true);

        MultiBondLib.Interfaces.RealSignal ampl
                                               annotation (extent=[-10,90; 10,110]);
      equation
        if cardinality(ampl) == 0 then
          ampl = 1;
        end if;

        x2 = x1 + transpose(R)*(r*ampl);

      end Translation;
    end Utilities;

    package Examples "Examples"
    annotation (Icon(
          Rectangle(extent=[-100,-100; 80,50],   style(
              color=0,
              fillColor=30,
              fillPattern=1)),
          Polygon(points=[100,70; 100,-80; 80,-100; 80,50; 100,70],      style(
              color=0,
              fillColor=30,
              fillPattern=1)),
          Text(
            extent=[-85,71; 65,-49],
            string="Sample",
            style(color=0)),
          Text(
            extent=[-97,23; 78,-98],
            string="Programs",
            style(color=0)),
          Text(
            extent=[-112,112; 128,63],
            string="%name",
            style(color=1)),
          Polygon(points=[-100,50; -80,70; 100,70; 80,50; -100,50], style(
            color=0,
            rgbcolor={0,0,0},
            fillColor=30,
            rgbfillColor={235,235,235},
            fillPattern=1))), preferedView="info",
    Documentation(info="<html>
This package contains various examples.
<p>
These examples demonstrate the usage of the Mechanics3D library.
<p>
For all these examples the following simulation setup is proposed.
<ul>
<li>Start time: 0 seconds
<li>Stop time: 10 seconds
<li>Number of intervals: 2500
<li>Algorithm: DASSL
</ul>
Don't forget to open an animation window.
</html>"));

      model FourBarLoop "3D kinematic loop"
                 extends Modelica.Icons.Example;

        inner World3D world3D(nominalLength=1, g=9.81)
                                               annotation (extent=[-100,-100; -80,-80]);
        annotation (Diagram, experiment(StopTime=10, NumberOfIntervals=2500),
      preferedView="info", Documentation(info="<html>
This example presents a kinematic loop. It consist in 4 bars.
It is equivalent to the example in the Modelica.Mechanics.MultiBody library.
<p>
<img src=\"../Images/FourBarLoop.png\">
</p>
<p>
The loop is automatically closed. It has one degree of freedom.
 and leads to 6 non-linear equations.
</html>"));
        Parts.Fixed Fixed1 annotation (extent=[-100,-40; -80,-20]);
        Parts.FixedTranslation FixedTranslation1(r={0,0.5,0.1}, width=0.05)
          annotation (extent=[-80,8; -60,28], rotation=90);
        Joints.Revolute Revolute1(initType=Modelica.Mechanics.MultiBody.Types.Init.
              PositionVelocity,
          n={1,0,0},
          phi_start=0,
          enforceStates=true,
          w_start=300)          annotation (extent=[-80,-20; -60,0], rotation=90);
        Parts.FixedTranslation FixedTranslation2(r={0,0.2,0}, width=0.05)
          annotation (extent=[40,-30; 60,-10], rotation=90);
        Parts.FixedTranslation FixedTranslation3(r={1,-0.3,-0.1}, width=0.05)
          annotation (extent=[-8,60; 12,80]);
        Parts.FixedTranslation FixedTranslation4(r={1.2,0,0}, animation=false)
          annotation (extent=[-20,-80; 0,-60],  rotation=0);
        Parts.Body Body2(
          m=0.5,
          I_11=0.05,
          I_22=0.05,
          I_33=0.05,
          I_21=0,
          I_31=0,
          I_32=0,
          animation=false)
                     annotation (extent=[22,40; 42,60], rotation=0);
        Joints.Prismatic Prismatic1(
          s_start=0,
          v_start=0,
          initType=Modelica.Mechanics.MultiBody.Types.Init.Free)
          annotation (extent=[80,-60; 60,-40]);
        Joints.Revolute Revolute4(
          n={0,0,1}, initType=Modelica.Mechanics.MultiBody.Types.Init.Free)
          annotation (extent=[52,24; 72,44],   rotation=0);
        Joints.Revolute Revolute6(
          n={0,1,0}, initType=Modelica.Mechanics.MultiBody.Types.Init.Free)
          annotation (extent=[74,44; 94,64],   rotation=90);
        Parts.FixedTranslation FixedTranslation5(r={0,0.25,0.05}, animation=
              false)
          annotation (extent=[-48,8; -28,28], rotation=90);
        Parts.Body Body1(
          m=0.5,
          I_11=0.05,
          I_22=0.05,
          I_33=0.05,
          I_21=0,
          I_31=0,
          I_32=0,
          animation=false)
                     annotation (extent=[-48,40; -28,60], rotation=90);
        Parts.Body Body3(
          m=0.5,
          I_11=0.05,
          I_22=0.05,
          I_33=0.05,
          I_21=0,
          I_31=0,
          I_32=0,
          animation=false)
                     annotation (extent=[60,0; 80,20], rotation=90);
        Parts.FixedTranslation FixedTranslation6(r={0.5,-0.15,-0.05}, animation=
             false)
          annotation (extent=[-8,40; 12,60]);
        Parts.FixedTranslation FixedTranslation7(r={0,0.1,0}, animation=false)
          annotation (extent=[60,-30; 80,-10], rotation=90);
        Joints.Spherical Spherical1(useQuaternions=false)
          annotation (extent=[-80,40; -60,60], rotation=90);
      equation
        connect(Revolute1.frame_a, Fixed1.frame_b) annotation (points=[-70,-21; -70,
              -30; -79,-30],
            style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=10,
            rgbfillColor={135,135,135},
            fillPattern=1));
        connect(FixedTranslation4.frame_a, Fixed1.frame_b) annotation (points=[-21,-70;
              -80,-70; -80,-30; -79,-30],      style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FixedTranslation1.frame_a, Revolute1.frame_b) annotation (points=[-70,7;
              -70,1],    style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FixedTranslation4.frame_b, Prismatic1.frame_a) annotation (points=[1,-70;
              90,-70; 90,-50; 81,-50],          style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Prismatic1.frame_b, FixedTranslation2.frame_a) annotation (points=[59,
              -50; 50,-50; 50,-31], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FixedTranslation2.frame_b, Revolute4.frame_a) annotation (points=[50,-9;
              50,34; 51,34],     style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FixedTranslation5.frame_a, FixedTranslation1.frame_a) annotation (
            points=[-38,7; -48,8; -48,7; -70,7], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Body1.frame_a, FixedTranslation5.frame_b) annotation (points=[-38,39;
              -38,29], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FixedTranslation6.frame_a, FixedTranslation3.frame_a) annotation (
            points=[-9,50; -9,70], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Body2.frame_a, FixedTranslation6.frame_b) annotation (points=[21,50;
              13,50], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FixedTranslation7.frame_a, FixedTranslation2.frame_a) annotation (
            points=[70,-31; 50,-31], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Body3.frame_a, FixedTranslation7.frame_b) annotation (points=[70,-1;
              70,-9], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Spherical1.frame_b, FixedTranslation3.frame_a)       annotation (
            points=[-70,61; -70,70; -9,70], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Spherical1.frame_a, FixedTranslation1.frame_b)       annotation (
            points=[-70,39; -70,29], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Revolute6.frame_a, Revolute4.frame_b) annotation (points=[84,43; 84,
              34; 73,34], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Revolute6.frame_b, FixedTranslation3.frame_b) annotation (points=[84,
              65; 84,70; 13,70], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
      end FourBarLoop;

      model RollingMarble "a marble rolling on a plane"
                 extends Modelica.Icons.Example;

        inner World3D world3D(nominalLength=5, g=9.81)
                                               annotation (extent=[-100,-40; -80,-20]);
        annotation (Diagram, experiment(StopTime=10, NumberOfIntervals=2500),
      preferedView="info", Documentation(info="<html>
This example presents an ideal rolling marble.
<p>
<img src=\"../Images/RollingMarble.png\">
</p>
<p>
The marble is attached to the origin by a spring. The tangential intial velocity leads to
an elliptic trajectory.
<p>
A ideal rolling marble has 5 degrees of freedom on positional level and 3 degrees of freedom on velocity level.
</html>"));
        Parts.Fixed Fixed1 annotation (extent=[-80,40; -60,60]);
        Forces.Spring Spring1(s0=0, c=5)    annotation (extent=[-40,40; -20,60]);
        RollingObjects.Marble Marble2(
          m=2,
          I_11=0.02,
          I_22=0.02,
          I_33=0.02,
          r=0.3,
          d=0,
          w_start=2*{0,0,360},
          initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
          useTransVelocities=true,
          x_start={2,0,-2},
          v_start={0,0,6}) annotation (extent=[-40,0; -20,20]);
      equation
        connect(Spring1.frame_a, Fixed1.frame_b) annotation (points=[-41,50; -59,50],
            style(
            color=0,
            rgbcolor={0,0,0},
            pattern=0,
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(Marble2.frame_b, Spring1.frame_b) annotation (points=[-19,10;
              10,10; 10,50; -19,50],
                                 style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
      end RollingMarble;

      model GyroscopicEffect "demonstration of the gyroscopic effect"
                 extends Modelica.Icons.Example;

        inner World3D world3D(nominalLength=5,
          animateWorld=true,
          animateGravity=true)                 annotation (extent=[-100,80; -80,100]);
        annotation (Diagram, experiment(StopTime=10, NumberOfIntervals=2500),
      preferedView="info", Documentation(info="<html>
This example demonstrates the gyroscopic effect.
<p>
<img src=\"../Images/Gyroscopic.png\">
</p>
<p>
The mass at the end of the spherical pendulum is heavily rotating. The mass then starts to turn around due to its rotation and enters a circular trajectory.
<p>
The efficiency of the simulation is drastically influenced by the choice of the sequence of cardan angles.
These can be set in the advanced group of the parameter menu.
<p>
In addition the model is confronted with an identical variant of the Modelica.Mechanics.Multibody library.
Both models behave exaclty the same.
</html>"));
        Parts.Body Body1(
          m=2,
          I_11=0.12,
          I_22=0.06,
          I_33=0.06,
          I_21=0,
          I_31=0,
          I_32=0)    annotation (extent=[20,40; 40,60]);
        Parts.Fixed Fixed1 annotation (extent=[-100,40; -80,60]);
        Parts.FixedTranslation FixedTranslation2(r={0,0,1})
          annotation (extent=[60,30; 80,50]);
        Parts.FixedTranslation FixedTranslation3(r={0,1,0})
          annotation (extent=[60,10; 80,30]);
        inner Modelica.Mechanics.MultiBody.World world(nominalLength=5, g=9.81,
          animateWorld=false,
          animateGravity=false)
          annotation (extent=[-100,-100; -80,-80]);
        Modelica.Mechanics.MultiBody.Parts.Fixed Fixed2(r={0,0,-2}, animation=
              false)
          annotation (extent=[-100,-60; -80,-40]);
        Parts.FixedTranslation FixedTranslation1(r={2,0,0})
          annotation (extent=[-20,40; 0,60]);
        Modelica.Mechanics.MultiBody.Parts.Body Body2(
          m=2,
          I_11=0.12,
          I_22=0.06,
          I_33=0.06) annotation (extent=[20,-60; 40,-40]);
        Modelica.Mechanics.MultiBody.Parts.FixedTranslation FixedTranslation4(r={2,0,
              0}) annotation (extent=[-20,-60; 0,-40]);
        Modelica.Mechanics.MultiBody.Parts.FixedTranslation FixedTranslation5(r={0,0,
              1}) annotation (extent=[60,-70; 80,-50]);
        Modelica.Mechanics.MultiBody.Parts.FixedTranslation FixedTranslation6(r={0,1,
              0}) annotation (extent=[60,-90; 80,-70]);
        Modelica.Mechanics.MultiBody.Joints.Spherical Spherical2(
          initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
          w_rel_a_start=40*360*{1,0,0},
          enforceStates=true,
          useQuaternions=false,
          sequence_angleStates={2,3,1})
                              annotation (extent=[-60,-60; -40,-40]);
        Joints.Spherical Spherical1(
          initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
          useQuaternions=false,
          w_start=40*360*{1,0,0},
          sequence_angles={2,3,1})
          annotation (extent=[-60,40; -40,60]);
        Parts.FixedTranslation FixedTranslation7(r={0,0,-1})
          annotation (extent=[60,70; 80,90]);
        Parts.FixedTranslation FixedTranslation8(r={0,-1,0})
          annotation (extent=[60,50; 80,70]);
        Modelica.Mechanics.MultiBody.Parts.FixedTranslation FixedTranslation9(r=
             {0,0,-1})
                  annotation (extent=[60,-30; 80,-10]);
        Modelica.Mechanics.MultiBody.Parts.FixedTranslation FixedTranslation10(
            r={0,-1,0})
                  annotation (extent=[60,-50; 80,-30]);
      equation
        connect(FixedTranslation3.frame_a, FixedTranslation2.frame_a) annotation (
            points=[59,20; 54,20; 54,40; 59,40], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=10,
            rgbfillColor={135,135,135},
            fillPattern=1));
        connect(FixedTranslation2.frame_a, Body1.frame_a) annotation (points=[59,40;
              54,40; 54,50; 19,50], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FixedTranslation5.frame_a, Body2.frame_a) annotation (points=[59,-60;
              52,-60; 52,-50; 19,-50],
                               style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FixedTranslation6.frame_a, Body2.frame_a) annotation (points=[59,-80;
              52,-80; 52,-50; 19,-50], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FixedTranslation4.frame_b, Body2.frame_a) annotation (points=[1,-50;
              19,-50], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FixedTranslation1.frame_b, Body1.frame_a) annotation (points=[1,50; 19,
              50],    style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Spherical2.frame_b, FixedTranslation4.frame_a) annotation (points=[-39,-50;
              -21,-50],                       style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Spherical2.frame_a, Fixed2.frame_b) annotation (points=[-61,-50;
              -79,-50],               style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Spherical1.frame_b, FixedTranslation1.frame_a)       annotation (
            points=[-39,50; -21,50],style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Spherical1.frame_a, Fixed1.frame_b)       annotation (points=[-61,50;
              -79,50], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FixedTranslation7.frame_a, Body1.frame_a) annotation (points=[
              59,80; 54,80; 54,50; 19,50], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FixedTranslation8.frame_a, Body1.frame_a) annotation (points=[
              59,60; 54,60; 54,50; 19,50], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FixedTranslation9.frame_a, Body2.frame_a) annotation (points=[59,-20;
              52,-20; 52,-50; 19,-50],
                               style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FixedTranslation10.frame_a, Body2.frame_a)
                                                          annotation (points=[59,-40;
              52,-40; 52,-50; 19,-50], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
      end GyroscopicEffect;

      model SphericalSpring "application of the spherical joint"
                 extends Modelica.Icons.Example;

        inner World3D world3D(nominalLength=5) annotation (extent=[-100,-40; -80,-20]);
        annotation (Diagram, preferedView="info", experiment(StopTime=10, NumberOfIntervals=2500),
      Documentation(info="<html>
This example presents the model of a spherical pendulum attached to a spring-damper.
<p>
<img src=\"../Images/SphericalSpring.png\">
</p>
<p>
The rotation of the spherical joint is described by quaternions.
This can be selected in the advanced tab of the parameter menu.
<p>
The usage of quaternions leads to the need for dynamic state selection,
because the 3 degrees of freedom are described by the 4 potential variables of the quaternion.
Also a set of non-linear equations arises, but these equations are solved robustly.
</html>"));
        Parts.Body Body1(
          m=2,
          I_11=0.01,
          I_22=0.01,
          I_33=0.01,
          I_21=0.1,
          I_31=0.1,
          I_32=0.1)  annotation (extent=[32,0; 52,20]);
        Parts.Fixed Fixed1 annotation (extent=[-100,0; -80,20]);
        Parts.FixedTranslation FixedTranslation1(r={2,0,2})
          annotation (extent=[-2,0; 18,20]);
        Joints.Spherical Spherical1(                 initType=Modelica.Mechanics.
              MultiBody.Types.Init.Free, w_start={0,0,0},
          useQuaternions=true)           annotation (extent=[-52,0; -32,20]);
        Parts.Fixed Fixed2(r={1.5,0,0.5})
                           annotation (extent=[-100,40; -80,60]);
        Forces.Spring Spring1(c=10, s0=1) annotation (extent=[-40,40; -20,60]);
        Forces.Damping Damping1(d=0.5) annotation (extent=[-40,64; -20,84]);
      equation
        connect(FixedTranslation1.frame_b, Body1.frame_a) annotation (points=[19,10;
              31,10], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Fixed2.frame_b, Spring1.frame_a) annotation (points=[-79,50; -41,50],
            style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Spring1.frame_b, FixedTranslation1.frame_b) annotation (points=[-19,
              50; 20,50; 20,10; 19,10], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Damping1.frame_a, Fixed2.frame_b) annotation (points=[-41,74; -79,74;
              -79,50], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Damping1.frame_b, FixedTranslation1.frame_b) annotation (points=[-19,
              74; 20,74; 20,10; 19,10], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Fixed1.frame_b, Spherical1.frame_a) annotation (points=[-79,10; -53,
              10], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Spherical1.frame_b, FixedTranslation1.frame_a) annotation (points=[
              -31,10; -3,10], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
      end SphericalSpring;

      model Bicycle "an uncontroled bicycle"
      extends Modelica.Icons.Example;

        import SI = Modelica.SIunits;
        import MB = Modelica.Mechanics.MultiBody;

        parameter SI.Angle saddlepipeAngle = 75
          "|Animation || angle of saddlepipe";
        final parameter SI.Angle saddlepipeAngleRad = SI.Conversions.from_deg(saddlepipeAngle);
        parameter SI.Position saddlenodeHeight = 0.3
          "|Animation || height of the saddle node";
        parameter SI.Position saddleHeight = 0.15
          "|Animation || height of the saddle above the saddlenode";
        parameter SI.Position chainwheelPos = 1.3*0.3
          "|Animation || xposition of the chainwheel";
        parameter Real ladyFactor = 0
          "|Animation || factor for low entrance: Pushes down the upper frame bar.";
        parameter SI.Angle handlebarAngle = 110
          "|Animation || angle of the handlebar";
        final parameter SI.Angle handlebarAngleRad = SI.Conversions.from_deg(handlebarAngle);

        final parameter SI.Position chainwheel[3] = {-chainwheelPos,0,0};
        final parameter SI.Position saddlenode[3] = {chainwheel[1]+(1/tan(saddlepipeAngleRad))*saddlenodeHeight,saddlenodeHeight,0};
        final parameter SI.Position upperframenode[3] = ladyFactor*chainwheel + (1-ladyFactor)*saddlenode;

        inner World3D world3D(                 g=9.81,
          n={0,-1,0},
          nominalLength=2)                     annotation (extent=[-20,60; 0,80]);
        annotation (Diagram, preferedView="info", experiment(StopTime=10, NumberOfIntervals=2500),
      Documentation(info="<html>
This example presents the model of a bicycle.
<p>
<img src=\"../Images/Bicycle.png\">
</p>
<p>
The joints of the bicycle are frictionless and the wheels are ideally rolling.
The bicycle is uncontrolled, but due to its initial velocity it is self-stabilizing.
Within a certain a range of driving velocity a bicycle is stable.
<p>
A bicycle has 7 degrees of freedom on positional level and 3 degrees of freedom on
velocity level.
</html>"));
        Joints.Revolute FWRevolute(
          phi(stateSelect=StateSelect.always),
          initType=Modelica.Mechanics.MultiBody.Types.Init.Position,
          phi_start=0,
          animation=true,
          cylinderLength=0.05,
          cylinderDiameter=0.08,
          cylinderColor={255,0,0})
          annotation (extent=[-80,-40; -60,-20], rotation=90);
        Joints.Revolute RWRevolute(
          enforceStates=false,
          phi_start=0,
          w_start=0,
          initType=Modelica.Mechanics.MultiBody.Types.Init.Free,
          animation=true,
          cylinderLength=0.05,
          cylinderDiameter=0.08,
          cylinderColor={255,0,0})
                               annotation (extent=[60,-40; 80,-20], rotation=270);
        Parts.FixedTranslation RearFrame(               animation=false, r={1.02,
              -0.48,0})                          annotation (extent=[10,0; 30,20]);
        Parts.FixedTranslation FrontFrame(                animation=false, r={0.18,
              0.48,0})                           annotation (extent=[-58,0; -38,20]);
        Parts.FixedTranslation RearMassPos(r={-0.3,0.9,0}, animation=false)
                                                 annotation (extent=[60,20; 80,40],
            rotation=90);
        Parts.FixedTranslation FrontMassPos(r={0.12,0.7,0}, animation=false)
                                                 annotation (extent=[-80,20; -60,40],
            rotation=90);
        Joints.Revolute Steering(
          phi(stateSelect=StateSelect.always),
          initType=Modelica.Mechanics.MultiBody.Types.Init.Position,
          phi_start=0,
          n={0.258,0.965,0},
          cylinderLength=0.07,
          cylinderDiameter=0.07,
          cylinderColor={255,0,0})
          annotation (extent=[-30,0; -10,20], rotation=0);
        Parts.SimpleBody FrontMass(
          I_31=0,
          I_32=0,
          animation=false,
          m=4,
          I_11=0.0546,
          I_22=0.0114,
          I_33=0.06,
          I_21=-0.0162)
               annotation (extent=[-80,60; -60,80], rotation=90);
        Parts.SimpleBody RearMass(
          I_31=0,
          I_32=0,
          animation=false,
          m=85,
          I_11=9.2,
          I_22=2.8,
          I_33=11,
          I_21=2.4)
               annotation (extent=[60,60; 80,80], rotation=90);
        RollingObjects.Wheel RWheel(
          m=2,
          I_11=0.06,
          I_22=0.06,
          I_33=0.12,
          initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
          phi_start={0,5,0},
          w_start=2.2*{0,0,360},
          r=0.3,
          enforceStates=true) annotation (extent=[40,-80; 60,-60]);
       Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RWSuspRight(
           lengthDirection=chainwheel,
           length=sqrt(chainwheel*chainwheel),
           shapeType="cylinder",
           color={255,255,0},
           width=0.03,
           height=0.03,
           r_shape={0,0,0.050},
           r=RearFrame.frame_b.P.x,
           R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

       Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RWSusp2Right(
           length=sqrt(saddlenode*saddlenode),
           shapeType="cylinder",
           color={255,255,0},
           lengthDirection=saddlenode,
           width=0.03,
           height=0.03,
           r_shape={0,0,0.050},
           r=RearFrame.frame_b.P.x,
           R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

       Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RWSuspLeft(
           lengthDirection=chainwheel,
           length=sqrt(chainwheel*chainwheel),
           shapeType="cylinder",
           color={255,255,0},
           width=0.03,
           height=0.03,
           r_shape={0,0,-0.050},
           r=RearFrame.frame_b.P.x,
           R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

       Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RWSusp2Left(
           length=sqrt(saddlenode*saddlenode),
           shapeType="cylinder",
           color={255,255,0},
           lengthDirection=saddlenode,
           width=0.03,
           height=0.03,
           r_shape={0,0,-0.050},
           r=RearFrame.frame_b.P.x,
           R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape SaddlePipe(
          shapeType="cylinder",
          color={255,255,0},
          r_shape=chainwheel,
          lengthDirection=saddlenode-chainwheel,
          width=0.06,
          height=0.06,
          length=(saddlenodeHeight+saddleHeight)*(1/sin(saddlepipeAngleRad)),
          r=RearFrame.frame_b.P.x,
          R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

         Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape lowerframepipe(
           shapeType="cylinder",
           color={255,255,0},
           r_shape=chainwheel,
           width=0.06,
           height=0.06,
           lengthDirection=-RearFrame.r-chainwheel,
           widthDirection={0,0,1},
           length=sqrt((-RearFrame.r-chainwheel)*(-RearFrame.r-chainwheel)),
           r=RearFrame.frame_b.P.x,
           R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

         Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape upperframepipe(
           shapeType="cylinder",
           color={255,255,0},
           width=0.06,
           height=0.06,
           widthDirection={0,0,1},
           r_shape=upperframenode,
           lengthDirection=(-RearFrame.r-upperframenode),
           length=sqrt((-RearFrame.r-upperframenode)*(-RearFrame.r-upperframenode)),
           r=RearFrame.frame_b.P.x,
           R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape chainwheelpipe(
          shapeType="cylinder",
          color={255,255,0},
          widthDirection={1,0,0},
          r_shape=chainwheel+{0,0,-0.08},
          lengthDirection={0,0,1},
          width=0.1,
          height=0.1,
          length=0.16,
          r=RearFrame.frame_b.P.x,
          R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

       Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape Saddle(
          color={0,0,0},
          shapeType="box",
          lengthDirection={-1,0,0},
          widthDirection={0,0,1},
          length=0.2,
          width=0.1,
          height=0.05,
          r_shape={saddlenode[1]+(saddleHeight/tan(saddlepipeAngleRad))+0.07,saddleHeight+saddlenodeHeight,0},
          r=RearFrame.frame_b.P.x,
          R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape ForkPipe1(
          shapeType="cylinder",
          color={255,255,0},
          lengthDirection={cos(handlebarAngleRad),sin(handlebarAngleRad),0},
          r_shape={0,0,0},
          length=0.134,
          width=0.05,
          height=0.05,
          r=FrontFrame.frame_b.P.x,
          R=MB.Frames.Orientation(T=FrontFrame.frame_b.P.R,w=zeros(3)));

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape ForkPipe2(
          shapeType="cylinder",
          color={255,255,0},
          lengthDirection={0,0,1},
          width=0.04,
          height=0.04,
          r_shape={cos(handlebarAngleRad),sin(handlebarAngleRad),0}*0.134+{0,0,-0.22},
          length=0.44,
          r=FrontFrame.frame_b.P.x,
          R=MB.Frames.Orientation(T=FrontFrame.frame_b.P.R,w=zeros(3)));

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape FWSuspLeft(
          shapeType="cylinder",
          r_shape={0,0,-0.050},
          color={255,255,0},
          width=0.03,
          height=0.03,
          lengthDirection=Steering.n,
          length=-FrontFrame.r*Steering.n/sqrt(Steering.n*Steering.n),
          r=FrontFrame.frame_b.P.x,
          R=MB.Frames.Orientation(T=FrontFrame.frame_b.P.R,w=zeros(3)));

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape FWSuspRight(
          shapeType="cylinder",
          color={255,255,0},
          width=0.03,
          height=0.03,
          lengthDirection=Steering.n,
          r_shape={0,0,0.050},
          length=-FrontFrame.r*Steering.n/sqrt(Steering.n*Steering.n),
          r=FrontFrame.frame_b.P.x,
          R=MB.Frames.Orientation(T=FrontFrame.frame_b.P.R,w=zeros(3)));

        RollingObjects.Wheel FWheel(
          phi_start={0,5,0},
          w_start=2.2*{0,0,360},
          r=0.35,
          m=3,
          I_11=0.14,
          I_22=0.14,
          I_33=0.28,
          initType=Modelica.Mechanics.MultiBody.Types.Init.Free,
          enforceStates=false)
                              annotation (extent=[-100,-80; -80,-60]);
      equation
        connect(RWRevolute.frame_a, RearFrame.frame_b)        annotation (points=[70,-19;
              70,10; 31,10],
                           style(
            color=0,
            rgbcolor={0,0,0},
            pattern=0,
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(FrontFrame.frame_a, FWRevolute.frame_b)       annotation (points=[-59,
              10; -70,10; -70,-19], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Steering.frame_a, FrontFrame.frame_b)         annotation (points=[-31,
              10; -37,10], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(RearFrame.frame_a, Steering.frame_b)          annotation (points=[9,
              10; -9,10], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(RearMassPos.frame_a, RWRevolute.frame_a)      annotation (points=[70,
              19; 70,-19], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(RearMass.frame_a, RearMassPos.frame_b)    annotation (points=[70,59;
              70,41], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FrontMassPos.frame_a, FWRevolute.frame_b)     annotation (points=[-70,
              19; -70,-19], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FrontMass.frame_a, FrontMassPos.frame_b)  annotation (points=[-70,59;
              -70,41], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(RWheel.frame_b, RWRevolute.frame_b)
                                                   annotation (points=[61,-70;
              70,-70; 70,-41], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FWheel.frame_b, FWRevolute.frame_a) annotation (points=[-79,-70;
              -70,-70; -70,-41], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
      end Bicycle;

      model Bicycle2 "an uncontroled bicycle"
      extends Modelica.Icons.Example;

        import SI = Modelica.SIunits;
        import MB = Modelica.Mechanics.MultiBody;

        parameter SI.Angle saddlepipeAngle = 75
          "|Animation || angle of saddlepipe";
        final parameter SI.Angle saddlepipeAngleRad = SI.Conversions.from_deg(saddlepipeAngle);
        parameter SI.Position saddlenodeHeight = 0.3
          "|Animation || height of the saddle node";
        parameter SI.Position saddleHeight = 0.15
          "|Animation || height of the saddle above the saddlenode";
        parameter SI.Position chainwheelPos = 1.3*0.3
          "|Animation || xposition of the chainwheel";
        parameter Real ladyFactor = 0
          "|Animation || factor for low entrance: Pushes down the upper frame bar.";
        parameter SI.Angle handlebarAngle = 110
          "|Animation || angle of the handlebar";
        final parameter SI.Angle handlebarAngleRad = SI.Conversions.from_deg(handlebarAngle);

        final parameter SI.Position chainwheel[3] = {-chainwheelPos,0,0};
        final parameter SI.Position saddlenode[3] = {chainwheel[1]+(1/tan(saddlepipeAngleRad))*saddlenodeHeight,saddlenodeHeight,0};
        final parameter SI.Position upperframenode[3] = ladyFactor*chainwheel + (1-ladyFactor)*saddlenode;

        inner World3D world3D(                 g=9.81,
          n={0,-1,0},
          nominalLength=2)                     annotation (extent=[-20,60; 0,80]);
        annotation (Diagram, preferedView="info", experiment(StopTime=10, NumberOfIntervals=2500),
      Documentation(info="<html>
This example presents the model of a bicycle. This model is a slight modification of the original model. The translation of the original model caused sometimes problems in older Dymola versions (<6).
However, the dynamic characteristics of the bycicle are not changed  in any way.
<p>
<img src=\"../Images/Bicycle.png\">
</p>
<p>
The joints of the bicycle are frictionless and the wheels are ideally rolling.
The bicycle is uncontrolled, but due to its initial velocity it is self-stabilizing.
Within a certain a range of driving velocity a bicycle is stable.
<p>
A bicycle has 7 degrees of freedom on positional level and 3 degrees of freedom on
velocity level.
</html>"));
        Joints.Revolute FWRevolute(
          phi(stateSelect=StateSelect.always),
          initType=Modelica.Mechanics.MultiBody.Types.Init.Position,
          phi_start=0,
          animation=true,
          cylinderLength=0.05,
          cylinderDiameter=0.08,
          cylinderColor={255,0,0})
          annotation (extent=[-80,-40; -60,-20], rotation=90);
        Joints.Revolute RWRevolute(
          enforceStates=false,
          phi_start=0,
          w_start=0,
          initType=Modelica.Mechanics.MultiBody.Types.Init.Free,
          animation=true,
          cylinderLength=0.05,
          cylinderDiameter=0.08,
          cylinderColor={255,0,0})
                               annotation (extent=[60,-40; 80,-20], rotation=270);
        Parts.FixedTranslation RearFrame(               animation=false, r={1.02,
              -0.48,0})                          annotation (extent=[10,0; 30,20]);
        Parts.FixedTranslation FrontFrame(                animation=false, r={0.18,
              0.48,0})                           annotation (extent=[-58,0; -38,20]);
        Parts.FixedTranslation RearMassPos(r={-0.3,0.9,0}, animation=false)
                                                 annotation (extent=[60,20; 80,40],
            rotation=90);
        Parts.FixedTranslation FrontMassPos(r={0.12,0.7,0}, animation=false)
                                                 annotation (extent=[-80,20; -60,40],
            rotation=90);
        Joints.Revolute Steering(
          phi(stateSelect=StateSelect.always),
          initType=Modelica.Mechanics.MultiBody.Types.Init.Position,
          phi_start=0,
          n={0.258,0.965,0},
          cylinderLength=0.07,
          cylinderDiameter=0.07,
          cylinderColor={255,0,0})
          annotation (extent=[-30,0; -10,20], rotation=0);
        Parts.SimpleBody FrontMass(
          I_31=0,
          I_32=0,
          animation=false,
          m=4,
          I_11=0.0546,
          I_22=0.0114,
          I_33=0.06,
          I_21=-0.0162)
               annotation (extent=[-80,60; -60,80], rotation=90);
        Parts.SimpleBody RearMass(
          I_31=0,
          I_32=0,
          animation=false,
          m=85,
          I_11=9.2,
          I_22=2.8,
          I_33=11,
          I_21=2.4)
               annotation (extent=[60,60; 80,80], rotation=90);
        RollingObjects.Wheel RWheel(
          m=2,
          I_11=0.06,
          I_22=0.06,
          I_33=0.12,
          initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
          phi_start={0,5,0},
          w_start=2.2*{0,0,360},
          r=0.3,
          enforceStates=true) annotation (extent=[40,-80; 60,-60]);
        RollingObjects.WheelJoint FWheelJoint(r=0.35)
                  annotation (extent=[-100,-80; -80,-60]);
        Parts.SimpleBody FWheelMass(
          I_21=0,
          I_31=0,
          I_32=0,
          animation=false,
          m=3,
          I_11=0.14,
          I_22=0.14,
          I_33=0.28)
               annotation (extent=[-60,-80; -40,-60]);
       Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RWSuspRight(
           lengthDirection=chainwheel,
           length=sqrt(chainwheel*chainwheel),
           shapeType="cylinder",
           color={255,255,0},
           width=0.03,
           height=0.03,
           r_shape={0,0,0.050},
           r=RearFrame.frame_b.P.x,
           R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

       Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RWSusp2Right(
           length=sqrt(saddlenode*saddlenode),
           shapeType="cylinder",
           color={255,255,0},
           lengthDirection=saddlenode,
           width=0.03,
           height=0.03,
           r_shape={0,0,0.050},
           r=RearFrame.frame_b.P.x,
           R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

       Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RWSuspLeft(
           lengthDirection=chainwheel,
           length=sqrt(chainwheel*chainwheel),
           shapeType="cylinder",
           color={255,255,0},
           width=0.03,
           height=0.03,
           r_shape={0,0,-0.050},
           r=RearFrame.frame_b.P.x,
           R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

       Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RWSusp2Left(
           length=sqrt(saddlenode*saddlenode),
           shapeType="cylinder",
           color={255,255,0},
           lengthDirection=saddlenode,
           width=0.03,
           height=0.03,
           r_shape={0,0,-0.050},
           r=RearFrame.frame_b.P.x,
           R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape SaddlePipe(
          shapeType="cylinder",
          color={255,255,0},
          r_shape=chainwheel,
          lengthDirection=saddlenode-chainwheel,
          width=0.06,
          height=0.06,
          length=(saddlenodeHeight+saddleHeight)*(1/sin(saddlepipeAngleRad)),
          r=RearFrame.frame_b.P.x,
          R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

         Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape lowerframepipe(
           shapeType="cylinder",
           color={255,255,0},
           r_shape=chainwheel,
           width=0.06,
           height=0.06,
           lengthDirection=-RearFrame.r-chainwheel,
           widthDirection={0,0,1},
           length=sqrt((-RearFrame.r-chainwheel)*(-RearFrame.r-chainwheel)),
           r=RearFrame.frame_b.P.x,
           R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

         Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape upperframepipe(
           shapeType="cylinder",
           color={255,255,0},
           width=0.06,
           height=0.06,
           widthDirection={0,0,1},
           r_shape=upperframenode,
           lengthDirection=(-RearFrame.r-upperframenode),
           length=sqrt((-RearFrame.r-upperframenode)*(-RearFrame.r-upperframenode)),
           r=RearFrame.frame_b.P.x,
           R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape chainwheelpipe(
          shapeType="cylinder",
          color={255,255,0},
          widthDirection={1,0,0},
          r_shape=chainwheel+{0,0,-0.08},
          lengthDirection={0,0,1},
          width=0.1,
          height=0.1,
          length=0.16,
          r=RearFrame.frame_b.P.x,
          R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

       Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape Saddle(
          color={0,0,0},
          shapeType="box",
          lengthDirection={-1,0,0},
          widthDirection={0,0,1},
          length=0.2,
          width=0.1,
          height=0.05,
          r_shape={saddlenode[1]+(saddleHeight/tan(saddlepipeAngleRad))+0.07,saddleHeight+saddlenodeHeight,0},
          r=RearFrame.frame_b.P.x,
          R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape ForkPipe1(
          shapeType="cylinder",
          color={255,255,0},
          lengthDirection={cos(handlebarAngleRad),sin(handlebarAngleRad),0},
          r_shape={0,0,0},
          length=0.134,
          width=0.05,
          height=0.05,
          r=FrontFrame.frame_b.P.x,
          R=MB.Frames.Orientation(T=FrontFrame.frame_b.P.R,w=zeros(3)));

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape ForkPipe2(
          shapeType="cylinder",
          color={255,255,0},
          lengthDirection={0,0,1},
          width=0.04,
          height=0.04,
          r_shape={cos(handlebarAngleRad),sin(handlebarAngleRad),0}*0.134+{0,0,-0.22},
          length=0.44,
          r=FrontFrame.frame_b.P.x,
          R=MB.Frames.Orientation(T=FrontFrame.frame_b.P.R,w=zeros(3)));

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape FWSuspLeft(
          shapeType="cylinder",
          r_shape={0,0,-0.050},
          color={255,255,0},
          width=0.03,
          height=0.03,
          lengthDirection=Steering.n,
          length=-FrontFrame.r*Steering.n/sqrt(Steering.n*Steering.n),
          r=FrontFrame.frame_b.P.x,
          R=MB.Frames.Orientation(T=FrontFrame.frame_b.P.R,w=zeros(3)));

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape FWSuspRight(
          shapeType="cylinder",
          color={255,255,0},
          width=0.03,
          height=0.03,
          lengthDirection=Steering.n,
          r_shape={0,0,0.050},
          length=-FrontFrame.r*Steering.n/sqrt(Steering.n*Steering.n),
          r=FrontFrame.frame_b.P.x,
          R=MB.Frames.Orientation(T=FrontFrame.frame_b.P.R,w=zeros(3)));

      equation
        connect(RWRevolute.frame_a, RearFrame.frame_b)        annotation (points=[70,-19;
              70,10; 31,10],
                           style(
            color=0,
            rgbcolor={0,0,0},
            pattern=0,
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(FrontFrame.frame_a, FWRevolute.frame_b)       annotation (points=[-59,
              10; -70,10; -70,-19], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Steering.frame_a, FrontFrame.frame_b)         annotation (points=[-31,
              10; -37,10], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(RearFrame.frame_a, Steering.frame_b)          annotation (points=[9,
              10; -9,10], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(RearMassPos.frame_a, RWRevolute.frame_a)      annotation (points=[70,
              19; 70,-19], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(RearMass.frame_a, RearMassPos.frame_b)    annotation (points=[70,59;
              70,41], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FrontMassPos.frame_a, FWRevolute.frame_b)     annotation (points=[-70,
              19; -70,-19], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FrontMass.frame_a, FrontMassPos.frame_b)  annotation (points=[-70,59;
              -70,41], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(RWheel.frame_b, RWRevolute.frame_b)
                                                   annotation (points=[61,-70;
              70,-70; 70,-41], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FWRevolute.frame_a, FWheelJoint.frame_b)
                                                        annotation (points=[-70,-41;
              -70,-70; -79,-70], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FWheelJoint.frame_b, FWheelMass.frame_a)
                                                    annotation (points=[-79,-70;
              -61,-70],
                    style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
      end Bicycle2;

      model PlanarLoop "a planar kinematic loop"
                 extends Modelica.Icons.Example;

        inner World3D world3D(                 g=9.81, nominalLength=5)
                                               annotation (extent=[-100,-100; -80,-80]);
        annotation (Diagram, preferedView="info", experiment(StopTime=10, NumberOfIntervals=2500),
      Documentation(info="<html>
This example presents a planar kinematic loop. It is equivalent to the example in the PlanarMechanics library.
<p>
<img src=\"../Images/PlanarLoop2.png\">
</p>
<p>
The planar loop is formed out of three revolute joints and one prismatic joint. Attached to this loop is a pendulum
that is dissipating its energy through the damper.
<p>
This model contains one planar loops that is closed by the usage of the planar revolute: a special cut joint for planar loops. The loops lead to 2 non-linear equations.
</html>"));
        Parts.Fixed Fixed1 annotation (extent=[-80,40; -60,60]);
        Joints.Revolute Revolute1(
          phi_start=0,
          n={0,0,1},
          initType=Modelica.Mechanics.MultiBody.Types.Init.Free,
          enforceStates=true)   annotation (extent=[-60,0; -40,20],  rotation=90);
        Parts.FixedTranslation FixedTranslation4(r={0,-3,0}, animation=true)
          annotation (extent=[-62,-40; -40,-20],rotation=270);
        Parts.Body Body2(
          animation=true,
          I_11=0.05,
          I_22=0.05,
          I_33=0.05,
          I_21=0,
          I_31=0,
          I_32=0,
          m=2)       annotation (extent=[50,4; 70,24],  rotation=90);
        Joints.Prismatic Prismatic1(
          v_start=0,
          initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
          s_start=2)
          annotation (extent=[0,40; -20,60], rotation=180);
        Forces.Damping Damping1(d=2) annotation (extent=[-20,60; 0,80]);
        Forces.Spring Spring1(c=50, s0=1.6) annotation (extent=[-20,80; 0,100]);
        Joints.Revolute Revolute2(
          n={0,0,1},
          initType=Modelica.Mechanics.MultiBody.Types.Init.Free,
          enforceStates=false)  annotation (extent=[20,0; 40,20],    rotation=90);
        Parts.FixedTranslation FixedTranslation1(r={0,-3,0}, animation=true)
          annotation (extent=[18,-40; 40,-20],  rotation=270);
        Joints.CutJoints.PlanarRevolute PlanarRevolute1
          annotation (extent=[-20,-60; 0,-40]);
        Joints.Revolute Revolute3(
          n={0,0,1},
          enforceStates=false,
          initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity)
                                annotation (extent=[38,-60; 58,-40], rotation=0);
        Parts.FixedTranslation FixedTranslation2(            animation=true, r={-2,0,
              0})
          annotation (extent=[48,-28; 70,-8],   rotation=270);
      equation
        connect(Prismatic1.frame_a, Fixed1.frame_b) annotation (points=[-21,50;
              -59,50], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Damping1.frame_a, Fixed1.frame_b) annotation (points=[-21,70;
              -50,70; -50,50; -59,50],
                               style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Spring1.frame_a, Fixed1.frame_b) annotation (points=[-21,90;
              -50,90; -50,50; -59,50],
                               style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Revolute1.frame_b, Fixed1.frame_b) annotation (points=[-50,21;
              -50,50; -59,50], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Prismatic1.frame_b, Revolute2.frame_b) annotation (points=[1,50;
              30,50; 30,21], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FixedTranslation1.frame_a, Revolute2.frame_a) annotation (
            points=[29,-19; 29,-9.5; 30,-9.5; 30,-1], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FixedTranslation4.frame_a, Revolute1.frame_a) annotation (
            points=[-51,-19; -51,-9.5; -50,-9.5; -50,-1], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Damping1.frame_b, Revolute2.frame_b) annotation (points=[1,70;
              30,70; 30,21], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Spring1.frame_b, Revolute2.frame_b) annotation (points=[1,90;
              30,90; 30,21], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(PlanarRevolute1.frame_b, FixedTranslation1.frame_b) annotation (
           points=[1,-50; 10,-50; 10,-48; 29,-48; 29,-41], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(PlanarRevolute1.frame_a, FixedTranslation4.frame_b) annotation (
           points=[-21,-50; -34,-50; -34,-41; -51,-41], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Revolute3.frame_a, FixedTranslation1.frame_b) annotation (
            points=[37,-50; 32,-50; 32,-48; 29,-48; 29,-41], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Revolute3.frame_b, FixedTranslation2.frame_b) annotation (
            points=[59,-50; 58,-50; 58,-29; 59,-29], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Body2.frame_a, FixedTranslation2.frame_a) annotation (points=[
              60,3; 60,-7; 59,-7], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
      end PlanarLoop;

      model CentrifugalForce "demonstration of the centrifugal force"
                 extends Modelica.Icons.Example;

        inner World3D world3D(                 g=9.81, nominalLength=5,
          animateGravity=false,
          animateWorld=true)                   annotation (extent=[-100,-100; -80,-80]);
        annotation (Diagram, preferedView="info",experiment(StopTime=10, NumberOfIntervals=2500),
       Documentation(info="<html>
This example demonstrates the influence of the centrifugal froce.
It also presents how to handle planar loops.
<p>
<img src=\"../Images/Centrifugal.png\">
</p>
<p>
The centrifugal forces tear the two body elements apart and are therefore squeezing the spring.
<p>
This model contains two planar loops that are closed by the usage of the planar revolute joints: a special cut joint for planar loops. The two loops lead to 4 non-linear equations.
</html>"));
        Parts.Fixed Fixed1 annotation (extent=[-100,0; -80,20]);
        Joints.Revolute Revolute1(
          phi_start=0,
          n={0,0,1},
          initType=Modelica.Mechanics.MultiBody.Types.Init.Free,
          enforceStates=true)   annotation (extent=[-20,-30; 0,-10], rotation=90);
        Parts.FixedTranslation FixedTranslation4(animation=true, r={1.3,0,0})
          annotation (extent=[-20,-60; 0,-40],  rotation=270);
        Parts.Body Body2(
          animation=true,
          I_11=0.05,
          I_22=0.05,
          I_33=0.05,
          I_21=0,
          I_31=0,
          I_32=0,
          m=2)       annotation (extent=[78,-90; 98,-70],
                                                        rotation=0);
        Joints.ActuatedPrismatic Prismatic1(
          v_start=0,
          initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
          n={0,1,0},
          s_start=1.45)
          annotation (extent=[40,0; 20,20], rotation=180);
        Joints.Revolute Revolute2(
          n={0,0,1},
          initType=Modelica.Mechanics.MultiBody.Types.Init.Free,
          enforceStates=false)  annotation (extent=[60,-30; 80,-10], rotation=90);
        Parts.FixedTranslation FixedTranslation1(animation=true, r={1.3,0,0})
          annotation (extent=[60,-60; 80,-40],  rotation=270);
        Joints.CutJoints.PlanarRevolute PlanarRevolute1
          annotation (extent=[20,-90; 40,-70]);
        Joints.ActuatedRevolute Revolute3(
          n={0,1,0},
          initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
          cylinderDiameter=world3D.defaultJointWidth*3,
          enforceStates=true,
          cylinderLength=world3D.defaultJointLength/5)
                                annotation (extent=[-70,0; -50,20],  rotation=0);
        Parts.Body Body1(
          I_11=0.05,
          I_22=0.05,
          I_33=0.05,
          I_21=0,
          I_31=0,
          I_32=0,
          m=4,
          animation=false)
                     annotation (extent=[-40,20; -20,40],
                                                        rotation=90);
        Joints.Revolute Revolute4(
          phi_start=0,
          n={0,0,1},
          initType=Modelica.Mechanics.MultiBody.Types.Init.Free,
          enforceStates=false)  annotation (extent=[-20,32; 0,52],   rotation=90);
        Joints.Revolute Revolute5(
          n={0,0,1},
          initType=Modelica.Mechanics.MultiBody.Types.Init.Free,
          enforceStates=false)  annotation (extent=[60,32; 80,52],   rotation=90);
        Parts.FixedTranslation FixedTranslation2(animation=true, r={-1.3,0,0})
          annotation (extent=[-20,60; 0,80],    rotation=90);
        Parts.FixedTranslation FixedTranslation3(animation=true, r={-1.3,0,0})
          annotation (extent=[60,60; 80,80],    rotation=270);
        Joints.CutJoints.PlanarRevolute PlanarRevolute2
          annotation (extent=[20,80; 40,100]);
        Parts.Body Body3(
          animation=true,
          I_11=0.05,
          I_22=0.05,
          I_33=0.05,
          I_21=0,
          I_31=0,
          I_32=0,
          m=2)       annotation (extent=[80,80; 100,100],
                                                        rotation=0);
        Modelica.Blocks.Sources.Constant t(k=10)
          annotation (extent=[-100,-40; -80,-20]);
        BondLib.Mechanical.Rotational.Sources.Torque torque
          annotation (extent=[-74,-40; -54,-20]);
        BondLib.Mechanical.Translational.Passive.SpringDamper springDamper(
          s_rel0=1.6,
          c=160,
          d=16) annotation (extent=[22,-26; 42,-6]);
      equation
        connect(Prismatic1.frame_b, Revolute2.frame_b) annotation (points=[41,10;
              70,10; 70,-9],     style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FixedTranslation1.frame_a, Revolute2.frame_a) annotation (
            points=[70,-39; 70,-31], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FixedTranslation4.frame_a, Revolute1.frame_a) annotation (
            points=[-10,-39; -10,-35; -10,-35; -10,-31], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Body2.frame_a, FixedTranslation1.frame_b) annotation (points=[
              77,-80; 70,-80; 70,-61], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(PlanarRevolute1.frame_b, FixedTranslation1.frame_b) annotation (
           points=[41,-80; 70,-80; 70,-61], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(PlanarRevolute1.frame_a, FixedTranslation4.frame_b) annotation (
           points=[19,-80; -10,-80; -10,-61], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Revolute3.frame_a, Fixed1.frame_b) annotation (points=[-71,10;
              -79,10], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Body1.frame_a, Revolute3.frame_b) annotation (points=[-30,19;
              -30,10; -49,10], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Revolute3.frame_b, Revolute1.frame_b) annotation (points=[-49,10;
              -10,10; -10,-9],     style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Prismatic1.frame_a, Revolute3.frame_b) annotation (points=[19,10;
              -15,10; -15,10; -49,10],
                           style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Revolute4.frame_a, Revolute3.frame_b) annotation (points=[-10,
              31; -10,10; -49,10], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Revolute5.frame_a, Prismatic1.frame_b) annotation (points=[70,31;
              70,10; 41,10],     style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FixedTranslation2.frame_a, Revolute4.frame_b) annotation (
            points=[-10,59; -10,53], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FixedTranslation3.frame_b, Revolute5.frame_b) annotation (
            points=[70,59; 70,53], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(PlanarRevolute2.frame_b, FixedTranslation3.frame_a) annotation (
           points=[41,90; 70,90; 70,81], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Body3.frame_a, PlanarRevolute2.frame_b) annotation (points=[79,90;
              41,90],     style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FixedTranslation2.frame_b, PlanarRevolute2.frame_a) annotation (
           points=[-10,81; -10,90; 19,90], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(torque.flange_b, Revolute3.axis) annotation (points=[-54,-30;
              -53,-30; -53,3], style(
            color=0,
            rgbcolor={0,0,0},
            pattern=0));
        connect(t.y, torque.tau) annotation (points=[-79,-30; -75,-30], style(
            color=74,
            rgbcolor={0,0,127},
            pattern=0));
        connect(springDamper.flange_a, Prismatic1.bearing) annotation (points=[22,-16;
              16,-16; 16,3; 24,3],         style(color=58, rgbcolor={0,127,0}));
        connect(springDamper.flange_b, Prismatic1.axis) annotation (points=[41.9,-16;
              41.9,4; 38,4; 38,3; 37,3],           style(color=58, rgbcolor={0,
                127,0}));
      end CentrifugalForce;

      model NewtonsCradleWeak
        "an implementation of Newton's cradle with weak collision models"
                 extends Modelica.Icons.Example;

        inner World3D world3D(nominalLength=5,
          animateWorld=false,
          animateGravity=false)                annotation (extent=[-100,-100;
              -80,-80]);
        annotation (Diagram, experiment(StopTime=10, NumberOfIntervals=2500),
      preferedView="info", Documentation(info="<html>
This example presents an implementation of newton's cradle
using a continuous collision model.
<p>
<img src=\"../Images/NewtonsCradleWeak.png\">
</p>
<p>
Although the virtual springs of the collision elements are chosen to be very stiff, the results are extremly poor.This example demonstrates the need for impuls modeling.
</html>"));
        Parts.Body Body1(
          m=2,
          I_21=0,
          I_31=0,
          I_32=0,
          sphereDiameter=0.5,
          I_11=0,
          I_22=0,
          I_33=0)    annotation (extent=[-100,-40; -80,-20],rotation=270);
        Parts.Fixed Fixed1 annotation (extent=[-100,70; -80,90],rotation=270);
        Joints.Revolute Revolute1(initType=Modelica.Mechanics.MultiBody.Types.Init.
              PositionVelocity,
          w_start=0,
          enforceStates=true,
          n={0,0,1},
          phi_start=-30)        annotation (extent=[-100,30; -80,50],rotation=
              270);
        Parts.FixedTranslation FixedTranslation1(r={0,-2,0})
          annotation (extent=[-100,-6; -80,14],rotation=270);
        Joints.Revolute Revolute2(
          initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
          n={0,0,1},
          w_start=0,
          enforceStates=true,
          phi_start=-30)
          annotation (extent=[-54,30; -34,50], rotation=270);
        Parts.Body Body2(
          m=2,
          I_21=0,
          I_31=0,
          I_32=0,
          sphereDiameter=0.5,
          I_11=0,
          I_22=0,
          I_33=0)    annotation (extent=[-54,-40; -34,-20],
                                                          rotation=270);
        Parts.Fixed Fixed2(r={0.5,0,0})
                           annotation (extent=[-54,70; -34,90],
                                                              rotation=270);
        Parts.FixedTranslation FixedTranslation6(r={0,-2,0})
          annotation (extent=[-54,-6; -34,14],
                                             rotation=270);
        Forces.SoftImpuls_SphereSphere SoftImpuls_SphereSphere1(
          ra=0.25,
          rb=0.25,
          c=1e09) annotation (extent=[-76,-28; -56,-8]);
        Joints.Revolute Revolute3(
          initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
          n={0,0,1},
          w_start=0,
          enforceStates=true,
          phi_start=0)
          annotation (extent=[-10,30; 10,50],  rotation=270);
        Parts.Body Body3(
          m=2,
          I_21=0,
          I_31=0,
          I_32=0,
          sphereDiameter=0.5,
          I_11=0,
          I_22=0,
          I_33=0)    annotation (extent=[-10,-40; 10,-20],rotation=270);
        Parts.Fixed Fixed3(r={1,0,0})
                           annotation (extent=[-10,70; 10,90],rotation=270);
        Parts.FixedTranslation FixedTranslation2(r={0,-2,0})
          annotation (extent=[-10,-6; 10,14],rotation=270);
        Forces.SoftImpuls_SphereSphere SoftImpuls_SphereSphere2(
          ra=0.25,
          rb=0.25,
          c=1e09) annotation (extent=[-32,-28; -12,-8]);
        Joints.Revolute Revolute4(
          initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
          n={0,0,1},
          w_start=0,
          enforceStates=true,
          phi_start=0)
          annotation (extent=[36,30; 56,50],   rotation=270);
        Parts.Body Body4(
          m=2,
          I_21=0,
          I_31=0,
          I_32=0,
          sphereDiameter=0.5,
          I_11=0,
          I_22=0,
          I_33=0)    annotation (extent=[36,-40; 56,-20], rotation=270);
        Parts.Fixed Fixed4(r={1.5,0,0})
                           annotation (extent=[36,70; 56,90], rotation=270);
        Parts.FixedTranslation FixedTranslation3(r={0,-2,0})
          annotation (extent=[36,-6; 56,14], rotation=270);
        Forces.SoftImpuls_SphereSphere SoftImpuls_SphereSphere3(
          ra=0.25,
          rb=0.25,
          c=1e09) annotation (extent=[14,-28; 34,-8]);
        Joints.Revolute Revolute5(
          initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
          n={0,0,1},
          w_start=0,
          enforceStates=true,
          phi_start=0)
          annotation (extent=[80,30; 100,50],  rotation=270);
        Parts.Body Body5(
          m=2,
          I_21=0,
          I_31=0,
          I_32=0,
          sphereDiameter=0.5,
          I_11=0,
          I_22=0,
          I_33=0)    annotation (extent=[80,-40; 100,-20],rotation=270);
        Parts.Fixed Fixed5(r={2,0,0})
                           annotation (extent=[80,70; 100,90],rotation=270);
        Parts.FixedTranslation FixedTranslation4(r={0,-2,0})
          annotation (extent=[80,-6; 100,14],rotation=270);
        Forces.SoftImpuls_SphereSphere SoftImpuls_SphereSphere4(
          ra=0.25,
          rb=0.25,
          c=1e09) annotation (extent=[58,-28; 78,-8]);
        Parts.FixedTranslation FixedTranslation5(r={2,0,0})
          annotation (extent=[-74,62; -62,76], rotation=0);
      equation
        connect(Body2.frame_a, FixedTranslation6.frame_b) annotation (points=[-44,-19;
              -44,-7], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FixedTranslation1.frame_b, Body1.frame_a) annotation (points=[-90,-7;
              -90,-19],
                      style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Revolute1.frame_a, Fixed1.frame_b) annotation (points=[-90,51;
              -90,69],
            style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Revolute2.frame_a, Fixed2.frame_b) annotation (points=[-44,51;
              -44,69],                                style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FixedTranslation1.frame_a, Revolute1.frame_b) annotation (
            points=[-90,15; -90,29],                                     style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FixedTranslation6.frame_a, Revolute2.frame_b) annotation (
            points=[-44,15; -44,29],                               style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(SoftImpuls_SphereSphere1.frame_b, Body2.frame_a) annotation (
            points=[-55,-18; -52.5,-18; -52.5,-19; -44,-19], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(SoftImpuls_SphereSphere1.frame_a, Body1.frame_a) annotation (
            points=[-77,-18; -79.5,-18; -79.5,-19; -90,-19], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Body3.frame_a,FixedTranslation2. frame_b) annotation (points=[
              2.0206e-015,-19; 2.0206e-015,-16; 0,-16; 0,-7; -2.0206e-015,-7],
                       style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Revolute3.frame_a,Fixed3. frame_b) annotation (points=[
              2.0206e-015,51; 2.0206e-015,55.5; 0,55.5; 0,69; -2.0206e-015,69],
                                                      style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FixedTranslation2.frame_a,Revolute3. frame_b) annotation (
            points=[2.0206e-015,15; 2.0206e-015,18.5; 0,18.5; 0,29;
              -2.0206e-015,29],                                    style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(SoftImpuls_SphereSphere2.frame_b, Body3.frame_a) annotation (
            points=[-11,-18; -8.5,-18; -8.5,-19; 2.0206e-015,-19], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(SoftImpuls_SphereSphere2.frame_a, Body2.frame_a) annotation (
            points=[-33,-18; -32.5,-18; -32.5,-19; -44,-19], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Body4.frame_a,FixedTranslation3. frame_b) annotation (points=[46,-19;
              46,-7],  style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Revolute4.frame_a,Fixed4. frame_b) annotation (points=[46,51;
              46,69],                                 style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FixedTranslation3.frame_a,Revolute4. frame_b) annotation (
            points=[46,15; 46,29],                                 style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(SoftImpuls_SphereSphere3.frame_b, Body4.frame_a) annotation (
            points=[35,-18; 37.5,-18; 37.5,-19; 46,-19], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Body5.frame_a,FixedTranslation4. frame_b) annotation (points=[90,-19;
              90,-7],  style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Revolute5.frame_a,Fixed5. frame_b) annotation (points=[90,51;
              90,69],                                 style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FixedTranslation4.frame_a,Revolute5. frame_b) annotation (
            points=[90,15; 90,29],                                 style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(SoftImpuls_SphereSphere4.frame_b, Body5.frame_a) annotation (
            points=[79,-18; 81.5,-18; 81.5,-19; 90,-19], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(SoftImpuls_SphereSphere4.frame_a, Body4.frame_a) annotation (
            points=[57,-18; 57.5,-18; 57.5,-19; 46,-19], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(SoftImpuls_SphereSphere3.frame_a, Body3.frame_a) annotation (
            points=[13,-18; 6,-18; 6,-19; 2.0206e-015,-19], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FixedTranslation5.frame_a, Fixed1.frame_b) annotation (points=[
              -74.6,69; -90,69], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
      end NewtonsCradleWeak;

      model ThreeBodySystem "three bodies attracting each other"
                 extends Modelica.Icons.Example;

        inner World3D world3D(nominalLength=5, g=0,
          gravityPoolSize=3)                   annotation (extent=[-80,0; -60,
              20]);
        annotation (Diagram, experiment(StopTime=10, NumberOfIntervals=2500),
      preferedView="info", Documentation(info="<html>
This example presents a system of three freely moving, mutually attracting bodies. The attraction is due to gravity.
<p>
<img src=\"../Images/3Body.png\">
</p>
<p>
This model demonstrates the usage of the gravity pool, which is included in the world model.
The gravityPoolSize of the world model is set to 3 and each body element has a unique value of the parameter  GPIndex in the range of 1 to 3.
<p>
You can also observe in this example, that freely moving body elements do not need to be connected to a free body movement joint.
</html>"));
        Parts.Body Body1(
          I_11=0.02,
          I_22=0.02,
          I_33=0.02,
          I_21=0,
          I_31=0,
          I_32=0,
          initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
          useQuaternions=true,
          m=1e11,
          GPIndex=1,
          v_start={0,0.8,0},
          x_start={3,0,0})
               annotation (extent=[0,40; 20,60]);
        Parts.Body Body2(
          I_11=0.02,
          I_22=0.02,
          I_33=0.02,
          I_21=0,
          I_31=0,
          I_32=0,
          initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
          useQuaternions=true,
          m=1e11,
          GPIndex=2,
          v_start={0,-0.8,0},
          x_start={-3,0,0})
               annotation (extent=[0,0; 20,20]);
        Parts.Body Body3(
          I_11=0.02,
          I_22=0.02,
          I_33=0.02,
          I_21=0,
          I_31=0,
          I_32=0,
          initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
          useQuaternions=true,
          m=1e11,
          GPIndex=3,
          v_start={0,0,0.8},
          x_start={0,0,-3})
               annotation (extent=[2,-40; 22,-20]);
      end ThreeBodySystem;

    end Examples;
  end Mechanics3D;

  package Mechanics3DwithImpulses "A library of hybrid 3D-mechanical models."
    extends Modelica.Icons.Library;
    model World3D
      "world element of the 3D-mechanicsWorld coordinate system + gravity field + default animation definition"
                   extends Mechanics3D.World3D;

    annotation (defaultComponentName="world3D",
        defaultComponentPrefixes="inner",preferedView="info",
        Documentation(info="<html>
This is the World3D model.
This model is an extended copy of the Modelica.Mechanics.MultiBody.World model.
<p>
This world model serves several purposes:
<ul>
<li>It visualizes the origin of the inertial system in the animation window.
<li>It sets the default parameters for the animation of all basic elements.
<li>It models a global gravity field. (either uniform gravity or point gravity)
<li>It constains a gravity pool to model the mutual gravitiational attraction between body elements.
</ul>
<p>
Since the gravity field function is required from all bodies with mass
and the default settings of animation properties are required
from nearly every component, exactly one instance of model World3D needs
to be present in every model on the top level. The basic declaration
needs to be:
</p>
<pre>
    <b>inner</b> Mechanics3D.World3D world3D
</pre>
<p>
Note, it must be an <b>inner</b> declaration with instance name <b>world3D</b>
in order that this world object can be accessed from all objects in the
model. When dragging the \"World3D\" object from the package browser into
the diagram layer, this declaration is automatically generated
(this is defined via annotations in model World).
</p>
<p>
To use the the gravity pool, set the parameter gravityPoolSize to the number
of bodies you'd like to have in your pool. Then give each body in the pool
a different index number from 1 to gravityPoolSize.
The index number can be set by the parameter GPindex of the body element.
</p>
</html>"));

    end World3D;

    model CollisionPool "collision pool"

      import SI = Modelica.SIunits;

    annotation (defaultComponentName="collisionPool",
        defaultComponentPrefixes="inner",preferedView="info",
        Documentation(info="<html>
This is the model of the collision pool.
<p>
The collision pool contains a finite set of spherical bodies and models all possible mutual collisions
between them.
<h3>Usage</h3>
To use the the collision pool, set the parameter collisionPoolSize to the number
of bodies you'd like to have in your pool. Then give each body in the pool
a different index number from 1 to collsionPoolSize.
The index number can be set by the parameter CPindex of the body element.
The contact signal needs to be the propagated to the mechanical system by the \"InsertImpulse\" element.
<h3>Important note</h3>
Exactly one instance of model CollisionPool needs
to be present in every model on the top level. The basic declaration
needs to be:
</p>
<pre>
    <b>inner</b> Mechanics3DwithImpulses.CollisionPool collisionPool
</pre>
</html>"));

      annotation (Coordsys(
          extent=[-100, -100; 100, 100],
          grid=[2, 2],
          component=[20, 20]),
        Window(
          x=0.13,
          y=0.1,
          width=0.81,
          height=0.83),
        Icon(
          Rectangle(extent=[-100,100; 100,-100],style(
              pattern=0,
              fillColor=7,
              rgbfillColor={255,255,255})),
          Ellipse(extent=[24,-38; 66,-78], style(
              pattern=0,
              gradient=3,
              fillColor=7,
              rgbfillColor={255,255,255})),
          Text(extent=[-140, 165; 140, 103], string="%name"),
          Text(
            extent=[-76,-104; 72,-128],
            string="%poolSize",
            style(color=0, rgbcolor={0,0,0})),
          Ellipse(extent=[12,-26; 54,-66], style(
              pattern=0,
              gradient=3,
              fillColor=68,
              rgbfillColor={170,213,255})),
          Ellipse(extent=[0,-12; 42,-52],  style(
              pattern=0,
              gradient=3,
              fillColor=69,
              rgbfillColor={1,128,255})),
          Ellipse(extent=[-90,12; -48,-28], style(
              pattern=0,
              gradient=3,
              fillColor=7,
              rgbfillColor={255,255,255})),
          Ellipse(extent=[-70,12; -28,-28], style(
              pattern=0,
              gradient=3,
              fillColor=68,
              rgbfillColor={170,213,255})),
          Ellipse(extent=[-50,12; -8,-28], style(
              pattern=0,
              gradient=3,
              fillColor=69,
              rgbfillColor={1,128,255})),
          Ellipse(extent=[20,72; 62,32], style(
              pattern=0,
              gradient=3,
              fillColor=7,
              rgbfillColor={255,255,255})),
          Ellipse(extent=[10,56; 52,16], style(
              pattern=0,
              gradient=3,
              fillColor=68,
              rgbfillColor={170,213,255})),
          Ellipse(extent=[0,40; 42,0],     style(
              pattern=0,
              gradient=3,
              fillColor=69,
              rgbfillColor={1,128,255})),
          Line(points=[6,-8; 70,-8],    style(color=2, rgbcolor={0,255,0})),
          Line(points=[-24,32; 6,-8],   style(color=2, rgbcolor={0,255,0})),
          Line(points=[-22,-48; 6,-8],  style(color=2, rgbcolor={0,255,0}))),
        Diagram);

      parameter Integer poolSize = 0;
      final parameter Integer collisionCount = integer(poolSize*(poolSize-1)/2);
      Interfaces.IFrame frames[poolSize];
      Modelica.Blocks.Interfaces.BooleanOutput[poolSize,poolSize] y;

    //  Types.CollisionObject COs[poolSize];

      Contacts.CollisionSphereSphere Collisions[collisionCount](
      each ra=0.1,
      each rb=0.1,
      each elasticity = 1.0,
      each muR = 0.0);

    protected
      function collisionIndex
        input Integer a;
        input Integer b;
        input Integer n;
        output Integer ind;
      algorithm
        ind := (b-1) + integer( ((n-1)*(n-2) - (n-1-a)*(n-a))/2);
      end collisionIndex;

    equation
      for i in 1:poolSize loop
         for i2 in (i+1):poolSize loop
            connect(Collisions[collisionIndex(i,i2,poolSize)].frame_a,frames[i]);
            connect(Collisions[collisionIndex(i,i2,poolSize)].frame_b,frames[i2]);
            y[i,i2] = Collisions[collisionIndex(i,i2,poolSize)].y;
            y[i2,i] = Collisions[collisionIndex(i,i2,poolSize)].y;
         end for;
         y[i,i] = false;
      end for;

    end CollisionPool;

    package Interfaces "connector elements"
      connector IFrame "hybrid connector for the mechanical components"
                       extends Mechanics3D.Interfaces.Frame;
        import SI = Modelica.SIunits;

        Boolean contact;
        SI.Velocity Vm[3];
        SI.AngularVelocity Wm[3];
        flow SI.Impulse F[3];
        flow SI.AngularImpulse T[3];

        annotation (Documentation(info="<html>
This is the basic impulse mechanical connector type.
It is an extension of the continuous connector Mechanics3D.Interfaces.Frame.
<p>
The extension adds the following potential variables:
<ul>
<li>average translational velocity: real Vm[3];
<li>average angular velocity: real Wm[3];
<li>contact signal: boolean contact;
</ul>
<p>
The extension adds the following flow variables:
<ul>
<li>force impulse: real F[3];
<li>torque impulse: real T[3];
</ul>
<p>
<p>
The variables Wm and T are resolved in their body system, that is specified by the orientation R.
All other additional variables are resolved in the inertial system.
<p>
Do not use this connector directly! Use its two inheritors Frame_a and Frame_b.
</html>"));
      end IFrame;
    annotation (Icon(
          Polygon(points=[-100,50; -80,70; 100,70; 80,50; -100,50],      style(
              color=58,
              fillColor=30,
              fillPattern=1)),
          Text(
            extent=[-85,35; 65,-85],
            string="Library",
            style(color=58)),
          Rectangle(extent=[-100,-100; 80,50],   style(
              color=58,
              fillColor=30,
              fillPattern=1)),
          Polygon(points=[100,70; 100,-80; 80,-100; 80,50; 100,70],      style(
              color=58,
              fillColor=30,
              fillPattern=1)),
          Text(
            extent=[-120,122; 120,73],
            style(color=1),
          string="%name"),
          Text(
            extent=[-85,35; 65,-85],
            string="Library",
            style(color=58))), preferedView="info", Documentation(info="<html>
This package contains the basic connectors of the impulse mechanical elements.
There are two connector types IFrame_a and IFrame_b, but their only difference is the symbol and the name.
They both contain exactly the same variables and are therefore semantically identical.
<p>
The package contains two converter elements, that enable the comfortable wrapping of the continuos bondgraphic models.
</html>"));

      connector IFrame_a "hybrid connector for the mechanical components"
        annotation(defaultComponentName="frame_a");
        extends IFrame;

        annotation (defaultComponentName="frame_a",
                Diagram,                       Icon(Rectangle(extent=[0,100;
                  100,-100], style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=47,
                rgbfillColor={255,170,85})),  Text(
              extent=[-98,-94; 102,-138],
              style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1),
              string="%name")),
          Documentation(info="<html>
This is a connector for impulse mechanical components. It inherits all its variables
from the basic connector type 'IFrame'.
</html>"));
      end IFrame_a;

      connector IFrame_b "hybrid connector for the mechanical components"
        annotation(defaultComponentName="frame_b");
        extends IFrame;

        annotation (defaultComponentName="frame_b",
                Diagram,                       Icon(Rectangle(extent=[-100,100;
                  0,-100], style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=51,
                rgbfillColor={255,255,170})), Text(
              extent=[-90,-96; 110,-140],
              style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1),
              string="%name")),
          Documentation(info="<html>
This is a connector for impulse mechanical components. It inherits all its variables
from the basic connector type 'IFrame'.
</html>"));
      end IFrame_b;

      model MBG2IMech "links the bond graph with the mechanic connector"
        import MultiBondLib;
        annotation (Icon(
            Line(points=[-80,-180; -80,-20; 80,-20; -80,-180],
                                                           style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[-80,0; -94,0], style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Text(
              extent=[-60,-80; 20,-40],
              style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1),
              string="MBG"),
            Text(
              extent=[-20,-176; 60,-120],
              style(
                color=10,
                rgbcolor={135,135,135},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1),
              string="M 3D"),
            Line(points=[-60,-100; 60,-100; 40,-80; 60,-100; 40,-120],
                                                            style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[-80,-180; 80,-180; 80,-20; -80,-180],
                                                           style(
                color=10,
                rgbcolor={135,135,135},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[-80,-400; -80,200],
                                           style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[-80,-200; -100,-200],
                                           style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[-80,-400; -100,-400],
                                           style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[-80,0; -100,0],   style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[-80,200; -100,200],
                                           style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Text(
              extent=[-82,242; 2,164],
              string="T",
              style(color=71, rgbcolor={85,170,255})),
            Text(
              extent=[-78,-358; 6,-436],
              style(color=71, rgbcolor={85,170,255}),
              string="R")),       Diagram(
            Line(points=[-80,-180; -80,-20; 80,-20; -80,-180],
                                                           style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[-80,0; -94,0], style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Text(
              extent=[-60,-80; 20,-40],
              style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1),
              string="MBG"),
            Text(
              extent=[-20,-174; 60,-120],
              style(
                color=10,
                rgbcolor={135,135,135},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1),
              string="M 3D"),
            Line(points=[-60,-100; 60,-100; 40,-80; 60,-100; 40,-120],
                                                            style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[-80,-180; 80,-180; 80,-20; -80,-180],
                                                           style(
                color=10,
                rgbcolor={135,135,135},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[-80,-400; -80,200],
                                           style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[-80,200; -100,200],
                                           style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[-80,0; -100,0],   style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[-80,-400; -100,-400],
                                           style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[-80,-200; -100,-200],
                                           style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Text(
              extent=[-82,238; 2,160],
              string="T",
              style(color=71, rgbcolor={85,170,255})),
            Text(
              extent=[-78,-362; 6,-440],
              style(color=71, rgbcolor={85,170,255}),
              string="R")),
          Coordsys(extent=[-100,-500; 100,300]),
          Documentation(info="<html>
This is a converter element. The signals and bond connections of a bondgraphic model
are converted into variables of the impulse mechanical connector. This element enables the wrapping of bondgraphic models and is acausal.
<p>
The converter element replaces the classic converter elements of the inherited continuous models.
</html>"));
        MultiBondLib.Interfaces.MultiBondCon MultiBondConTrans(n=3)
          annotation (extent=[-110,190; -90,210]);
        IFrame_b frame_b
                        annotation (extent=[80,-120; 100,-80]);
        MultiBondLib.Interfaces.RealSignal x[3]
          annotation (extent=[-110,-10; -90,10]);
        MultiBondLib.Interfaces.RealSignal R[3,3]
          annotation (extent=[-110,-210; -90,-190]);
        MultiBondLib.Interfaces.MultiBondCon MultiBondConRot(n=3)
          annotation (extent=[-110,-410; -90,-390]);
      equation
        MultiBondConTrans.e*MultiBondConTrans.d = frame_b.f;
        MultiBondConRot.e*MultiBondConRot.d = frame_b.t;

        MultiBondConTrans.f = frame_b.P.v;
        MultiBondConRot.f = frame_b.P.w;

        x = frame_b.P.x;
        R = frame_b.P.R;
      end MBG2IMech;

      model IMech2MBG "links the bond graph with the mechanic connector"
        import MultiBondLib;
        annotation (Icon(
            Line(points=[-80,-180; -80,-20; 80,-20; -80,-180],
                                                           style(
                color=10,
                rgbcolor={135,135,135},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[-80,-180; 80,-180; 80,-20; -80,-180],
                                                           style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[94,0; 80,0], style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Text(
              extent=[-10,-160; 70,-120],
              style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1),
              string="MBG"),
            Text(
              extent=[-70,-100; 20,-30],
              style(
                color=10,
                rgbcolor={135,135,135},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1),
              string="M 3D"),
            Line(points=[-60,-100; 60,-100; 40,-80; 60,-100; 40,-120],
                                                            style(
                color=10,
                rgbcolor={135,135,135},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[100,200; 80,200], style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[80,-400; 80,200], style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[100,0; 80,0],     style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[100,-200; 80,-200],
                                           style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[100,-400; 80,-400],
                                           style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Text(
              extent=[-6,238; 78,160],
              string="T",
              style(color=71, rgbcolor={85,170,255})),
            Text(
              extent=[-2,-362; 82,-440],
              style(color=71, rgbcolor={85,170,255}),
              string="R")),       Diagram(
            Line(points=[-80,-180; -80,-20; 80,-20; -80,-180],
                                                           style(
                color=10,
                rgbcolor={135,135,135},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[-80,-180; 80,-180; 80,-20; -80,-180],
                                                           style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[94,0; 80,0], style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Text(
              extent=[-10,-160; 70,-120],
              style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1),
              string="MBG"),
            Text(
              extent=[-68,-92; 18,-30],
              style(
                color=10,
                rgbcolor={135,135,135},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1),
              string="M 3D"),
            Line(points=[-60,-100; 60,-100; 40,-80; 60,-100; 40,-120],
                                                            style(
                color=10,
                rgbcolor={135,135,135},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[100,0; 80,0],     style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[100,200; 80,200], style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[100,-200; 80,-200],
                                           style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[100,-400; 80,-400],
                                           style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[80,-400; 80,200], style(
                color=71,
                rgbcolor={85,170,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Text(
              extent=[-6,238; 78,160],
              string="T",
              style(color=71, rgbcolor={85,170,255})),
            Text(
              extent=[-2,-362; 82,-440],
              style(color=71, rgbcolor={85,170,255}),
              string="R")),
          Coordsys(extent=[-100,-500; 100,300]),
          Documentation(info="<html>
This is a converter element. The signals and bond connections of a bondgraphic model
are converted into variables of the impulse mechanical connector. This element enables the wrapping of bondgraphic
models and is acausal.
<p>
The converter element replaces the classic converter elements of the inherited continuous models.
</html>"));
        IFrame_a frame_a
                        annotation (extent=[-100,-120; -80,-80]);
        MultiBondLib.Interfaces.MultiBondCon MultiBondConRot(n=3)
          annotation (extent=[92,-410; 112,-390]);
        MultiBondLib.Interfaces.RealSignal x[3] annotation (extent=[90,-10; 110,10]);
        MultiBondLib.Interfaces.RealSignal R[3,3]
                                                annotation (extent=[90,-210; 110,-190]);
        MultiBondLib.Interfaces.MultiBondCon MultiBondConTrans(n=3)
          annotation (extent=[90,190; 110,210]);
      equation
        MultiBondConTrans.e*MultiBondConTrans.d = frame_a.f;
        MultiBondConRot.e*MultiBondConRot.d = frame_a.t;

        MultiBondConTrans.f = frame_a.P.v;
        MultiBondConRot.f = frame_a.P.w;

        x = frame_a.P.x;
        R = frame_a.P.R;
      end IMech2MBG;

      model InsertImpulse
        "introduces the contact signal to the mechanic system"
        IFrame_a frame_a annotation (extent=[-80,-20; -60,20]);
        IFrame_b frame_b annotation (extent=[60,-20; 80,20]);
        annotation (Diagram, Icon(
            Line(points=[-60,0; -20,0], style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[18,0; 60,0], style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[0,20; 0,60], style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Ellipse(extent=[-20,20; 20,-20], style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1))),
          Documentation(info="<html>
This interface inducts the contact signal into a mechanical subsystem.
The origin of the contact signal is contact element.
<p>
The \"InsertImpulse\" element can also recieve several contact signals from
the collision pool. Just add the corresponding inex numbers to the parameter vector
\"CPIndedces\". Theses contact signals are automatically merged.
</html>"));
        Modelica.Blocks.Interfaces.BooleanInput u
          annotation (extent=[-10,60; 10,80], rotation=270);
        parameter Integer[:] CPIndeces = zeros(0);

      protected
        outer CollisionPool collisionPool;
        Boolean u2;
      algorithm
        u2 := false;
        for i2 in CPIndeces loop
          for i in 1:collisionPool.poolSize loop
            u2 := u2 or (collisionPool.y[i2,i]);
          end for;
        end for;

      equation
        connect(frame_a, frame_b) annotation (points=[-70,0; 70,0], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        frame_b.contact = u;
        if size(CPIndeces,1) > 0 then
          u = u2;
        end if;

      end InsertImpulse;

      model ConnectContinousFrame "interface to the continuous models"
        IFrame_b frame_b annotation (extent=[60,-20; 80,20]);
        annotation (Diagram, Icon(Line(points=[-60,0; 60,0], style(
                color=0,
                rgbcolor={0,0,0},
                pattern=2,
                thickness=2,
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1))),
          Documentation(info="<html>
This interface model enables connections between the hybrid impulse mechanical components of this library
and purely continuous components of the Mechanics3D library.
<p>
A force impulse is not transmitted through this element.
</html>"));
        Mechanics3D.Interfaces.Frame_a frame_a
          annotation (extent=[-80,-20; -60,20]);
      equation
        defineBranch(frame_a.P, frame_b.P);
        frame_a.P = frame_b.P;
        frame_a.f + frame_b.f = zeros(3);
        frame_a.t + frame_b.t = zeros(3);
        frame_b.F = zeros(3);
        frame_b.T = zeros(3);

      end ConnectContinousFrame;

    end Interfaces;

    package Contacts "contact models"
      extends Modelica.Icons.Library;
      model CollisionSpherePlane
        "models the collision between a spheres and a plane"
        import SI = Modelica.SIunits;
        Interfaces.IFrame_a frame_a annotation (extent=[-120,-20; -100,20]);
        annotation (Diagram, Icon(
            Line(points=[0,40; 0,-40], style(
                color=2,
                rgbcolor={0,255,0},
                gradient=3,
                fillColor=75,
                rgbfillColor={85,133,255})),
                                  Line(points=[0,40; 0,60],    style(
                color=0,
                rgbcolor={0,0,0},
                fillColor=51,
                rgbfillColor={255,255,170},
                fillPattern=1)),
            Line(points=[-100,0; -100,0; -70,0],
                                               style(color=0, rgbcolor={0,0,0})),
            Ellipse(extent=[-70,30; -10,-30], style(
                pattern=0,
                gradient=3,
                fillColor=75,
                rgbfillColor={85,133,255})),
            Ellipse(extent=[-4,4; 4,-4], style(
                pattern=0,
                gradient=3,
                fillColor=2,
                rgbfillColor={0,255,0})),
            Line(points=[82,0; 60,0; 100,0],   style(color=0, rgbcolor={0,0,0})),
            Line(points=[10,-2; 10,-40],style(
                color=2,
                rgbcolor={0,255,0},
                gradient=3,
                fillColor=75,
                rgbfillColor={85,133,255})),
            Line(points=[-4,-4; -14,-40], style(
                color=2,
                rgbcolor={0,255,0},
                gradient=3,
                fillColor=75,
                rgbfillColor={85,133,255})),
            Line(points=[-14,40; -4,4], style(
                color=2,
                rgbcolor={0,255,0},
                gradient=3,
                fillColor=75,
                rgbfillColor={85,133,255})),
            Line(points=[10,40; 10,2],style(
                color=2,
                rgbcolor={0,255,0},
                gradient=3,
                fillColor=75,
                rgbfillColor={85,133,255})),
            Text(
              extent=[-100,-38; 100,-90],
              string="%name",
              style(
                color=3,
                rgbcolor={0,0,255},
                gradient=3,
                fillColor=30,
                rgbfillColor={215,215,215})),
            Text(
              extent=[-64,-34; -96,-4],
              string="a",
              style(
                color=9,
                rgbcolor={175,175,175},
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1)),
            Text(
              extent=[100,-50; 68,-20],
              style(
                color=9,
                rgbcolor={175,175,175},
                pattern=0,
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1),
              string="b"),
            Rectangle(extent=[20,40; 60,-40], style(
                color=3,
                rgbcolor={0,0,255},
                gradient=1,
                fillColor=75,
                rgbfillColor={85,85,255}))),
          Documentation(info="<html>
This element models the collision between a sphere surrounding  frame a and a plane throughgoing frame b.
<p>
The collision is modelled by three impulses that are separated by a very small timespan.<br>
The first impulse models the reflection law. The second impulse models the effect of friction.<br>
The third impulse models a necessary correction if the friction impulse was too strong and caused a reflection.
<h3>General parameters</h3>
The charactisitics of the impact can be set by the parameters:
<ul>
<li>elasticity: The elasticity coefficient.
<li>muR: The friction coefficient.
</ul>
<p>
The characteristics of the geometry can be set by the parameters:
<ul>
<li>ra: The sphere radius.
<li>Nb: normal vector of the plane, pointing from inside to outside.
</ul>
<h3>Visualization</h3>
The element isn't visualized.
<h3>Advanced settings</h3>
A collision causes three consecutive impulses. The parameter contactDuration determines
the timespan between the first and the last impulse. It is usually very small.
<p>
The parameter s_small in the advanced menu reduces the stiffness of the friction
for slip velocities in the range from zero up to s_small.
</html>"));

        parameter SI.Radius ra = 1 "radius of sphere at frame a";
        parameter SI.Radius Nb[3] = {0,1,0} "normal vector of plane";

        parameter SI.Position s_small = 1e-4 "|Advanced||critical length";

        parameter Real elasticity = 1.0 "Elasticity of impuls";
        parameter Real muR = 0.0 "friction coefficient";

        parameter Real contactDuration =   1e-9
          "|Advanced||time to handle the impulses";

      protected
        Real[3,3] R_a "orientation of frame a at the impulse time";
        Real[3,3] R_b "orientation of frame a at the impulse time";

        SI.Distance d "distance vector from sphere center to plane";
        Real eR[3] "normalized variant of d";
        Real noteR[3] "a vector that has any value but not r";
        Real eA[3] "unit vector that is normal to r";
        Real eB[3] "unit vector that is normal to r and eA.";
        //eR, eA, eB build up an orthonormal coordinate system, where eR is pointing in contact direction.

        Boolean contact "contact signal";
        Integer seqState
          "state in the impluse sequence (0=impact, 1=friction, 2=correction)";
        Real frictionImpulseTime "time of the succeeding friction Impulse";
        Real correctionImpulseTime "time of the succeeding correction Impulse";

        SI.Impulse F[3] "force impulse between the two frames";
        SI.Velocity vA[3]
          "rel. velocity of the two frames right before the impulse";
        SI.Velocity Vm[3] "average rel. velocity during the impulse";

        //variables of the impact impulse
        SI.Impulse FR "force impulse in direction of eR";
        SI.Impulse FA0 "force impulse in direction of eA";
        SI.Impulse FB0 "force impulse in direction of eB";
        SI.Velocity VmR0 "average velocity in direction of eR";

        //variables of the friction impulse
        SI.Impulse FA1 "force impulse in direction of eA";
        SI.Impulse FB1 "force impulse in direction of eB";
        SI.Impulse FR1 "force impulse in direction of eR";
        SI.Velocity VFricElast[3]
          "becomes non-zero if the friction impulse caused more than an elastic impulse";

        //eC, eD, eE build up an orthonormal coordinate system where eC points into the direction
        //of the lateral velocity difference (slippage)
        Real eC[3];
        Real noteC[3];
        Real eD[3];
        Real eE[3];

        //variables of the correction impulse
        SI.Impulse FD2 "force impulse in direction of eD";
        SI.Impulse FE2 "force impulse in direction of eE";
        SI.Velocity VmC2 "average velocity in direction of eC";

      public
        Modelica.Blocks.Interfaces.BooleanOutput y
          annotation (extent=[10,60; -10,80], rotation=90);
        Interfaces.IFrame_b frame_b annotation (extent=[100,-20; 120,20]);
      initial equation
        contact = false;
        seqState = -1;
        frictionImpulseTime = 0;
        correctionImpulseTime = 0;

      equation

      algorithm
        //reset contact signal to false
        when contact then
          contact :=false;
        end when;

        //detect collision and trigger event
        when d <= ra then
          contact :=true;
          seqState := 0;
          frictionImpulseTime :=time + contactDuration/2;
        end when;

        //trigger event for friction impulse
        when (time >= frictionImpulseTime) and (seqState == 0) then
          contact :=true;
          seqState := 1;
          frictionImpulseTime := 0;
          correctionImpulseTime := time + contactDuration/2;
        end when;

        //trigger event for correction impulse
        when (time >= correctionImpulseTime) and (seqState == 1) then
          contact :=true;
          seqState := 2;
          correctionImpulseTime := 0;
        end when;

      equation

        //build up coordinate system eR, eA, eB at the moment of collision.
        d = (frame_a.P.x- frame_b.P.x)*(transpose(frame_b.P.R)*Nb);
        when contact and (seqState == 0) then
          eR = transpose(R_b)*Nb/sqrt(Nb*Nb);
          noteR = if abs(eR[1]) > 0.1 then {0,1,0} else (if abs(eR[2])
             > 0.1 then {0,0,1} else {1,0,0});
          eA = cross(eR, noteR)/sqrt(cross(eR, noteR)*cross(eR, noteR));
          eB = cross(eA, eR);
        end when;

       //state situation right before the impulse
        when contact then
          vA = (pre(frame_b.P.v)+cross(transpose(R_b)*pre(frame_b.P.w),zeros(3))) -
               (pre(frame_a.P.v)+cross(transpose(R_a)*pre(frame_a.P.w),-eR*ra));
          R_a = frame_a.P.R;
          R_b = frame_b.P.R;
        end when;

       //store the impact impulse in FR
        when contact then
          FR = F*eR;
        end when;

        //impact impulse
        when contact and (seqState == 0) then
          VmR0 = (1-elasticity)*(vA*eR)/2;
          FA0 = 0;
          FB0 = 0;
        end when;

        //friction impulse
        when contact and (seqState == 1) then
          FR1 = 0;
          FA1 = -muR*abs(pre(FR))*((vA/sqrt(vA*vA))*eA);
          FB1 = -muR*abs(pre(FR))*((vA/sqrt(vA*vA))*eB);
          VFricElast[1] = if sign(vA[1])*Vm[1] >= abs(vA[1]/2) then 0 else Vm[1]- (vA[1]/2);
          VFricElast[2] = if sign(vA[2])*Vm[2] >= abs(vA[2]/2) then 0 else Vm[2]- (vA[2]/2);
          VFricElast[3] = if sign(vA[3])*Vm[3] >= abs(vA[3]/2) then 0 else Vm[3]- (vA[3]/2);
        end when;

        //correction impulse
        when contact and (seqState == 2) and (pre(VFricElast)*pre(VFricElast) > 0) then
          eC = if pre(VFricElast)*pre(VFricElast) < s_small^2 then {1,0,0} else
                pre(VFricElast)/sqrt(pre(VFricElast)*pre(VFricElast));
          noteC = if abs(eC[1]) > 0.1 then {0,1,0} else (if abs(eC[2])
             > 0.1 then {0,0,1} else {1,0,0});
          eD = cross(eC, noteC)/sqrt(cross(eC, noteC)*cross(eC, noteC));
          eE = cross(eD, eC);

          VmC2 = sqrt(pre(VFricElast)*pre(VFricElast));
          FD2 = 0;
          FE2 = 0;
        end when;

        //state impulse dependent equations
        if contact then
          if (seqState == 0) then //further equations for the impact impulse
            Vm*eR = VmR0;
            F*eA = FA0;
            F*eB = FB0;
         else
             if (seqState == 1) then //further equations for the friction impulse
               F*eR = FR1;
               F*eA = FA1;
               F*eB = FB1;
           else
              //further equations for the correction impulse
              if (seqState == 2) and (pre(VFricElast)*pre(VFricElast) > 0) then
                Vm*eC = VmC2;
                F*eD = FD2;
                F*eE = FE2;
              else
                F = zeros(3);
              end if;
           end if;
         end if;
        else
          F = zeros(3);
        end if;

        //propagate contact signal
        y = contact;

        //state equations for the translational domain
        Vm = (frame_b.Vm+cross(transpose(R_b)*frame_b.Wm,zeros(3))) -
             (frame_a.Vm+cross(transpose(R_a)*frame_a.Wm,-eR*ra));
        F = -frame_b.F;
        F = frame_a.F;

        //state equations for the rotational domain
        R_b*cross(zeros(3),F) = -frame_b.T;
        R_a*cross(-eR*ra,F) = frame_a.T;

        //define continuous connector variables
        frame_a.f = zeros(3);
        frame_a.t = zeros(3);
        frame_b.f = zeros(3);
        frame_b.t = zeros(3);

      end CollisionSpherePlane;

      model CollisionSphereSphere "models the collision between two spheres"
        import SI = Modelica.SIunits;
        Interfaces.IFrame_a frame_a annotation (extent=[-120,-20; -100,20]);
        annotation (Diagram, Icon(
            Line(points=[0,40; 0,-40], style(
                color=2,
                rgbcolor={0,255,0},
                gradient=3,
                fillColor=75,
                rgbfillColor={85,133,255})),
                                  Line(points=[0,40; 0,60],    style(
                color=0,
                rgbcolor={0,0,0},
                fillColor=51,
                rgbfillColor={255,255,170},
                fillPattern=1)),
            Line(points=[-100,0; -100,0; -70,0],
                                               style(color=0, rgbcolor={0,0,0})),
            Ellipse(extent=[-70,30; -10,-30], style(
                pattern=0,
                gradient=3,
                fillColor=75,
                rgbfillColor={85,133,255})),
            Ellipse(extent=[-4,4; 4,-4], style(
                pattern=0,
                gradient=3,
                fillColor=2,
                rgbfillColor={0,255,0})),
            Ellipse(extent=[14,30; 74,-30], style(
                pattern=0,
                gradient=3,
                fillColor=75,
                rgbfillColor={85,133,255})),
            Line(points=[80,0; 74,0; 100,0],   style(color=0, rgbcolor={0,0,0})),
            Line(points=[4,-4; 12,-40], style(
                color=2,
                rgbcolor={0,255,0},
                gradient=3,
                fillColor=75,
                rgbfillColor={85,133,255})),
            Line(points=[-4,-4; -14,-40], style(
                color=2,
                rgbcolor={0,255,0},
                gradient=3,
                fillColor=75,
                rgbfillColor={85,133,255})),
            Line(points=[-14,40; -4,4], style(
                color=2,
                rgbcolor={0,255,0},
                gradient=3,
                fillColor=75,
                rgbfillColor={85,133,255})),
            Line(points=[14,40; 4,4], style(
                color=2,
                rgbcolor={0,255,0},
                gradient=3,
                fillColor=75,
                rgbfillColor={85,133,255})),
            Text(
              extent=[-100,-38; 100,-90],
              string="%name",
              style(
                color=3,
                rgbcolor={0,0,255},
                gradient=3,
                fillColor=30,
                rgbfillColor={215,215,215})),
            Text(
              extent=[-64,-34; -96,-4],
              string="a",
              style(
                color=9,
                rgbcolor={175,175,175},
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1)),
            Text(
              extent=[100,-50; 68,-20],
              style(
                color=9,
                rgbcolor={175,175,175},
                pattern=0,
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1),
              string="b")),
          Documentation(info="<html>
This element models the collision between two spheres surrounding  frame a and frame b.
<p>
The collision is modelled by three impulses that are separated by a very small timespan.<br>
The first impulse models the reflection law. The second impulse models the effect of friction.<br>
The third impulse models a necessary correction if the friction impulse was too strong and caused a reflection.
<h3>General parameters</h3>
The charactisitics of the impact can be set by the parameters:
<ul>
<li>elasticity: The elasticity coefficient.
<li>muR: The friction coefficient.
</ul>
<p>
The characteristics of the geometry can be set by the parameters:
<ul>
<li>ra: The radius of the sphere surrounding frame a.
<li>rb: The radius of the sphere surrounding frame b.
</ul>
<h3>Visualization</h3>
The element isn't visualized.
<h3>Advanced settings</h3>
A collision causes three consecutive impulses. The parameter contactDuration determines
the timespan between the first and the last impulse. It is usually very small.
<p>
The parameter s_small in the advanced menu reduces the stiffness of the friction
for slip velocities in the range from zero up to s_small.
</html>"));

        parameter SI.Radius ra = 1 "radius of sphere at frame a";
        parameter SI.Radius rb = 1 "radius of sphere at frame b";

        parameter SI.Position s_small = 1e-4 "|Advanced||critical length";

        parameter Real elasticity = 1.0 "Elasticity of impuls";
        parameter Real muR = 0.0 "friction coefficient";

        parameter Real contactDuration =   1e-9
          "|Advanced||time to handle the impulses";

        parameter Boolean useParameters = true
          "|Advanced||use the parameter values.";

        //the following variables are determined by the parameters above if useParameter = true
        SI.Radius ra_ "optional variable radius of sphere at frame a";
        SI.Radius rb_ "optional variable radius of sphere at frame b";

        Real elasticity_ "optional variable elasticity";
        Real muR_ "optional variable friction coefficient";

      protected
        Real[3,3] R_a "orientation of frame a at the impulse time";
        Real[3,3] R_b "orientation of frame a at the impulse time";

        SI.Distance r[3]
          "vector pointing from center of sphere a to center of sphere b";
        Real eR[3] "normalized variant of r";
        Real noteR[3] "a vector that has any value but not r";
        Real eA[3] "unit vector that is normal to r";
        Real eB[3] "unit vector that is normal to r and eA.";
        //eR, eA, eB build up an orthonormal coordinate system, where eR is pointing in contact direction.

        Boolean contact "contact signal";
        Integer seqState
          "state in the impluse sequence (0=impact, 1=friction, 2=correction)";
        Real frictionImpulseTime "time of the succeeding friction Impulse";
        Real correctionImpulseTime "time of the succeeding correction Impulse";

        SI.Impulse F[3] "force impulse between the two frames";
        SI.Velocity vA[3]
          "rel. velocity of the two frames right before the impulse";
        SI.Velocity Vm[3] "average rel. velocity during the impulse";

        //variables of the impact impulse
        SI.Impulse FR "force impulse in direction of eR";
        SI.Impulse FA0 "force impulse in direction of eA";
        SI.Impulse FB0 "force impulse in direction of eB";
        SI.Velocity VmR0 "average velocity in direction of eR";

        //variables of the friction impulse
        SI.Impulse FA1 "force impulse in direction of eA";
        SI.Impulse FB1 "force impulse in direction of eB";
        SI.Impulse FR1 "force impulse in direction of eR";
        SI.Velocity VFricElast[3]
          "becomes non-zero if the friction impulse caused more than an elastic impulse";

        //eC, eD, eE build up an orthonormal coordinate system where eC points into the direction
        //of the lateral velocity difference (slippage)
        Real eC[3];
        Real noteC[3];
        Real eD[3];
        Real eE[3];

        //variables of the correction impulse
        SI.Impulse FD2 "force impulse in direction of eD";
        SI.Impulse FE2 "force impulse in direction of eE";
        SI.Velocity VmC2 "average velocity in direction of eC";

      public
        Modelica.Blocks.Interfaces.BooleanOutput y
          annotation (extent=[10,60; -10,80], rotation=90);
        Interfaces.IFrame_b frame_b annotation (extent=[100,-20; 120,20]);
      initial equation
        contact = false;
        seqState = -1;
        frictionImpulseTime = 0;
        correctionImpulseTime = 0;

      equation

      algorithm
        //reset contact signal to false
        when contact then
          contact :=false;
        end when;

        //detect collision and trigger event
        when sqrt(r*r) <= (ra_+rb_) then
          contact :=true;
          seqState := 0;
         frictionImpulseTime :=time + contactDuration/2;
        end when;

        //trigger event for friction impulse
        when (time >= frictionImpulseTime) and (seqState == 0) then
          contact :=true;
          seqState := 1;
          frictionImpulseTime := 0;
          correctionImpulseTime := time + contactDuration/2;
        end when;

        //trigger event for correction impulse
        when (time >= correctionImpulseTime) and (seqState == 1) then
          contact :=true;
          seqState := 2;
          correctionImpulseTime := 0;
        end when;

      equation
        if useParameters then
          ra_ = ra;
          rb_ = rb;
          elasticity_ = elasticity;
          muR_ = muR;
        end if;

        //build up coordinate system eR, eA, eB at the moment of collision.
        r = frame_b.P.x- frame_a.P.x;
        when contact and (seqState == 0) then
          eR = r/sqrt(r*r);
          noteR = if abs(eR[1]) > 0.1 then {0,1,0} else (if abs(eR[2])
             > 0.1 then {0,0,1} else {1,0,0});
          eA = cross(eR, noteR)/sqrt(cross(eR, noteR)*cross(eR, noteR));
          eB = cross(eA, eR);
        end when;

       //state situation right before the impulse
        when contact then
          vA = (pre(frame_b.P.v)+cross(transpose(R_b)*pre(frame_b.P.w),-eR*rb_)) -
               (pre(frame_a.P.v)+cross(transpose(R_a)*pre(frame_a.P.w),eR*ra_));
          R_a = frame_a.P.R;
          R_b = frame_b.P.R;

        end when;

        //store the impact impulse in FR
        when contact then
          FR = F*eR;
        end when;

        //impact impulse
        when contact and (seqState == 0) then
          VmR0 = (1-elasticity_)*(vA*eR)/2;
          FA0 = 0;
          FB0 = 0;
        end when;

        //friction impulse
        when contact and (seqState == 1) then
          FR1 = 0;
          FA1 = -muR_*abs(pre(FR))*((vA/sqrt(vA*vA))*eA);
          FB1 = -muR_*abs(pre(FR))*((vA/sqrt(vA*vA))*eB);
          VFricElast[1] = if sign(vA[1])*Vm[1] >= abs(vA[1]/2) then 0 else Vm[1]- (vA[1]/2);
          VFricElast[2] = if sign(vA[2])*Vm[2] >= abs(vA[2]/2) then 0 else Vm[2]- (vA[2]/2);
          VFricElast[3] = if sign(vA[3])*Vm[3] >= abs(vA[3]/2) then 0 else Vm[3]- (vA[3]/2);
        end when;

        //correction impulse
        when contact and (seqState == 2) and (pre(VFricElast)*pre(VFricElast) > 0) then
          eC = if pre(VFricElast)*pre(VFricElast) < s_small^2 then {1,0,0} else
                pre(VFricElast)/sqrt(pre(VFricElast)*pre(VFricElast));
          noteC = if abs(eC[1]) > 0.1 then {0,1,0} else (if abs(eC[2])
             > 0.1 then {0,0,1} else {1,0,0});
          eD = cross(eC, noteC)/sqrt(cross(eC, noteC)*cross(eC, noteC));
          eE = cross(eD, eC);

          VmC2 = sqrt(pre(VFricElast)*pre(VFricElast));
          FD2 = 0;
          FE2 = 0;
        end when;

        //state the impulse dependent equations
        if contact then
          if (seqState == 0) then //further equations for the impact impulse
            Vm*eR = VmR0;
            F*eA = FA0;
            F*eB = FB0;
         else
             if (seqState == 1) then //further equations fot the friction impulse
               F*eR = FR1;
               F*eA = FA1;
               F*eB = FB1;
           else
              //further equations for the correction impulse
              if (seqState == 2) and (pre(VFricElast)*pre(VFricElast) > 0) then
                Vm*eC = VmC2;
                F*eD = FD2;
                F*eE = FE2;
              else
                F = zeros(3);
              end if;
           end if;
         end if;
        else
          F = zeros(3);
        end if;

        //propagate contact signal
        y = contact;

        //state equations for the translational domain
        Vm = (frame_b.Vm+cross(transpose(R_b)*frame_b.Wm,-eR*rb_)) -
             (frame_a.Vm+cross(transpose(R_a)*frame_a.Wm,eR*ra_));
        F = -frame_b.F;
        F = frame_a.F;

        //state equations for the rotational domain
        R_b*cross(-eR*rb_,F) = -frame_b.T;
        R_a*cross(eR*ra_,F) = frame_a.T;

        //define continuous connector variables
        frame_a.f = zeros(3);
        frame_a.t = zeros(3);
        frame_b.f = zeros(3);
        frame_b.t = zeros(3);

      end CollisionSphereSphere;

      model NoCollision "dummy collision element"
        import SI = Modelica.SIunits;
        Interfaces.IFrame_a frame_a annotation (extent=[-120,-20; -100,20]);
        annotation (Diagram, Icon(Line(points=[0,2; 0,60],     style(
                color=0,
                rgbcolor={0,0,0},
                fillColor=51,
                rgbfillColor={255,255,170},
                fillPattern=1)),
            Line(points=[-100,0; -100,0; -70,0],
                                               style(color=0, rgbcolor={0,0,0})),
            Ellipse(extent=[-70,20; -30,-20], style(
                pattern=0,
                fillColor=9,
                rgbfillColor={175,175,175})),
            Line(points=[80,0; 74,0; 100,0],   style(color=0, rgbcolor={0,0,0})),
            Text(
              extent=[-100,-36; 100,-88],
              string="%name",
              style(
                color=3,
                rgbcolor={0,0,255},
                gradient=3,
                fillColor=30,
                rgbfillColor={215,215,215})),
            Text(
              extent=[-64,-34; -96,-4],
              string="a",
              style(
                color=9,
                rgbcolor={175,175,175},
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1)),
            Text(
              extent=[100,-50; 68,-20],
              style(
                color=9,
                rgbcolor={175,175,175},
                pattern=0,
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1),
              string="b"),
            Ellipse(extent=[34,20; 74,-20], style(
                pattern=0,
                fillColor=9,
                rgbfillColor={175,175,175})),
            Ellipse(extent=[-58,8; -42,-8], style(
                pattern=0,
                fillColor=7,
                rgbfillColor={255,255,255})),
            Ellipse(extent=[46,8; 62,-8], style(
                pattern=0,
                fillColor=7,
                rgbfillColor={255,255,255}))),
          Documentation(info="<html>
This is a dummy elements that models no collision at all.
The contact signal is always false. The force and torque impulses ar always zero.
</html>"));

      public
        Modelica.Blocks.Interfaces.BooleanOutput y
          annotation (extent=[10,60; -10,80], rotation=90);
        Interfaces.IFrame_b frame_b annotation (extent=[100,-20; 120,20]);
      equation
        y = false;

        zeros(3) = -frame_b.F;
        zeros(3) = frame_a.F;

        zeros(3) = -frame_b.T;
        zeros(3) = frame_a.T;

        frame_a.f = zeros(3);
        frame_a.t = zeros(3);
        frame_b.f = zeros(3);
        frame_b.t = zeros(3);

      end NoCollision;

      annotation (preferedView="info", Documentation(info="<html>
The models of this package model collisions of spheres and planes.
</html>"));
      model EnergyInjection "dummy collision element"
        import SI = Modelica.SIunits;
        parameter SI.Position n[3] = {1,0,0} "direction of the impulse"  annotation(Evaluate=true);
        final parameter SI.Position eN[3] = n/sqrt(n*n) annotation(Evaluate = true);
        parameter SI.Energy E = 1
          "Energy that should be introduced into the system";
        SI.Impulse Fn;
        SI.Velocity Vm_n;

        Interfaces.IFrame_a frame_a annotation (extent=[-120,-20; -100,20]);
        annotation (Diagram, Icon(
            Ellipse(extent=[-40,10; -20,-10], style(
                color=58,
                rgbcolor={0,127,0},
                gradient=3,
                fillColor=51,
                rgbfillColor={255,255,170})),
            Line(points=[-100,0; -100,0; -70,0],
                                               style(color=0, rgbcolor={0,0,0})),
            Text(
              extent=[-100,-36; 100,-88],
              string="%name",
              style(
                color=3,
                rgbcolor={0,0,255},
                gradient=3,
                fillColor=30,
                rgbfillColor={215,215,215})),
            Line(points=[-20,0; -20,0; 0,0],   style(color=0, rgbcolor={0,0,0})),
            Polygon(points=[-58,24; -86,0; -58,-24; -58,24], style(
                color=42,
                rgbcolor={127,0,0},
                fillColor=1,
                rgbfillColor={255,0,0})),
            Ellipse(extent=[-54,10; -34,-10], style(
                color=58,
                rgbcolor={0,127,0},
                gradient=3,
                fillColor=6,
                rgbfillColor={255,255,0})),
            Ellipse(extent=[-68,10; -48,-10], style(
                color=58,
                rgbcolor={0,127,0},
                gradient=3,
                fillColor=45,
                rgbfillColor={255,128,0}))),
          Documentation(info="<html>
This elements causes a force impulse in the given direction n, that leads to a certain
injection of energy. <br> The amount of energy is specified by the parameter E.
<p>
Please note that this element introduces a quadratic equation into the system. <br>
This might result in a larger system of non-linear equations that has to be solved
at corresponding discrete event.
</html>"));

        Modelica.Blocks.Interfaces.BooleanInput u
          annotation (extent=[0,-10; 20,10],  rotation=180);

      protected
        Real[3,3] R_a "orientation of frame a at the impulse time";

      equation
        when u then
          R_a = frame_a.P.R;
        end when;

        zeros(3) = frame_a.T;
        Fn * (eN * R_a) = frame_a.F;
        Vm_n = frame_a.Vm * (eN*R_a);

        frame_a.f = zeros(3);
        frame_a.t = zeros(3);

        if u then
          -Fn*abs(Vm_n) = E;
        else
          Fn = 0;
        end if;

      end EnergyInjection;

    end Contacts;

  annotation (Icon(
        Text(
          extent=[-120,122; 120,73],
          style(color=1),
        string="%name"),
        Polygon(points=[-100,50; -80,70; 100,70; 80,50; -100,50],      style(
            color=42,
            fillColor=30,
            fillPattern=1)),
        Polygon(points=[100,70; 100,-80; 80,-100; 80,50; 100,70],      style(
            color=42,
            fillColor=30,
            fillPattern=1)),
        Rectangle(extent=[-100,-100; 80,50],   style(
            color=42,
            fillColor=30,
            fillPattern=1)),
        Text(
          extent=[-85,35; 65,-85],
          string="Library",
          style(color=42))), preferedView="info", Documentation(info="<html>
  This is an extension of the package Mechanics3D.
  The continuous models are extended to hybrid models, that describe the behaviour of in situaions of continuous changement and in situations of sudden (impulse) changement.
The extension of the underlying continuous models is done by equations.
<p>
<img src=\"../Images/NewtonsCradle.png\">
<img src=\"../Images/Cue.png\">
</p>
<p>
The library is used to create models of mechanical systems that underly hard collisions and impacts.
Again, mechanical systems can be composed out of single ideal elements. They are seperated as in Mechanics3D into packages for:
<ul>
<li> basic parts like bodies or fixations
<li> joint elements
<li> force elements
<li> contact models
</ul>
<p>
<h3>Tutorial</h3>
The modeling of the actual mechanical systems doesn't differ from the Mechanics3D library.
<p>
A contact model needs to be applied to model an hard impact between two mechanical systems.
The contact model generates additionally a contact signal that needs to be manually connected to both colliding systmes. This is done via the \"InsertImpulse\" element of the subpackage \"interfaces\".
<p>
If a system underlies several possible impacts, the corresponding contact signals have to be merged
by a boolean \"or\" function.
<p>
Please, don't forget to take a look at the examples.
<h3>Extension of the continuous models</h3>
The existing continuous models of the Mechanics3D library are extended by their corresponding impulse equations. The necessary equations are added in textual form. The continuous models remain unchanged.
<p>
To afford such an extension of the continuous models, it is necessary to redeclare the existing connectors. The new connectors are an extended variant of the old ones.
The new connector contains also boolean variable that is the contact signals. This signal is set to true at the time of a force impulse and is transmitted between all rigid connections.
<h3>Kinematic Loops</h3>
Impacts on kinematic loops cause no severe problems. Only the loop needs to be closed manually
by a special CloseLoop elements of the package ?Joints?. The CloseLoop element is an
extension of the manual loop closer of the Mechanics3D library. It is needed, because
a further loop needs to be cut: the one of the boolean contact signal.
<h3>Efficency</h3>
The efficiency of the continuous models is not impaired in any way.
<p>
The efficiency of the computation at an discrete event is sufficient but could be better.
However, the resulting systems of linear equations are solved accurately and robustly.
<h3>Examples</h3>
A small set of examples demonstrate the usage of the Mechanics3DwithImpulses library.
They offer a good starting point to make yourself familiar with this library.
</html>"));

    package Forces "force elements"
      extends Modelica.Icons.Library;
      model Damping "model of a linear damper"
        annotation (Icon(
            Rectangle(extent=[-40,40; 20,-40], style(
                pattern=0,
                fillColor=30,
                rgbfillColor={215,215,215})),
            Line(points=[-100,0; -40,0; -40,40; 40,40], style(color=0, rgbcolor={0,0,
                    0})),
            Line(points=[-40,0; -40,-40; 42,-40], style(color=0, rgbcolor={0,0,0})),
            Line(points=[100,0; 0,0; 0,32; 0,-32], style(color=0, rgbcolor={0,0,0})),
            Text(
              extent=[-68,-50; -100,-20],
              string="a",
              style(
                color=9,
                rgbcolor={175,175,175},
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1)),
            Text(
              extent=[100,-50; 68,-20],
              style(
                color=9,
                rgbcolor={175,175,175},
                pattern=0,
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1),
              string="b"),
            Text(
              extent=[-100,112; 100,60],
              string="%name",
              style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1)),
            Text(
              extent=[-100,-60; 100,-106],
              style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1),
              string="d=%d")), Diagram,
          Documentation(info="<html>
This is the model of a linear damper element.
<p>
The damper generates a counteracting force that is proportional to the
relative velocity.
<p>
The damping coefficient can be set by the parameter d.
</html>"));
        parameter Real d(
          final unit="N.s/m",
          final min=0) = 0 "Damping constant";

        Interfaces.IFrame_a frame_a annotation (extent=[-120,-20; -100,20]);
        Interfaces.IFrame_b frame_b annotation (extent=[100,-20; 120,20]);

      protected
        Interfaces.ConnectContinousFrame ConnectContinousFrame1
          annotation (extent=[40,-20; 80,20]);
        Interfaces.ConnectContinousFrame ConnectContinousFrame2
          annotation (extent=[-40,-20; -80,20]);
        Mechanics3D.Forces.Damping Damping1(d=d)
          annotation (extent=[-20,-20; 20,20]);
      equation
        connect(ConnectContinousFrame2.frame_b, frame_a) annotation (points=[
              -74,0; -110,0], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(ConnectContinousFrame1.frame_b, frame_b) annotation (points=[74,
              0; 110,0], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Damping1.frame_a, ConnectContinousFrame2.frame_a) annotation (
            points=[-22,0; -46,0], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Damping1.frame_b, ConnectContinousFrame1.frame_a) annotation (
            points=[22,0; 46,0], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
      end Damping;

      model Spring "model of a linear spring"
        annotation (Icon(
            Text(
              extent=[-100,100; 100,48],
              string="%name",
              style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1)),
            Line(points=[-100,0; -80,0; -40,40; 40,-40], style(color=0, rgbcolor={0,0,
                    0})),
            Ellipse(extent=[-10,10; 10,-10], style(
                pattern=0,
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1)),
            Line(points=[40,-40; 80,0; 100,0], style(color=0, rgbcolor={0,0,0})),
            Text(
              extent=[100,-50; 68,-20],
              style(
                color=9,
                rgbcolor={175,175,175},
                pattern=0,
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1),
              string="b"),
            Text(
              extent=[-100,-46; 100,-92],
              style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1),
              string="c=%c"),
            Text(
              extent=[-68,-50; -100,-20],
              string="a",
              style(
                color=9,
                rgbcolor={175,175,175},
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1))), Diagram,
          Documentation(info="<html>
This is the model of a linear spring.
<p>
<img src=\"../Images/Spring.png\">
</p>
<p>
The spring generates a counteracting force that is linear dependent on the positional shift.
<p>
The spring coefficient can be set by the parameter c. The rest lenght can be specified by the parameter s0.
<p>
A spring with a rest length s0 unequal to zero, has a stiff behavior if its length is approaching zero.
The parameter s_small in the advanced menu reduces this stiffness for spring lengths ranging from zero up to s_small.
<h3>Visualization</h3>
This element is visualized by a coil. Further specifications can be made by the parameters in the animation group.
</html>"));

        import SI = Modelica.SIunits;
        import MB = Modelica.Mechanics.MultiBody;

        parameter Boolean animation = true "animate spring";

        parameter Real c(
          final unit="N/m",
          final min=0) = 0 "Spring constant";

        parameter SI.Position s0 = 0 "rest length of spring";
        parameter SI.Position s_small = 1e-4
          "|Advanced||critical Spring length";

        parameter SI.Distance width= world3D.defaultForceWidth
          "|Animation|if animation = true| Width of spring";
        parameter SI.Distance coilWidth=width/5
          "|Animation|if animation = true| Width of spring coil";
        parameter Integer numberOfWindings=5
          "|Animation|if animation = true| Number of spring windings";
        parameter MB.Types.Color color= world3D.defaultForceElementColor
          "|Animation|if animation = true| Color of spring";

        Interfaces.IFrame_a frame_a annotation (extent=[-120,-20; -100,20]);
        Interfaces.IFrame_b frame_b annotation (extent=[100,-20; 120,20]);

      protected
        outer World3D world3D;

        Interfaces.ConnectContinousFrame ConnectContinousFrame1
          annotation (extent=[40,-20; 80,20]);
        Interfaces.ConnectContinousFrame ConnectContinousFrame2
          annotation (extent=[-40,-20; -80,20]);
        Mechanics3D.Forces.Spring Spring1(
          animation=animation,
          c=c,
          s0=s0,
          s_small=s_small,
          width=width,
          coilWidth=coilWidth,
          numberOfWindings=numberOfWindings,
          color=color) annotation (extent=[-20,-20; 20,20]);
      equation
        connect(ConnectContinousFrame2.frame_b, frame_a) annotation (points=[
              -74,0; -110,0], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(ConnectContinousFrame1.frame_b, frame_b) annotation (points=[74,
              0; 110,0], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Spring1.frame_b, ConnectContinousFrame1.frame_a) annotation (
            points=[22,0; 46,0], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Spring1.frame_a, ConnectContinousFrame2.frame_a) annotation (
            points=[-22,0; -46,0], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
      end Spring;
    end Forces;

    package Joints "joint elements"
      extends Modelica.Icons.Library;
      model Revolute "revolute joint with 1 degree of freedom"
      extends Mechanics3D.Joints.Revolute(
              redeclare Interfaces.IFrame_a frame_a,
              redeclare Interfaces.IFrame_b frame_b,
              redeclare Interfaces.IMech2MBG Mech2MBG1,
              redeclare Interfaces.MBG2IMech MBG2Mech1);

         parameter Boolean reinitByImpulse =  enforceStates
          "|Advanced||reinit velocities by an impulse";

      protected
        Real Rrel[3,3];
        Real Wm;
        Real Wa;

      equation
        when frame_a.contact then
          Wa = w;
          Rrel = planarRotation1.Rrel;
        end when;

        if reinitByImpulse then
          when frame_b.contact then
            reinit(w,Wa+2*(Wm-Wa));
          end when;
        end if;

        frame_a.contact = frame_b.contact;
        frame_a.F + frame_b.F  = zeros(3);
        frame_a.Vm = frame_b.Vm;
        Rrel*frame_a.T + frame_b.T  = zeros(3);
        frame_b.T*eN = 0;
        Rrel*frame_a.Wm = -Wm*eN+frame_b.Wm;

        annotation (Diagram(                  Rectangle(extent=[-110,20; -100,
                  -20], style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=47,
                rgbfillColor={255,170,85})),  Rectangle(extent=[100,20; 110,-20],
                style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=51,
                rgbfillColor={255,255,170}))), Icon(
                                              Rectangle(extent=[100,20; 110,-20],
                style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=51,
                rgbfillColor={255,255,170})), Rectangle(extent=[-110,20; -100,
                  -20], style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=47,
                rgbfillColor={255,170,85}))),
          Documentation(info="<html>
This is a revolute joint. The two connected frames are allowed to rotate around the joint axis.
This joint defines one degree of freedom.
<p>
<img src=\"../Images/Revolute.png\">
</p>
<h3>General parameter</h3>
The rotation axis of the revolute joint can be defined by the parameter n. n can be of arbitrary length, but it must not be zero.
<p>
The parameter phi_offset defines an offset value for the revolute angle phi.
<p>
The parameter animation toggles the visualization of the element.
<h3>Initialization</h3>
In general, you can specify...
<ul>
<li>...the initial revolute angle.
<li>...the initial angular velocity.
<li>...the initial angular acceleration.
</ul>
Which of these variables do effectively appear in the inital equations can be defined by the parameter initType.
<h3>Visualization</h3>
This element is visualized by cylinder along the rotation axis. The settings for length, diameter and color can be specified by the animation parameters.
<h3>Advanced settings</h3>
The activation of enforceStates enforces the joint to explicitely define integrators.
This parameter is useful to choose the state variables manually.
<p>
The activation of reinitByImpulse determines the state variables to be reinitialized in case of a force impulse. It is coupled by default with the parameter enforceStates.
The selection of the reinitialization points must be done manually.
</html>"));
      end Revolute;

      model Prismatic "prismatic joint with 1 degree of freedom"
      extends Mechanics3D.Joints.Prismatic(
              redeclare Interfaces.IFrame_a frame_a,
              redeclare Interfaces.IFrame_b frame_b,
              redeclare Interfaces.IMech2MBG Mech2MBG1,
              redeclare Interfaces.MBG2IMech MBG2Mech1);

         parameter Boolean reinitByImpulse =  enforceStates
          "|Advanced||reinit velocities by an impulse";

      protected
        Real R[3,3];
        Real rs;
        Real Vm;
        Real Va;

      equation
        when frame_a.contact then
          R = frame_a.P.R;
          rs = s;
          Va = v;
        end when;

        if reinitByImpulse then
          when frame_b.contact then
            reinit(v,Va+2*(Vm-Va));
          end when;
        end if;

        frame_a.contact = frame_b.contact;
        frame_a.F + frame_b.F = zeros(3);
        (R*frame_b.F)*eN = 0;
        frame_a.T + frame_b.T + cross(rs*eN,R*frame_b.F) = zeros(3);
        frame_a.Vm + transpose(R)*cross(frame_a.Wm,rs*eN) + transpose(R)*(Vm*eN) = frame_b.Vm;
        frame_a.Wm = frame_b.Wm;

        annotation (Diagram(                  Rectangle(extent=[-110,20; -100,
                  -20], style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=47,
                rgbfillColor={255,170,85})),  Rectangle(extent=[100,20; 110,-20],
                style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=51,
                rgbfillColor={255,255,170}))), Icon(
                                              Rectangle(extent=[100,20; 110,-20],
                style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=51,
                rgbfillColor={255,255,170})), Rectangle(extent=[-110,20; -100,
                  -20], style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=47,
                rgbfillColor={255,170,85}))),
          Documentation(info="<html>
This is a prismatic joint. The two connected frames are allowed to shift in direction of the joint axis.
This joint defines one degree of freedom.
<p>
<img src=\"../Images/Prismatic3D.png\">
</p>
<h3>General parameter</h3>
The joint axis can be defined by the parameter n. n can be of arbitrary length, but it must not be zero.
<p>
The parameter s_offset defines an offset value for the joint length s.
<p>
The parameter animation toggles the visualization of the element.
<h3>Initialization</h3>
In general, you can specify...
<ul>
<li>...the initial joint length.
<li>...the initial joint velocity.
<li>...the initial joint acceleration.
</ul>
Which of these variables do effectively appear in the inital equations can be defined by the parameter initType.
<h3>Visualization</h3>
This element is visualized by box. The settings for width, height and color can be specified by the animation parameters.
<h3>Advanced settings</h3>
The activation of enforceStates enforces the joint to explicitely define integrators.
This parameter is useful to choose the state variables manually.
<p>
The activation of reinitByImpulse determines the state variables to be reinitialized in case of a force impulse. It is coupled by default with the parameter enforceStates.
The selection of the reinitialization points must be done manually.
</html>"));
      end Prismatic;

      model Spherical
        "spherical joint with all 3 rotational degrees of freedom"
      extends Mechanics3D.Joints.Spherical(
              redeclare Interfaces.IFrame_a frame_a,
              redeclare Interfaces.IFrame_b frame_b,
              redeclare Interfaces.IMech2MBG Mech2MBG1,
              redeclare Interfaces.MBG2IMech MBG2Mech1);

         parameter Boolean reinitByImpulse =  enforceStates
          "|Advanced||reinit velocities by an impulse";

      protected
        Real Rrel[3,3];
        Real Wm[3];
        Real Wa[3];

      equation
        when frame_a.contact then
          Wa = w;
          Rrel = Rotation1.Rrel;
        end when;

        if reinitByImpulse then
          when frame_b.contact then
            reinit(w,Wa+2*(Wm-Wa));
          end when;
        end if;

        frame_a.contact = frame_b.contact;
        frame_a.F + frame_b.F  = zeros(3);
        frame_a.Vm = frame_b.Vm;
        Rrel*frame_a.T + frame_b.T  = zeros(3);
        frame_b.T = zeros(3);
        Rrel*frame_a.Wm = -Wm + frame_b.Wm;

        annotation (Diagram(                  Rectangle(extent=[-110,20; -100,
                  -20], style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=47,
                rgbfillColor={255,170,85})),  Rectangle(extent=[100,20; 110,-20],
                style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=51,
                rgbfillColor={255,255,170}))), Icon(
                                              Rectangle(extent=[100,20; 110,-20],
                style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=51,
                rgbfillColor={255,255,170})), Rectangle(extent=[-110,20; -100,
                  -20], style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=47,
                rgbfillColor={255,170,85}))),
          Documentation(info="<html>
This is an spherical joint. The two connected frames are allowed to rotate freely.
This joint defines three degrees of freedom.
<p>
<img src=\"../Images/Spherical.png\">
</p>
<h3>General parameter</h3>
The parameter animation toggles the visualization of the element
<h3>Initialization</h3>
In general, you can specify...
<ul>
<li>...the initial orientation.
<li>...the initial angular velocity.
<li>...the initial angular acceleration.
</ul>
Which of these variables do effectively appear in the inital equations can be defined by the parameter initType.
<h3>Visualization</h3>
This element is visualized by a sphere.
<h3>Advanced settings</h3>
The activation of enforceStates enforces the joint to explicitely define integrators.
This parameter is useful to choose the state variables manually.
<p>
The activation of reinitByImpulse determines the state variables to be reinitialized in case of a force impulse. It is coupled by default with the parameter enforceStates.
The selection of the reinitialization points must be done manually.
<p>
The orientation can either be expressed by the three cardan angles or by quaternions.
<ul>
<li>The usage of cardan angles leads to a faster computation but contains a singular point. It is therefore of limited applicability.
<li> The usage of quaternions lead to a robust solution, but it generates the need for dynamic state selection and leads to non-linear equations.
</ul>
<p>
Which of these two variants is used, can be specified by the parameter useQuaternions.
If cardan angles are chosen to be used, you can specify the sequence of rotation axis by the parameter sequence_angles.
</html>"));
      end Spherical;

      model FreeTranslationalMovement
        "joint with all 3 translational degrees of freedom"
         extends Mechanics3D.Joints.FreeTranslationalMovement(redeclare
            Interfaces.IFrame_b frame_b,                      redeclare
            Interfaces.MBG2IMech MBG2Mech1);
         parameter Boolean reinitByImpulse =  enforceStates
          "|Advanced||reinit velocities by an impulse";

        annotation (Diagram(                  Rectangle(extent=[100,20; 110,-20],
                style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=51,
                rgbfillColor={255,255,170}))), Icon(Rectangle(extent=[100,20;
                  110,-20], style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=51,
                rgbfillColor={255,255,170}))),
          Documentation(info="<html>
This is an untypical joint. The translational movement of its connected element is not restricted
and all 3 translational degrees of freedom are defined. The orientation is fixated.
<h3>General parameter</h3>
The parameter r defines a positional offset.
<h3>Initialization</h3>
In general, you can specify...
<ul>
<li>...the initial position.
<li>...the initial velocity.
<li>...the initial acceleration.
</ul>
Which of these variables do effectively appear in the inital equations can be defined by the parameter initType.
<h3>Visualization</h3>
This element isn't visualized.
<h3>Advanced settings</h3>
The activation of enforceStates enforces the joint to explicitely define integrators.
This parameter is useful to choose the state variables manually.
<p>
The activation of reinitByImpulse determines the state variables to be reinitialized in case of a force impulse. It is coupled by default with the parameter enforceStates.
The selection of the reinitialization points must be done manually.
</html>"));

      protected
        Real Va[3];
        Real Wa[3];

      equation
          when frame_b.contact then
            Va = frame_b.P.v;
            Wa = frame_b.P.w;
          end when;

          if reinitByImpulse then
            when frame_b.contact then
              reinit(v,Va+2*(frame_b.Vm-Va));
            end when;
          end if;

          frame_b.F = zeros(3);
          frame_b.Wm = zeros(3);

      end FreeTranslationalMovement;

      model FreeBodyMovement "joint with all 6 degrees of freedom"
           extends Mechanics3D.Joints.FreeBodyMovement(redeclare
            Interfaces.IFrame_b frame_b,                      redeclare
            Interfaces.MBG2IMech MBG2Mech1);

         parameter Boolean reinitByImpulse =  enforceStates
          "|Advanced||reinit velocities by an impulse";

      protected
        Real Va[3];
        Real Wa[3];

      equation
          when frame_b.contact then
            Va = frame_b.P.v;
            Wa = frame_b.P.w;
         end when;

          if reinitByImpulse then
            when frame_b.contact then
              reinit(v,Va+2*(frame_b.Vm-Va));
              reinit(w,Wa+2*(frame_b.Wm-Wa));
            end when;
          end if;

          frame_b.F = zeros(3);
          frame_b.T = zeros(3);

        annotation (Diagram(                  Rectangle(extent=[100,20; 110,-20],
                style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=51,
                rgbfillColor={255,255,170}))), Icon(
                                              Rectangle(extent=[100,20; 110,-20],
                style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=51,
                rgbfillColor={255,255,170}))),
          Documentation(info="<html>
This is an untypical joint, that does not restrict the movement of its connected element
and defines all 6 degrees of freedom. The usage of this joint is hardly necessary, because it is potentially avaiable in each body element.
<h3>General parameter</h3>
There are no general parameters
<h3>Initialization</h3>
In general, you can specify...
<ul>
<li>...the initial position and orientation.
<li>...the initial velocity and angular velocity.
<li>...the initial acceleration and angular acceleration.
</ul>
Which of these variables do effectively appear in the inital equations can be defined by the parameter initType.
<h3>Visualization</h3>
This element isn't visualized.
<h3>Advanced settings</h3>
The activation of enforceStates enforces the joint to explicitely define integrators.
This parameter is useful to choose the state variables in a kinematic manually.
<p>
The activation of reinitByImpulse determines the state variables to be reinitialized in case of a force impulse. It is coupled by default with the parameter enforceStates.
The selection of the reinitialization points must be done manually.
<p>
The orientation can either be expressed by the three cardan angles or by quaternions.
<ul>
<li>The usage of cardan angles leads to a faster computation but contains a singular point. It is therefore of limited applicability.
<li> The usage of quaternions lead to a robust solution, but it generates the need for dynamic state selection and leads to non-linear equations.
</ul>
<p>
Which of these two variants is used, can be specified by the parameter useQuaternions.
If cardan angles are chosen to be used, you can specify the sequence of rotation axis by the parameter sequence_angles.
</html>"));
      end FreeBodyMovement;

      model PotentialFBM "potential joint with all 6 degrees of freedom"
           extends Mechanics3D.Joints.PotentialFBM(
              redeclare Interfaces.IFrame_b frame_b,
              redeclare Interfaces.MBG2IMech MBG2Mech1);

         parameter Boolean reinitByImpulse =  enforceStates
          "|Advanced||reinit velocities by an impulse";

      protected
        Real Va[3];
        Real Wa[3];

      equation
          when frame_b.contact then
            Va = frame_b.P.v;
            Wa = frame_b.P.w;
         end when;

          if reinitByImpulse then
            when frame_b.contact then
              reinit(v,Va+2*(frame_b.Vm-Va));
              reinit(w,Wa+2*(frame_b.Wm-Wa));
            end when;
          end if;

          frame_b.F = zeros(3);
          frame_b.T = zeros(3);

        annotation (Diagram(                  Rectangle(extent=[100,20; 110,-20],
                style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=51,
                rgbfillColor={255,255,170}))), Icon(
                                              Rectangle(extent=[100,20; 110,-20],
                style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=51,
                rgbfillColor={255,255,170}))),
          Documentation(info="<html>
This is a potential joint. It is in principle equal to the free body movement joint, but the differential
equations are only stated if necessary (i. e.: if the body movement can't be derived out of other joints).
This joint is part of every body element. There is actually no further usage of this element.
<h3>General parameter</h3>
There are no general parameters
<h3>Initialization</h3>
In general, you can specify...
<ul>
<li>...the initial position and orientation.
<li>...the initial velocity and angular velocity.
<li>...the initial acceleration and angular acceleration.
</ul>
Which of these variables do effectively appear in the inital equations can be defined by the parameter initType.
<h3>Visualization</h3>
This element isn't visualized.
<h3>Advanced settings</h3>
The activation of enforceStates enforces the joint to explicitely define integrators.
This parameter is useful to choose the state variables manually.
<p>
The activation of reinitByImpulse determines the state variables to be reinitialized in case of a force impulse. It is coupled by default with the parameter enforceStates.
The selection of the reinitialization points must be done manually.
<p>
The orientation can either be expressed by the three cardan angles or by quaternions.
<ul>
<li>The usage of cardan angles leads to a faster computation but contains a singular point. It is therefore of limited applicability.
<li> The usage of quaternions lead to a robust solution, but it generates the need for dynamic state selection and leads to non-linear equations.
</ul>
<p>
Which of these two variants is used, can be specified by the parameter useQuaternions.
If cardan angles are chosen to be used, you can specify the sequence of rotation axis by the parameter sequence_angles.
</html>"));
      end PotentialFBM;

      model CloseLoop "element to close kinematik loops manualy"
      extends Mechanics3D.Joints.CloseLoop(
              redeclare Interfaces.IFrame_a frame_a,
              redeclare Interfaces.IFrame_b frame_b);

      equation
      frame_a.F = frame_b.F;
      frame_a.T = frame_b.T;
      frame_a.Vm = frame_b.Vm;
      frame_a.Wm = frame_b.Wm;

        annotation (Diagram(                  Rectangle(extent=[-110,20; -100,
                  -20], style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=47,
                rgbfillColor={255,170,85})),  Rectangle(extent=[100,22; 110,-18],
                style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=51,
                rgbfillColor={255,255,170}))), Icon(
                                              Rectangle(extent=[100,20; 110,-20],
                style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=51,
                rgbfillColor={255,255,170})), Rectangle(extent=[-110,20; -100,
                  -20], style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=47,
                rgbfillColor={255,170,85}))),
          Documentation(info="<html>
This is the CloseLoop element.
<p>
With this element you can cut a kinematic loop. Just insert the element into the loop
at the point where you'd like to cut it. Kinematic loops have to be cut manually in impulse mechanical systems.
<p>
This element connects its two connectors in a non-redundant way. It must not be used outside a kinematik loop.
</html>"));
      end CloseLoop;

      annotation (preferedView="info", Documentation(info="<html>
This package contains models of joints.
<p>
Joints are massles objects, that define the relative movement between two rigid elements.
The number of degrees of freedom specifies how many variables are minimally needed to describe the relative
position. An object in 3D-space can have up to 6 degrees of freedom.
<p>
Joints usually define integrators and the joint variables on positional and velocity level
become state variables of the system. Anyhow the integrators might be removed by the Pantelides algorithm, if the joint is placed in a kinematic loop.<br>
The number of degrees of freedom equals the number of potential state variables.
<p>
The state variables have to be reinitialized at a force impulse. Hence, the selection of the reinitialization points must be done manually and is equal to the selection of the state variables that also should be done manually.
<p>
It is possible and common to create complex joints out of simple joints.
However, one has to pay attention that no singularities occur if two or more joints are connected (directly or through massless elements).
</html>"));
      package CutJoints
        model PlanarRevolute
        extends Mechanics3D.Joints.CutJoints.PlanarRevolute(
                redeclare Interfaces.IFrame_a frame_a,
                redeclare Interfaces.IFrame_b frame_b);

        protected
          Real weakener;
          Real RT[3,3];

        equation
          when frame_a.contact then
            RT = transpose(frame_a.P.R);
          end when;

          frame_a.Vm = frame_b.Vm + weakener*RT*eN;
          frame_a.F*RT*eN = 0;
          frame_a.T = eN*0;
          frame_a.F + frame_b.F = zeros(3);
          frame_a.T + frame_b.T = zeros(3);

          annotation (Documentation(info="<html>
This special model of a revolute joint is designed to cut planar loops.
<p>
If a planar loop is cut by a standard revolute joint a singular system of equations results.
<p>
<p>
<img src=\"../Images/Revolute.png\">
</p>
<h3>General parameter</h3>
The rotation axis of the revolute joint can be defined by the parameter n. n can be of arbitrary length, but it must not be zero.
<p>
The parameter phi_offset defines an offset value for the revolute angle phi.
<p>
The parameter animation toggles the visualization of the element.
<h3>Visualization</h3>
This element is visualized by cylinder along the rotation axis. The settings for length, diameter and color can be specified by the animation parameters.
</html>"));
        end PlanarRevolute;
        annotation (Documentation(info="<html>
This subpackage contains so called cut joints. These are elements, that close kinematic loops.
</html>
"));
      end CutJoints;
    end Joints;

    package Parts "Parts"
      extends Modelica.Icons.Library;

      model Body "complete model of a body"
        extends Mechanics3D.Parts.Body(redeclare Interfaces.IFrame_a frame_a,
                                       redeclare Interfaces.IMech2MBG Mech2MBG1,
                                       redeclare Joints.PotentialFBM
            PotentialFBM1(
          initType=initType,
          x_start=x_start,
          v_start=v_start,
          a_start=a_start,
          phi_start=phi_start,
          w_start=w_start,
          z_start=z_start,
          enforceStates=enforceStates,
          useQuaternions=useQuaternions,
          sequence_angles=sequence_angles,
          reinitByImpulse = reinitByImpulse));

        annotation (Icon(                     Rectangle(extent=[-110,20; -100,
                  -20], style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=47,
                rgbfillColor={255,170,85}))),
                          Diagram(            Rectangle(extent=[-110,20; -100,
                  -20], style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=47,
                rgbfillColor={255,170,85}))),
          Documentation(info="<html>
This is the model of a body representing a point with given mass and inertia tensor.
<p>
If the body model is not connected to any joint, its movement is defined to be free.
Therefore this model includes a potential free-body movement joint and in consequences shares certain joint characterisitcs.
<p>
<img src=\"../Images/Body.png\">
</p>
<h3>General parameter</h3>
The mass can be specified by the parameter m.
<p>
The inertia tensor is a symmetric 3x3 matrix and can be specified by the parameters I11, I12, ...
<p>
A non-zero value for the parameter GPIndex inserts the body into the gravity pool.<br>
Make sure the integer value is unique and does not exceed the size of the gravity pool.
<p>
The parameter animation toggles the visualization
<h3>Initialization</h3>
In general, you can specify...
<ul>
<li>...the initial position and orientation.
<li>...the initial velocity and angular velocity.
<li>...the initial acceleration and angular acceleration.
</ul>
Which of these variables do effectively appear in the inital equations can be defined by the parameter initType.
<h3>Visualization</h3>
The element is visualized by a sphere. Diameter and color of the sphere can be specified by the animation parameters.
<h3>Advanced settings</h3>
The activation of enforceStates enforces the joint to explicitely define integrators.
This parameter is useful to choose the state variables manually.
<p>
The activation of reinitByImpulse determines the state variables to be reinitialized in case of a force impulse. It is coupled by default with the parameter enforceStates.
The selection of the reinitialization points must be done manually.
<p>
The orientation can either be expressed by the three cardan angles or by quaternions.
<ul>
<li>The usage of cardan angles leads to a faster computation but contains a singular point. It is therefore of limited applicability.
<li> The usage of quaternions lead to a robust solution, but it generates the need for dynamic state selection and leads to non-linear equations.
</ul>
<p>
Which of these two variants is used, can be specified by the parameter useQuaternions.
If cardan angles are chosen to be used, you can specify the sequence of rotation axis by the parameter sequence_angles.
</html>"));

         parameter Boolean reinitByImpulse =  enforceStates
          "|Advanced||reinit velocities by an impulse";
         parameter Integer CPIndex = 0;

      protected
        outer CollisionPool collisionPool;
        Real Va[3];
        Real Wa[3];
      equation
        if CPIndex > 0 then
          connect(frame_a, collisionPool.frames[CPIndex]);
        end if;
        when frame_a.contact then
          Va = frame_a.P.v;
          Wa = frame_a.P.w;
        end when;

        frame_a.F = m*2*(frame_a.Vm-Va);
        frame_a.T = Inert*2*(frame_a.Wm-Wa);

      end Body;

      model SimpleBody "simple model of a body"
         extends Mechanics3D.Parts.SimpleBody(redeclare Interfaces.IFrame_a
            frame_a,                          redeclare Interfaces.IMech2MBG
            Mech2MBG1);

        annotation (Diagram(                  Rectangle(extent=[-110,20; -100,
                  -20], style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=47,
                rgbfillColor={255,170,85}))), Icon(Rectangle(extent=[-110,20;
                  -100,-20], style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=47,
                rgbfillColor={255,170,85}))),
          Documentation(info="<html>
This is the model of a body representing a point with given mass and inertia tensor.
<p>
Different from the standard body model, this model does not contain a potential joint and therefore
needs to be connected to a joint or fixation element.
<p>
<img src=\"../Images/Body.png\">
</p>
<h3>General parameter</h3>
The mass can be specified by the parameter m.
<p>
The inertia tensor is a symmetric 3x3 matrix and can be specified by the parameters I11, I12, ...
<p>
A non-zero value for the parameter GPIndex inserts the body into the gravity pool.<br>
Make sure the integer value is unique and does not exceed the size of the gravity pool.
<p>
The parameter animation toggles the visualization
<h3>Visualization</h3>
The element is visualized by a sphere. Diameter and color of the sphere can be specified by the animation parameters.
</html>"));

      protected
        Real Va[3];
        Real Wa[3];
      equation
        when frame_a.contact then
          Va = frame_a.P.v;
          Wa = frame_a.P.w;
        end when;

        frame_a.F = m*2*(frame_a.Vm-Va);
        frame_a.T = Inert*2*(frame_a.Wm-Wa);

      end SimpleBody;

      model Fixed "wall"
                  extends Mechanics3D.Parts.Fixed(redeclare Interfaces.IFrame_b
            frame_b,                              redeclare
            Interfaces.MBG2IMech MBG2Mech1);
      equation
         frame_b.Vm = zeros(3);
         frame_b.Wm = zeros(3);
        annotation (Diagram(                  Rectangle(extent=[100,20; 110,-20],
                style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=51,
                rgbfillColor={255,255,170}))), Icon(
                                              Rectangle(extent=[100,20; 110,-20],
                style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=51,
                rgbfillColor={255,255,170}))),
          Documentation(info="<html>
This is the model of a body representing a point with given mass and inertia tensor.
<p>
Different from the standard body model, this model does not contain a potential joint and therefore
needs to be connected to a joint or fixation element.
<h3>General parameter</h3>
The mass can be specified by the parameter m.
<p>
The inertia tensor is a symmetric 3x3 matrix and can be specified by the parameters I11, I12, ...
<p>
A non-zero value for the parameter GPIndex inserts the body into the gravity pool.<br>
Make sure the integer value is unique and does not exceed the size of the gravity pool.
<p>
The parameter animation toggles the visualization
<h3>Visualization</h3>
The element is visualized by a sphere. Diameter and color of the sphere can be specified by the animation parameters.
</html>"));
      end Fixed;

      model FixedRotation "fixed rotation"
        extends Mechanics3D.Parts.FixedRotation(redeclare Interfaces.IFrame_a
            frame_a,                   redeclare Interfaces.IFrame_b frame_b,
                                       redeclare Interfaces.IMech2MBG Mech2MBG1,
                                       redeclare Interfaces.MBG2IMech MBG2Mech1);

      equation
        frame_a.contact = frame_b.contact;
        frame_a.F + frame_b.F = zeros(3);
        frame_a.Vm =  frame_b.Vm;

        Rotation1.Rrel*frame_a.T + frame_b.T  = zeros(3);
        Rotation1.Rrel*frame_a.Wm = frame_b.Wm;

        annotation (Documentation(info="<html>
This component defines a fixed rotation between the two connected frames.
<h3>General parameter</h3>
The rotation can be specified by the rotation axis n and the rotation anlge phi.
The rotation axis is resolved in the body system.
<h3>Visualization</h3>
The element isn't visualized.
</html>"));
      end FixedRotation;

      model FixedTranslation "fixed translation"
        extends Mechanics3D.Parts.FixedTranslation(redeclare
            Interfaces.IFrame_a frame_a,
                                       redeclare Interfaces.IFrame_b frame_b,
                                       redeclare Interfaces.IMech2MBG Mech2MBG1,
                                       redeclare Interfaces.MBG2IMech MBG2Mech1);

      protected
        Real R[3,3];

      equation
      when frame_a.contact then
        R = frame_a.P.R;
      end when;

      frame_a.contact = frame_b.contact;
      frame_a.F + frame_b.F = zeros(3);
      frame_a.T + frame_b.T + cross(r,R*frame_b.F) = zeros(3);
      frame_a.Vm + transpose(R)*cross(frame_a.Wm,r) = frame_b.Vm;
      frame_a.Wm = frame_b.Wm;

        annotation (Diagram(                  Rectangle(extent=[-110,20; -100,
                  -20], style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=47,
                rgbfillColor={255,170,85})),  Rectangle(extent=[100,20; 110,-20],
                style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=51,
                rgbfillColor={255,255,170}))), Icon(
                                              Rectangle(extent=[100,20; 110,-20],
                style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=51,
                rgbfillColor={255,255,170})), Rectangle(extent=[-110,20; -100,
                  -20], style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=47,
                rgbfillColor={255,170,85}))),
          Documentation(info="<html>
This is the model of a massless rod. It defines a fixed translation between the two connected frames.
<p>
<img src=\"../Images/Transl.png\">
</p>
<h3>General parameter</h3>
The rod can be specified by a parameter vector r.
r is resolved in the body system and points from frame a to frame b.
<h3>Visualization</h3>
The element is normally visualized as cylinder. Anyhow the visualization can be changed by the according parameters.
</html>"));
      end FixedTranslation;

      annotation (preferedView="info", Documentation(info="<html>
This package contains completely rigid components.
<p>
These components are either define a mass and inertia or they define a fixed relationship.
</html>"));
    end Parts;

    package Examples "Examples"
    annotation (Icon(
          Rectangle(extent=[-100,-100; 80,50],   style(
              color=0,
              fillColor=30,
              fillPattern=1)),
          Polygon(points=[100,70; 100,-80; 80,-100; 80,50; 100,70],      style(
              color=0,
              fillColor=30,
              fillPattern=1)),
          Text(
            extent=[-85,71; 65,-49],
            string="Sample",
            style(color=0)),
          Text(
            extent=[-97,23; 78,-98],
            string="Programs",
            style(color=0)),
          Text(
            extent=[-112,112; 128,63],
            string="%name",
            style(color=1)),
          Polygon(points=[-100,50; -80,70; 100,70; 80,50; -100,50], style(
            color=0,
            rgbcolor={0,0,0},
            fillColor=30,
            rgbfillColor={235,235,235},
            fillPattern=1))), preferedView="info", Documentation(info="<html>
This package contains various examples.
<p>
These examples demonstrate the usage of the Mechanics3DwithImpulses library.
<p>
For all these examples the following simulation setup is proposed.
<ul>
<li>Start time: 0 seconds
<li>Stop time: 10 seconds
<li>Number of intervals: 2500
<li>Algorithm: DASSL
</ul>
Don't forget to open an animation window.
</html>"));

      model MixedModel "ball attached to a spring bouncing on the floor"
                  extends Modelica.Icons.Example;
        inner Mechanics3D.World3D world3D(     n={0,-1,0}, g=9.81)
          annotation (extent=[40,60; 60,80]);
        annotation (Diagram, experiment(StopTime=10, NumberOfIntervals=2500),
      preferedView="info", Documentation(info="<html>
This example demonstrates how to create a mixed model.
<p>
<img src=\"../Images/MixedModel.png\">
</p>
<p>
The fixation and the spring are continuous models of the Mechanics3D library.
All other elements are taken from this library.
Both types can be connected by the special interface element: \"ConnectContinuousFrame\".
</html>"));
        Joints.FreeTranslationalMovement FreeTranslationalMovement1(initType=
              Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
          enforceStates=false,
          reinitByImpulse=true,
          x_start={0.2,0.5,0})
          annotation (extent=[-80,0; -60,20]);
        Parts.SimpleBody SimpleBody1(sphereDiameter=0.1)
                                     annotation (extent=[22,0; 42,20]);
        Contacts.CollisionSpherePlane CollisionSphereSphere1(ra=0.05)
          annotation (extent=[28,-34; 8,-14], rotation=270);
        Interfaces.InsertImpulse InsertImpulse1 annotation (extent=[0,20; 20,0]);
        Mechanics3D.Parts.Fixed Fixed1(r={0,1,0})
          annotation (extent=[-80,40; -58,60]);
        Mechanics3D.Forces.Spring Spring1(      s0=0.5,
          numberOfWindings=5,
          c=12,
          width=0.05)
          annotation (extent=[-40,40; -20,60]);
        inner CollisionPool collisionPool
          annotation (extent=[70,60; 90,80]);
        Interfaces.InsertImpulse InsertImpulse2
          annotation (extent=[8,-58; 28,-38], rotation=90);
        Parts.Fixed Fixed2 annotation (extent=[8,-80; 28,-60], rotation=90);
        Interfaces.ConnectContinousFrame ConnectContinousFrame1
          annotation (extent=[-8,40; 12,60]);
      equation
        connect(InsertImpulse1.frame_a, FreeTranslationalMovement1.frame_b)
          annotation (points=[3,10; -59,10], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(InsertImpulse1.frame_b, SimpleBody1.frame_a) annotation (points=[17,10;
              21,10],        style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(CollisionSphereSphere1.frame_a, SimpleBody1.frame_a)
          annotation (points=[18,-13; 20,-13; 20,10; 21,10], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(Spring1.frame_a, Fixed1.frame_b) annotation (points=[-41,50;
              -56.9,50], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(CollisionSphereSphere1.y, InsertImpulse1.u) annotation (points=
              [11,-24; 10,-24; 10,3], style(color=5, rgbcolor={255,0,255}));
        connect(InsertImpulse2.frame_b, CollisionSphereSphere1.frame_b)
          annotation (points=[18,-41; 18,-38; 18,-35; 18,-35], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Fixed2.frame_b, InsertImpulse2.frame_a) annotation (points=[18,
              -59; 18,-55; 18,-55], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(InsertImpulse2.u, CollisionSphereSphere1.y) annotation (points=
              [11,-48; 8,-48; 8,-24; 11,-24], style(color=5, rgbcolor={255,0,
                255}));
        connect(ConnectContinousFrame1.frame_a, Spring1.frame_b) annotation (
            points=[-5,50; -19,50], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(ConnectContinousFrame1.frame_b, SimpleBody1.frame_a)
          annotation (points=[9,50; 16,50; 16,48; 21,48; 21,10], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
      end MixedModel;

      model BouncingPendulum "pendulum bouncing on the floor"
                  extends Modelica.Icons.Example;
        annotation (Diagram, experiment(StopTime=10, NumberOfIntervals=2500),
      preferedView="info",  Documentation(info="<html>
This example presents a pendulum bouncing on the floor.
<p>
<img src=\"../Images/BouncingPendulum.png\">
</p>
</html>"));
        Parts.SimpleBody SimpleBody1(sphereDiameter=0.1)
                                     annotation (extent=[30,40; 50,60]);
        Contacts.CollisionSpherePlane CollisionSphereSphere1(ra=0.05)
          annotation (extent=[40,10; 20,30], rotation=270);
        Interfaces.InsertImpulse InsertImpulse1
          annotation (extent=[0,60; 20,40]);
        Parts.Fixed Fixed2(r={0,0.5,0})
                           annotation (extent=[-100,40; -80,60], rotation=0);
        Joints.Revolute Revolute1(enforceStates=true, initType=Modelica.
              Mechanics.MultiBody.Types.Init.PositionVelocity)
          annotation (extent=[-70,40; -50,60]);
        Parts.FixedTranslation FixedTranslation1(r={-0.6,0,0})
          annotation (extent=[-38,40; -18,60]);
        inner World3D world3D annotation (extent=[-100,-60; -80,-40]);
        Parts.Fixed Fixed1 annotation (extent=[20,-40; 40,-20], rotation=90);
        Interfaces.InsertImpulse InsertImpulse2
          annotation (extent=[20,4; 40,-16], rotation=90);
        inner CollisionPool collisionPool
          annotation (extent=[-60,-60; -40,-40]);
      equation
        connect(InsertImpulse1.frame_b, SimpleBody1.frame_a) annotation (points=[17,50;
              29,50],        style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(CollisionSphereSphere1.frame_a, SimpleBody1.frame_a)
          annotation (points=[30,31; 28,31; 28,50; 29,50],   style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(FixedTranslation1.frame_b, InsertImpulse1.frame_a) annotation (
            points=[-17,50; 3,50], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(FixedTranslation1.frame_a, Revolute1.frame_b) annotation (
            points=[-39,50; -49,50], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(Fixed2.frame_b, Revolute1.frame_a) annotation (points=[-79,50;
              -71,50], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(CollisionSphereSphere1.y, InsertImpulse1.u) annotation (points=
              [23,20; 10,20; 10,43], style(color=5, rgbcolor={255,0,255}));
        connect(InsertImpulse2.frame_b, Fixed1.frame_b) annotation (points=[30,
              -13; 30,-19], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(InsertImpulse2.frame_a, CollisionSphereSphere1.frame_b)
          annotation (points=[30,1; 30,5; 30,9; 30,9], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(InsertImpulse2.u, CollisionSphereSphere1.y) annotation (points=
              [23,-6; 10,-6; 10,20; 23,20], style(
            color=5,
            rgbcolor={255,0,255},
            gradient=1,
            fillColor=75,
            rgbfillColor={85,85,255}));
      end BouncingPendulum;

      model NewtonsCradle "An implementation of Newton's Cradle"
                  extends Modelica.Icons.Example;
        inner Mechanics3D.World3D world3D(     n={0,-1,0}, g=9.81,
          nominalLength=5,
          animateWorld=false,
          animateGravity=false)
          annotation (extent=[-100,-100; -80,-80]);
        annotation (Diagram, experiment(StopTime=10, NumberOfIntervals=2500),
      Coordsys(extent=[-100,-100; 160,100]), preferedView="info",
          Documentation(info="<html>
This example presents the model of Newton's cadle.
<p>
<img src=\"../Images/NewtonsCradle.png\">
</p>
</html>"));
        Parts.SimpleBody SimpleBody1(sphereDiameter=0.5,
          I_11=0.01,
          I_22=0.01,
          I_33=0.01)                 annotation (extent=[-100,-40; -80,-20],
            rotation=270);
        Interfaces.InsertImpulse InsertImpulse1
          annotation (extent=[-80,0; -100,-20], rotation=90);
        Parts.Fixed Fixed2 annotation (extent=[-100,80; -80,100], rotation=270);
        Joints.Revolute Revolute1(enforceStates=true,
          initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
          w_start=0,
          phi_start=-40)
          annotation (extent=[-100,40; -80,60], rotation=270);
        Parts.FixedTranslation FixedTranslation1(r={0,-2,0})
          annotation (extent=[-100,0; -80,20], rotation=270);
        Parts.SimpleBody SimpleBody2(m=1, sphereDiameter=0.5,
          I_11=0.01,
          I_22=0.01,
          I_33=0.01)                 annotation (extent=[-40,-40; -20,-20],
            rotation=270);
        Interfaces.InsertImpulse InsertImpulse2
          annotation (extent=[-40,0; -20,-20],
                                             rotation=90);
        Parts.Fixed Fixed1(r={0.5,0,0})
                           annotation (extent=[-40,80; -20,100],
                                                               rotation=270);
        Joints.Revolute Revolute2(enforceStates=true,
          initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
          w_start=0,
          phi_start=-40)
          annotation (extent=[-40,40; -20,60],
                                             rotation=270);
        Parts.FixedTranslation FixedTranslation2(r={0,-2,0})
          annotation (extent=[-40,0; -20,20],
                                            rotation=270);
        Contacts.CollisionSphereSphere CollisionSphereSphere1(ra=0.2499, rb=
              0.2499,
          elasticity=1.0)
          annotation (extent=[-70,-40; -50,-20]);
        Parts.SimpleBody SimpleBody3(m=1, sphereDiameter=0.5,
          I_11=0.01,
          I_22=0.01,
          I_33=0.01)                 annotation (extent=[20,-40; 40,-20],
            rotation=270);
        Interfaces.InsertImpulse InsertImpulse3
          annotation (extent=[20,0; 40,-20], rotation=90);
        Parts.Fixed Fixed3(r={1,0,0})
                           annotation (extent=[20,80; 40,100], rotation=270);
        Joints.Revolute Revolute3(enforceStates=true,
          initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
          phi_start=0,
          w_start=0)
          annotation (extent=[20,40; 40,60], rotation=270);
        Parts.FixedTranslation FixedTranslation3(r={0,-2,0})
          annotation (extent=[20,0; 40,20], rotation=270);
        Contacts.CollisionSphereSphere CollisionSphereSphere2(ra=0.2499, rb=
              0.2499,
          elasticity=1.0)
          annotation (extent=[-10,-40; 10,-20]);
        Modelica.Blocks.Logical.Or Or1
          annotation (extent=[-52,-2; -40,8], rotation=270);
        Parts.SimpleBody SimpleBody4(m=1, sphereDiameter=0.5,
          I_11=0.01,
          I_22=0.01,
          I_33=0.01)                 annotation (extent=[80,-42; 100,-22],
            rotation=270);
        Interfaces.InsertImpulse InsertImpulse4
          annotation (extent=[80,0; 100,-20],rotation=90);
        Parts.Fixed Fixed4(r={1.5,0,0})
                           annotation (extent=[80,80; 100,100],rotation=270);
        Joints.Revolute Revolute4(enforceStates=true,
          initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
          phi_start=0,
          w_start=0)
          annotation (extent=[80,40; 100,60],rotation=270);
        Parts.FixedTranslation FixedTranslation4(r={0,-2,0})
          annotation (extent=[80,0; 100,20],rotation=270);
        Contacts.CollisionSphereSphere CollisionSphereSphere3(ra=0.2499, rb=
              0.2499,
          elasticity=1.0,
          muR=0)
          annotation (extent=[50,-40; 70,-20]);
        Modelica.Blocks.Logical.Or Or2
          annotation (extent=[6,-2; 18,8],    rotation=270);
        Parts.SimpleBody SimpleBody5(m=1, sphereDiameter=0.5,
          I_11=0.01,
          I_22=0.01,
          I_33=0.01)                 annotation (extent=[140,-42; 160,-22],
            rotation=270);
        Interfaces.InsertImpulse InsertImpulse5
          annotation (extent=[140,0; 160,-20],
                                             rotation=90);
        Parts.Fixed Fixed5(r={2,0,0})
                           annotation (extent=[140,80; 160,100],
                                                               rotation=270);
        Joints.Revolute Revolute5(enforceStates=true,
          initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
          w_start=0,
          phi_start=80)
          annotation (extent=[140,40; 160,60],
                                             rotation=270);
        Parts.FixedTranslation FixedTranslation5(r={0,-2,0})
          annotation (extent=[140,0; 160,20],
                                            rotation=270);
        Contacts.CollisionSphereSphere CollisionSphereSphere4(ra=0.2499, rb=
              0.2499,
          elasticity=1.0)
          annotation (extent=[110,-42; 130,-22]);
        Modelica.Blocks.Logical.Or Or3
          annotation (extent=[66,-2; 78,8],   rotation=270);
        inner CollisionPool collisionPool
          annotation (extent=[-60,-100; -40,-80]);
        Parts.FixedTranslation FixedTranslation6(r={2,0,0})
          annotation (extent=[-74,70; -64,86], rotation=0);
      equation
        connect(InsertImpulse1.frame_b, SimpleBody1.frame_a) annotation (points=[-90,-17;
              -90,-19],      style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(FixedTranslation1.frame_b, InsertImpulse1.frame_a) annotation (
            points=[-90,-1; -90,-3],
                                   style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(FixedTranslation1.frame_a, Revolute1.frame_b) annotation (
            points=[-90,21; -90,39], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(Fixed2.frame_b, Revolute1.frame_a) annotation (points=[-90,79;
              -90,61], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(InsertImpulse2.frame_b,SimpleBody2. frame_a) annotation (points=[-30,-17;
              -30,-18; -30,-19; -30,-19],
                             style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(FixedTranslation2.frame_b,InsertImpulse2. frame_a) annotation (
            points=[-30,-1; -30,-2; -30,-2; -30,-3],
                                   style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(FixedTranslation2.frame_a,Revolute2. frame_b) annotation (
            points=[-30,21; -30,25.5; -30,25.5; -30,30; -30,39; -30,39],
                                     style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(Fixed1.frame_b,Revolute2. frame_a) annotation (points=[-30,79;
              -30,74.5; -30,74.5; -30,70; -30,61; -30,61],
                       style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(CollisionSphereSphere1.y, InsertImpulse1.u) annotation (points=[-60,-23;
              -60,-10; -83,-10],           style(color=5, rgbcolor={255,0,255}));
        connect(SimpleBody1.frame_a, CollisionSphereSphere1.frame_a)
          annotation (points=[-90,-19; -90,-18; -78,-18; -78,-30; -71,-30],
            style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(SimpleBody2.frame_a, CollisionSphereSphere1.frame_b)
          annotation (points=[-30,-19; -30,-18; -46,-18; -46,-30; -49,-30],
            style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(InsertImpulse3.frame_b,SimpleBody3. frame_a) annotation (points=[30,-17;
              30,-18; 30,-19; 30,-19],
                             style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(FixedTranslation3.frame_b,InsertImpulse3. frame_a) annotation (
            points=[30,-1; 30,-2; 30,-2; 30,-3],
                                   style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(FixedTranslation3.frame_a,Revolute3. frame_b) annotation (
            points=[30,21; 30,25.5; 30,25.5; 30,30; 30,39; 30,39],
                                     style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(Fixed3.frame_b,Revolute3. frame_a) annotation (points=[30,79;
              30,74.5; 30,74.5; 30,70; 30,61; 30,61],
                       style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(SimpleBody2.frame_a, CollisionSphereSphere2.frame_a)
          annotation (points=[-30,-19; -30,-18; -14,-18; -14,-30; -11,-30],
                                                              style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(SimpleBody3.frame_a, CollisionSphereSphere2.frame_b)
          annotation (points=[30,-19; 30,-18; 14,-18; 14,-30; 11,-30], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Or1.y, InsertImpulse2.u) annotation (points=[-46,-2.5; -46,-10;
              -37,-10], style(color=5, rgbcolor={255,0,255}));
        connect(CollisionSphereSphere1.y, Or1.u2) annotation (points=[-60,-23;
              -60,9; -50.8,9], style(color=5, rgbcolor={255,0,255}));
        connect(CollisionSphereSphere2.y, Or1.u1) annotation (points=[0,-23; 0,
              9; -46,9],    style(color=5, rgbcolor={255,0,255}));
        connect(InsertImpulse4.frame_b,SimpleBody4. frame_a) annotation (points=[90,-17;
              90,-21],       style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(FixedTranslation4.frame_b,InsertImpulse4. frame_a) annotation (
            points=[90,-1; 90,-3], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(FixedTranslation4.frame_a,Revolute4. frame_b) annotation (
            points=[90,21; 90,39],   style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(Fixed4.frame_b,Revolute4. frame_a) annotation (points=[90,79;
              90,61],  style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(SimpleBody4.frame_a,CollisionSphereSphere3. frame_b)
          annotation (points=[90,-21; 90,-18; 74,-18; 74,-30; 71,-30], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(CollisionSphereSphere2.y, Or2.u2) annotation (points=[0,-23; 0,
              9; 7.2,9], style(color=5, rgbcolor={255,0,255}));
        connect(Or2.y, InsertImpulse3.u) annotation (points=[12,-2.5; 12,-10;
              23,-10], style(color=5, rgbcolor={255,0,255}));
        connect(CollisionSphereSphere3.y, Or2.u1) annotation (points=[60,-23;
              60,9; 12,9], style(color=5, rgbcolor={255,0,255}));
        connect(SimpleBody3.frame_a, CollisionSphereSphere3.frame_a)
          annotation (points=[30,-19; 30,-18; 49,-18; 49,-30], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(InsertImpulse5.frame_b,SimpleBody5. frame_a) annotation (points=[150,-17;
              150,-21],      style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(FixedTranslation5.frame_b,InsertImpulse5. frame_a) annotation (
            points=[150,-1; 150,-3],
                                   style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(FixedTranslation5.frame_a,Revolute5. frame_b) annotation (
            points=[150,21; 150,39], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(Fixed5.frame_b,Revolute5. frame_a) annotation (points=[150,79;
              150,61], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(CollisionSphereSphere4.y,InsertImpulse5. u) annotation (points=[120,-25;
              120,-10; 143,-10],        style(color=5, rgbcolor={255,0,255}));
        connect(SimpleBody5.frame_a,CollisionSphereSphere4. frame_b)
          annotation (points=[150,-21; 150,-18; 134,-18; 134,-32; 131,-32],
                                                                       style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(SimpleBody4.frame_a, CollisionSphereSphere4.frame_a)
          annotation (points=[90,-21; 90,-18; 110,-18; 110,-26; 109,-32], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(CollisionSphereSphere3.y, Or3.u2) annotation (points=[60,-23;
              60,9; 67.2,9], style(color=5, rgbcolor={255,0,255}));
        connect(Or3.y, InsertImpulse4.u) annotation (points=[72,-2.5; 72,-10;
              83,-10], style(color=5, rgbcolor={255,0,255}));
        connect(CollisionSphereSphere4.y, Or3.u1) annotation (points=[120,-25;
              120,9; 72,9], style(color=5, rgbcolor={255,0,255}));
        connect(FixedTranslation6.frame_a, Fixed2.frame_b) annotation (points=[
              -74.5,78; -80,78; -80,79; -90,79], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
      end NewtonsCradle;

      model BulletOnPendulum "a bullet hits a pendulum"
                  extends Modelica.Icons.Example;
        inner Mechanics3D.World3D world3D(     n={0,-1,0}, g=0,
          animateGravity=false)
          annotation (extent=[60,82; 80,102]);
        annotation (Diagram, experiment(StopTime=10, NumberOfIntervals=2500),
      preferedView="info", Documentation(info="<html>
This example presents a pendulum fully hit by a free flying bullet.
<p>
<img src=\"../Images/BulletOnPendulum.png\">
</p>
</html>"));
        Parts.SimpleBody SimpleBody1(sphereDiameter=0.5, m=1)
                                     annotation (extent=[-80,-40; -60,-20],
            rotation=270);
        Interfaces.InsertImpulse InsertImpulse1
          annotation (extent=[-60,0; -80,-20], rotation=90);
        Parts.SimpleBody SimpleBody2(sphereDiameter=0.5, m=1)
                                     annotation (extent=[0,-40; 20,-20],
            rotation=270);
        Interfaces.InsertImpulse InsertImpulse2
          annotation (extent=[0,0; 20,-20], rotation=90);
        Contacts.CollisionSphereSphere CollisionSphereSphere1(ra=0.25, rb=0.25,
          elasticity=1.0)
          annotation (extent=[-40,-40; -20,-20]);
        Joints.FreeTranslationalMovement FreeTranslationalMovement1(initType=
              Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
          v_start={4,0,0},
          enforceStates=false,
          reinitByImpulse=true,
          x_start={-2,-2,0})
          annotation (extent=[-80,40; -62,60], rotation=270);
        Parts.Fixed Fixed1(r={1,0,0})
                           annotation (extent=[0,80; 20,100], rotation=270);
        Joints.Revolute Revolute2(enforceStates=true,
          initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
          phi_start=0,
          w_start=0,
          cylinderLength=0.5,
          cylinderDiameter=0.3)
          annotation (extent=[0,40; 20,60], rotation=270);
        Parts.FixedTranslation FixedTranslation2(r={0,-2,0})
          annotation (extent=[0,0; 20,20], rotation=270);

        inner CollisionPool collisionPool
          annotation (extent=[60,40; 80,60]);
      equation
        connect(InsertImpulse1.frame_b, SimpleBody1.frame_a) annotation (points=[-70,-17;
              -70,-19],      style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(InsertImpulse2.frame_b,SimpleBody2. frame_a) annotation (points=[10,-17;
              10,-18; 10,-19; 10,-19],
                             style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(CollisionSphereSphere1.y, InsertImpulse1.u) annotation (points=
              [-30,-23; -30,-10; -63,-10], style(color=5, rgbcolor={255,0,255}));
        connect(CollisionSphereSphere1.y, InsertImpulse2.u) annotation (points=
              [-30,-23; -30,-10; 3,-10], style(color=5, rgbcolor={255,0,255}));
        connect(SimpleBody1.frame_a, CollisionSphereSphere1.frame_a)
          annotation (points=[-70,-19; -70,-18; -48,-18; -48,-30; -41,-30],
            style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(SimpleBody2.frame_a, CollisionSphereSphere1.frame_b)
          annotation (points=[10,-19; 10,-18; -14,-18; -14,-30; -19,-30], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FreeTranslationalMovement1.frame_b, InsertImpulse1.frame_a)
          annotation (points=[-71,39; -71,18; -70,18; -70,-3], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FixedTranslation2.frame_a,Revolute2. frame_b) annotation (
            points=[10,21; 10,25.5; 10,25.5; 10,30; 10,39; 10,39],
                                     style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(Fixed1.frame_b,Revolute2. frame_a) annotation (points=[10,79;
              10,74.5; 10,74.5; 10,70; 10,61; 10,61],
                       style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(FixedTranslation2.frame_b, InsertImpulse2.frame_a) annotation (
            points=[10,-1; 10,-1.5; 10,-3; 10,-3], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
      end BulletOnPendulum;

      model BouncingSpherical "a spherical pendulum bouncing on the floor"
                  extends Modelica.Icons.Example;
        inner Mechanics3D.World3D world3D(     n={0,-1,0}, g=9.81,
          nominalLength=3)
          annotation (extent=[-80,-60; -60,-40]);
        annotation (Diagram, experiment(StopTime=10, NumberOfIntervals=2500),
      preferedView="info", Documentation(info="<html>
This example presents a spherical-pendulum bouncing on the floor.
<p>
<img src=\"../Images/BouncingSpherical.png\">
</p>
</html>"));
        Parts.SimpleBody SimpleBody1(sphereDiameter=0.4)
                                     annotation (extent=[20,20; 40,40]);
        Contacts.CollisionSpherePlane CollisionSphereSphere1(ra=0.2)
          annotation (extent=[26,-18; 6,2], rotation=270);
        Interfaces.InsertImpulse InsertImpulse1
          annotation (extent=[-10,40; 10,20]);
        Parts.Fixed Fixed2 annotation (extent=[-100,20; -80,40]);
        Parts.FixedTranslation FixedTranslation1(r={-1.3,0,0})
          annotation (extent=[-40,20; -20,40]);
        Joints.Spherical Spherical1(
          reinitByImpulse=true,
          initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
          w_start={0,80,0},
          useQuaternions=false) annotation (extent=[-70,20; -50,40]);
        Interfaces.InsertImpulse InsertImpulse2
          annotation (extent=[6,-44; 26,-24], rotation=90);
        Parts.Fixed Fixed1(r={0,-1,0})
          annotation (extent=[6,-70; 26,-50], rotation=90);
        inner CollisionPool collisionPool annotation (extent=[-40,-60; -20,-40]);
      equation
        connect(InsertImpulse1.frame_b, SimpleBody1.frame_a) annotation (points=[7,30; 19,
              30],           style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(FixedTranslation1.frame_b, InsertImpulse1.frame_a) annotation (
            points=[-19,30; -7,30],style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(Spherical1.frame_b, FixedTranslation1.frame_a) annotation (
            points=[-49,30; -41,30], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Spherical1.frame_a, Fixed2.frame_b) annotation (points=[-71,30;
              -79,30], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(SimpleBody1.frame_a, CollisionSphereSphere1.frame_a)
          annotation (points=[19,30; 16,30; 16,3], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(InsertImpulse2.frame_b, CollisionSphereSphere1.frame_b)
          annotation (points=[16,-27; 16,-23; 16,-19; 16,-19], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(InsertImpulse2.u, CollisionSphereSphere1.y) annotation (points=[9,-34; 0,
              -34; 0,-8; 9,-8],           style(color=5, rgbcolor={255,0,255}));
        connect(CollisionSphereSphere1.y, InsertImpulse1.u) annotation (points=[9,-8; 0,
              -8; 0,23],          style(color=5, rgbcolor={255,0,255}));
        connect(Fixed1.frame_b, InsertImpulse2.frame_a) annotation (points=[16,
              -49; 16,-41], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
      end BouncingSpherical;

      model FourBarLoop "a kinematic loops underlies hard impacts"
                 extends Modelica.Icons.Example;

        inner Mechanics3D.World3D world3D(nominalLength=1, g=9.81)
                                               annotation (extent=[-100,-100; -80,-80]);
        annotation (Diagram, experiment(StopTime=10, NumberOfIntervals=2500),
      preferedView="info", Documentation(info="<html>
This example presents a model of a kinematic loop colliding to a plane.
<p>
<img src=\"../Images/ImpactLoop.png\">
</p>
<p>
Kinematic loops have to be closed manually.
</html>"));
        Parts.Fixed Fixed1 annotation (extent=[-100,-40; -80,-20]);
        Parts.FixedTranslation FixedTranslation1(r={0,0.5,0.1}, width=0.05)
          annotation (extent=[-80,12; -60,32],rotation=90);
        Joints.Revolute Revolute1(
          initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
          n={1,0,0},
          phi_start=0,
          enforceStates=true,
          w_start=300)          annotation (extent=[-80,-20; -60,0], rotation=90);
        Parts.FixedTranslation FixedTranslation2(r={0,0.2,0}, width=0.05)
          annotation (extent=[40,-30; 60,-10], rotation=90);
        Parts.FixedTranslation FixedTranslation3(r={1,-0.3,-0.1}, width=0.05)
          annotation (extent=[-8,60; 12,80]);
        Parts.FixedTranslation FixedTranslation4(r={1.2,0,0}, animation=
              false)
          annotation (extent=[-20,-80; 0,-60],  rotation=0);
        Parts.SimpleBody Body2(
          m=0.5,
          I_11=0.05,
          I_22=0.05,
          I_33=0.05,
          I_21=0,
          I_31=0,
          I_32=0,
          animation=false)
                     annotation (extent=[22,40; 42,60], rotation=0);
        Joints.Prismatic Prismatic1(
          s_start=0,
          v_start=0,
          initType=Modelica.Mechanics.MultiBody.Types.Init.Free)
          annotation (extent=[88,-60; 68,-40]);
        Joints.Revolute Revolute4(n={0,0,1}, initType=Modelica.Mechanics.
              MultiBody.Types.Init.Free)
          annotation (extent=[52,24; 72,44],   rotation=0);
        Joints.Revolute Revolute6(n={0,1,0}, initType=Modelica.Mechanics.
              MultiBody.Types.Init.Free)
          annotation (extent=[74,44; 94,64],   rotation=90);
        Parts.FixedTranslation FixedTranslation5(r={0,0.25,0.05}, animation=
              false)
          annotation (extent=[-100,8; -80,28],rotation=90);
        Parts.SimpleBody Body1(
          m=0.5,
          I_11=0.05,
          I_22=0.05,
          I_33=0.05,
          I_21=0,
          I_31=0,
          I_32=0,
          animation=false)
                     annotation (extent=[-100,40; -80,60],rotation=90);
        Parts.SimpleBody Body3(
          m=0.5,
          I_11=0.05,
          I_22=0.05,
          I_33=0.05,
          I_21=0,
          I_31=0,
          I_32=0,
          animation=false)
                     annotation (extent=[60,0; 80,20], rotation=90);
        Parts.FixedTranslation FixedTranslation6(r={0.5,-0.15,-0.05}, animation=
             false)
          annotation (extent=[-8,40; 12,60]);
        Parts.FixedTranslation FixedTranslation7(r={0,0.1,0}, animation=false)
          annotation (extent=[60,-30; 80,-10], rotation=90);
        Joints.Spherical Spherical1(useQuaternions=false, sphereDiameter=0.1)
          annotation (extent=[-80,40; -60,60], rotation=90);
        Joints.CloseLoop CloseLoop1 annotation (extent=[40,60; 60,80]);
        Interfaces.InsertImpulse InsertImpulse1
          annotation (extent=[-60,-80; -40,-60]);
        Contacts.CollisionSpherePlane CollisionSpherePlane1(ra=0.05)
          annotation (extent=[-40,-20; -20,-40]);
        Parts.Fixed Fixed2 annotation (extent=[20,-40; 0,-20],  rotation=0);
        Interfaces.InsertImpulse InsertImpulse2
          annotation (extent=[-20,-20; 0,-40],
                                             rotation=0);
        inner CollisionPool collisionPool
          annotation (extent=[-60,-100; -40,-80]);
      equation
        connect(Revolute1.frame_a, Fixed1.frame_b) annotation (points=[-70,-21; -70,
              -30; -79,-30],
            style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=10,
            rgbfillColor={135,135,135},
            fillPattern=1));
        connect(FixedTranslation1.frame_a, Revolute1.frame_b) annotation (points=[-70,11;
              -70,1],    style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FixedTranslation4.frame_b, Prismatic1.frame_a) annotation (points=[1,-70;
              90,-70; 90,-50; 89,-50],          style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Prismatic1.frame_b, FixedTranslation2.frame_a) annotation (points=[67,-50;
              50,-50; 50,-31],      style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FixedTranslation2.frame_b, Revolute4.frame_a) annotation (points=[50,-9;
              50,34; 51,34],     style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FixedTranslation5.frame_a, FixedTranslation1.frame_a) annotation (
            points=[-90,7; -70,6; -70,11],       style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Body1.frame_a, FixedTranslation5.frame_b) annotation (points=[-90,39;
              -90,29], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FixedTranslation6.frame_a, FixedTranslation3.frame_a) annotation (
            points=[-9,50; -9,70], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Body2.frame_a, FixedTranslation6.frame_b) annotation (points=[21,50;
              13,50], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FixedTranslation7.frame_a, FixedTranslation2.frame_a) annotation (
            points=[70,-31; 50,-31], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Body3.frame_a, FixedTranslation7.frame_b) annotation (points=[70,-1;
              70,-9], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Spherical1.frame_b, FixedTranslation3.frame_a)       annotation (
            points=[-70,61; -70,70; -9,70], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Spherical1.frame_a, FixedTranslation1.frame_b)       annotation (
            points=[-70,39; -70,33], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Revolute6.frame_a, Revolute4.frame_b) annotation (points=[84,43; 84,
              34; 73,34], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(CloseLoop1.frame_a, FixedTranslation3.frame_b) annotation (
            points=[39,70; 13,70], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(CloseLoop1.frame_b, Revolute6.frame_b) annotation (points=[61,
              70; 84,70; 84,65], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Fixed1.frame_b, InsertImpulse1.frame_a) annotation (points=[-79,
              -30; -80,-30; -80,-70; -57,-70], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(InsertImpulse1.frame_b, FixedTranslation4.frame_a) annotation (
            points=[-43,-70; -21,-70], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FixedTranslation1.frame_b, CollisionSpherePlane1.frame_a)
          annotation (points=[-70,33; -46,33; -46,-30; -41,-30], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(CollisionSpherePlane1.y, InsertImpulse1.u) annotation (points=[-30,-37;
              -30,-44; -50,-44; -50,-63],              style(color=5, rgbcolor=
                {255,0,255}));
        connect(InsertImpulse2.frame_a, CollisionSpherePlane1.frame_b)
          annotation (points=[-17,-30; -19,-30], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Fixed2.frame_b, InsertImpulse2.frame_b) annotation (points=[-1,
              -30; -3,-30], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(InsertImpulse1.u, InsertImpulse2.u) annotation (points=[-50,-63;
              -50,-44; -10,-44; -10,-37], style(color=5, rgbcolor={255,0,255}));
      end FourBarLoop;

      model CueStrikingBall "a cue hitting a ball"
                  extends Modelica.Icons.Example;
        inner Mechanics3D.World3D world3D(     n={0,-1,0},
          nominalLength=3,
          g=0,
          animateWorld=false,
          animateGravity=false)
          annotation (extent=[20,60; 40,80]);
        annotation (Diagram, experiment(StopTime=10, NumberOfIntervals=2500),
      preferedView="info", Documentation(info="<html>
This example presents a cue striking at a ball.
The ball starts to rotate, due to friction.
<p>
<img src=\"../Images/Cue.png\">
</p>
</html>"));
        Parts.SimpleBody SimpleBody1(
          I_11=0.02,
          I_22=0.02,
          I_33=0.02,
          m=3,
          sphereDiameter=0.06)       annotation (extent=[-38,-20; -18,0]);
        Interfaces.InsertImpulse InsertImpulse1
          annotation (extent=[-60,-20; -40,0]);
        Interfaces.InsertImpulse InsertImpulse2
          annotation (extent=[-60,60; -40,40]);
        Contacts.CollisionSphereSphere CollisionSphereSphere1(
          contactDuration=1e-3,
          elasticity=0.8,
          muR=0.2,
          ra=0.03,
          rb=0.15)        annotation (extent=[-52,10; -32,30], rotation=90);
        Parts.FixedTranslation FixedTranslation1(r={0,-0.25,0})
          annotation (extent=[-52,64; -32,84], rotation=90);
        Parts.FixedTranslation FixedTranslation2(r={-1.5,0,0}, color={100,90,0})
          annotation (extent=[-54,-40; -34,-20], rotation=270);
        Joints.FreeBodyMovement FreeBodyMovement2(
          initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
          reinitByImpulse=true,
          v_start={4,0,0},
          x_start={-2,0.05,0})
                              annotation (extent=[-80,-20; -60,0]);
        Parts.SimpleBody SimpleBody3(
          I_11=0.02,
          sphereDiameter=0.2,
          m=6,
          I_22=0.2,
          I_33=0.2,
          animation=false)           annotation (extent=[-40,-60; -20,-40]);
        Parts.Body Body1(
          animation=true,
          m=4,
          I_11=0.02,
          I_22=0.02,
          I_33=0.02,
          initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
          reinitByImpulse=true,
          sphereDiameter=0.3)   annotation (extent=[-40,40; -20,60]);
        inner CollisionPool collisionPool annotation (extent=[60,60; 80,80]);
        Parts.FixedTranslation FixedTranslation3(r={0,0.25,0})
          annotation (extent=[-30,64; -10,84], rotation=90);
        Parts.FixedTranslation FixedTranslation4(r={-0.25,0,0})
          annotation (extent=[-94,64; -74,84], rotation=90);
        Parts.FixedTranslation FixedTranslation5(r={0.25,0,0})
          annotation (extent=[-68,64; -48,84], rotation=90);
      equation
        connect(InsertImpulse1.frame_b, SimpleBody1.frame_a) annotation (points=[-43,-10;
              -39,-10],      style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(CollisionSphereSphere1.frame_a, SimpleBody1.frame_a)
          annotation (points=[-42,9; -42,-10; -39,-10], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(CollisionSphereSphere1.y, InsertImpulse2.u) annotation (points=
              [-49,20; -50,20; -50,43], style(color=5, rgbcolor={255,0,255}));
        connect(CollisionSphereSphere1.y, InsertImpulse1.u) annotation (points=[-49,20;
              -50,20; -50,-3],          style(color=5, rgbcolor={255,0,255}));
        connect(FixedTranslation2.frame_a, SimpleBody1.frame_a) annotation (
            points=[-44,-19; -44,-10; -39,-10], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FreeBodyMovement2.frame_b, InsertImpulse1.frame_a) annotation (
            points=[-59,-10; -57,-10], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(SimpleBody3.frame_a, FixedTranslation2.frame_b) annotation (
            points=[-41,-50; -44,-50; -44,-41], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FixedTranslation1.frame_a, Body1.frame_a) annotation (points=[-42,63;
              -42,50; -41,50],         style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(InsertImpulse2.frame_b, Body1.frame_a) annotation (points=[-43,50;
              -41,50],     style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(CollisionSphereSphere1.frame_b, Body1.frame_a) annotation (
            points=[-42,31; -42,50; -41,50], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FixedTranslation1.frame_a, FixedTranslation3.frame_a)
          annotation (points=[-42,63; -20,63], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FixedTranslation4.frame_a, Body1.frame_a) annotation (points=[-84,63;
              -84,64; -42,64; -42,50; -41,50],
                                       style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FixedTranslation4.frame_a, FixedTranslation5.frame_a)
          annotation (points=[-84,63; -72,64; -72,63; -58,63], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
      end CueStrikingBall;

      model BouncingBall "a rotating ball bouncing on the floor"
                  extends Modelica.Icons.Example;
        inner Mechanics3D.World3D world3D(     n={0,-1,0},
          nominalLength=3,
          g=9.81)
          annotation (extent=[20,60; 40,80]);
        annotation (Diagram, experiment(StopTime=10, NumberOfIntervals=2500),
      preferedView="info", Documentation(info="<html>
A heavily rotating ball is bouncing on the floor.
It picks up tranlsational velocity, due to friction.
<p>
<img src=\"../Images/BouncingBall.png\">
</p>
</html>"));
        Interfaces.InsertImpulse InsertImpulse1
          annotation (extent=[-50,-20; -30,0], rotation=90);
        Parts.SimpleBody SimpleBody2(sphereDiameter=0.5,
          m=1,
          I_11=0.04,
          I_22=0.04,
          I_33=0.04)                 annotation (extent=[-40,40; -20,60]);
        Interfaces.InsertImpulse InsertImpulse2
          annotation (extent=[-60,60; -40,40]);
        Parts.FixedTranslation FixedTranslation1(r={0,0.35,0})
          annotation (extent=[-50,66; -30,86], rotation=90);
        Joints.FreeBodyMovement FreeBodyMovement1(
          initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
          reinitByImpulse=true,
          x_start={-2,1.25,0},
          v_start={0,0,0},
          w_start=4*{0,0,-360})
                             annotation (extent=[-80,40; -60,60]);
        Contacts.CollisionSpherePlane CollisionSpherePlane1(
          ra=0.25,
          elasticity=1.0,
          contactDuration=1e-3,
          muR=0.1) annotation (extent=[-30,10; -50,30], rotation=270);
        Parts.Fixed Fixed1 annotation (extent=[-50,-40; -30,-20], rotation=90);
        inner CollisionPool collisionPool annotation (extent=[20,20; 40,40]);
      equation
        connect(InsertImpulse2.frame_b,SimpleBody2. frame_a) annotation (points=[-43,50;
              -41,50],       style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(FixedTranslation1.frame_a, SimpleBody2.frame_a) annotation (points=[-40,65;
              -41,50],         style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FreeBodyMovement1.frame_b, InsertImpulse2.frame_a) annotation (
            points=[-59,50; -57,50], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(CollisionSpherePlane1.frame_a, SimpleBody2.frame_a) annotation (
           points=[-40,31; -40,50; -41,50], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(CollisionSpherePlane1.y, InsertImpulse2.u) annotation (points=[
              -47,20; -50,20; -50,43], style(color=5, rgbcolor={255,0,255}));
        connect(InsertImpulse1.u, CollisionSpherePlane1.y) annotation (points=[
              -47,-10; -50,-10; -50,20; -47,20], style(color=5, rgbcolor={255,0,
                255}));
        connect(InsertImpulse1.frame_b, CollisionSpherePlane1.frame_b)
          annotation (points=[-40,-3; -40,9], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Fixed1.frame_b, InsertImpulse1.frame_a) annotation (points=[-40,
              -19; -40,-17], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
      end BouncingBall;

      model CP1 "modeling of mutual collisions"
                  extends Modelica.Icons.Example;
        annotation (Diagram, experiment(StopTime=10, NumberOfIntervals=2500),
      preferedView="info", Documentation(info="<html>
Five freely flying bodies are colliding due to mutual gravitional attraction.
<p>
<img src=\"../Images/CollisionPool.png\">
</p>
This example presents the collision pool. The collision pool is a tool to model all possible mutual collision between spherical objects  in a generic manner.
</html>"));
        Interfaces.InsertImpulse InsertImpulse1(CPIndeces={2})
          annotation (extent=[-40,40; -20,60]);
        Interfaces.InsertImpulse InsertImpulse2(CPIndeces={1})
          annotation (extent=[-40,100; -20,80]);
        Parts.Body Body1(
          I_11=0.04,
          I_22=0.04,
          I_33=0.04,
          CPIndex=1,
          x_start={-1,0,0},
          sphereDiameter=0.2,
          GPIndex=1,
          v_start={0,0,0},
          m=1e10,
          reinitByImpulse=false,
          enforceStates=false,
          initType=Modelica.Mechanics.MultiBody.Types.Init.Free)
               annotation (extent=[-20,80; 0,100]);
        Parts.Body Body2(
          I_11=0.04,
          I_22=0.04,
          I_33=0.04,
          CPIndex=2,
          initType=Modelica.Mechanics.MultiBody.Types.Init.Free,
          sphereDiameter=0.2,
          GPIndex=2,
          x_start={1,1,0},
          m=1e10,
          reinitByImpulse=false,
          enforceStates=false)
                              annotation (extent=[-20,40; 0,60]);
        Interfaces.InsertImpulse InsertImpulse3(CPIndeces={3})
          annotation (extent=[-38,0; -18,20]);
        Parts.Body Body3(
          I_11=0.04,
          I_22=0.04,
          I_33=0.04,
          initType=Modelica.Mechanics.MultiBody.Types.Init.Free,
          sphereDiameter=0.2,
          CPIndex=3,
          GPIndex=3,
          v_start={0,0,0},
          x_start={1.0,0.0,-0.5},
          m=1e10,
          reinitByImpulse=false)
                              annotation (extent=[-18,0; 2,20]);
        Interfaces.InsertImpulse InsertImpulse4(CPIndeces={4})
          annotation (extent=[-40,-40; -20,-20]);
        Parts.Body Body4(
          I_11=0.04,
          I_22=0.04,
          I_33=0.04,
          initType=Modelica.Mechanics.MultiBody.Types.Init.Free,
          sphereDiameter=0.2,
          CPIndex=4,
          GPIndex=4,
          x_start={0,0,1},
          m=1e10,
          reinitByImpulse=false)
                              annotation (extent=[-20,-40; 0,-20]);
        Interfaces.InsertImpulse InsertImpulse5(CPIndeces={5})
          annotation (extent=[-40,-80; -20,-60]);
        Parts.Body Body5(
          I_11=0.04,
          I_22=0.04,
          I_33=0.04,
          initType=Modelica.Mechanics.MultiBody.Types.Init.Free,
          sphereDiameter=0.2,
          v_start={0,0,0},
          CPIndex=5,
          GPIndex=5,
          x_start={0,-1,-0.8},
          m=1e10,
          reinitByImpulse=false)
                              annotation (extent=[-20,-80; 0,-60]);
        Joints.FreeTranslationalMovement FreeTranslationalMovement1(enforceStates=
              true,
          initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
          x_start={-1,0,0})
                    annotation (extent=[-60,80; -40,100]);
        Joints.FreeTranslationalMovement FreeTranslationalMovement2(enforceStates=
              true,
          initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
          x_start={1,1,0})
                    annotation (extent=[-60,40; -40,60]);
        Joints.FreeTranslationalMovement FreeTranslationalMovement3(enforceStates=
              true,
          initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
          x_start={1.0,0.0,-0.5})
                    annotation (extent=[-60,0; -40,20]);
        Joints.FreeTranslationalMovement FreeTranslationalMovement4(enforceStates=
              true,
          initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
          x_start={0,-0.2,0.8})
                    annotation (extent=[-60,-40; -40,-20]);
        Joints.FreeTranslationalMovement FreeTranslationalMovement5(enforceStates=
              true,
          initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
          x_start={0,-1,-0.8})
                    annotation (extent=[-60,-80; -40,-60]);
        inner World3D world3D(
          g=0,
          gravityPoolSize=5)   annotation (extent=[58,60; 78,80]);
        inner CollisionPool collisionPool(poolSize=5)
          annotation (extent=[60,20; 80,40]);
      equation
        connect(InsertImpulse2.frame_b, Body1.frame_a) annotation (points=[-23,90;
              -21,90],     style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(Body2.frame_a, InsertImpulse1.frame_b) annotation (points=[-21,50;
              -23,50],       style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(Body3.frame_a,InsertImpulse3. frame_b) annotation (points=[-19,10;
              -21,10],       style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(Body4.frame_a,InsertImpulse4. frame_b) annotation (points=[-21,-30;
              -23,-30],      style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(Body5.frame_a,InsertImpulse5. frame_b) annotation (points=[-21,-70;
              -23,-70],      style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(FreeTranslationalMovement1.frame_b, InsertImpulse2.frame_a)
          annotation (points=[-39,90; -37,90], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FreeTranslationalMovement2.frame_b, InsertImpulse1.frame_a)
          annotation (points=[-39,50; -37,50], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FreeTranslationalMovement3.frame_b, InsertImpulse3.frame_a)
          annotation (points=[-39,10; -35,10], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FreeTranslationalMovement4.frame_b, InsertImpulse4.frame_a)
          annotation (points=[-39,-30; -37,-30], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FreeTranslationalMovement5.frame_b, InsertImpulse5.frame_a)
          annotation (points=[-39,-70; -37,-70], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
      end CP1;

      model CP2 "modeling of mutual collisions"
                  extends Modelica.Icons.Example;
        annotation (Diagram, experiment(StopTime=10, NumberOfIntervals=2500),
      preferedView="info", Documentation(info="<html>
Five freely flying bodies are colliding due to mutual gravitional attraction.
<p>
<img src=\"../Images/CollisionPool.png\">
</p>
This example presents the collision pool. The collision pool is a tool to model all possible mutual collision between spherical objects  in a generic manner.
In constrast to the previous example, the rotation of the objects is modeled additionally.
</html>"));
        Interfaces.InsertImpulse InsertImpulse1(CPIndeces={2})
          annotation (extent=[-40,40; -20,60]);
        Interfaces.InsertImpulse InsertImpulse2(CPIndeces={1})
          annotation (extent=[-40,100; -20,80]);
        Parts.Body Body1(
          CPIndex=1,
          x_start={-1,0,0},
          sphereDiameter=0.2,
          GPIndex=1,
          v_start={0,0,0},
          m=1e10,
          reinitByImpulse=true,
          initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
          useQuaternions=false,
          enforceStates=false,
          I_11=0.04e10,
          I_22=0.04e10,
          I_33=0.04e10)
               annotation (extent=[-20,80; 0,100]);
        Parts.Body Body2(
          CPIndex=2,
          sphereDiameter=0.2,
          GPIndex=2,
          x_start={1,1,0},
          m=1e10,
          reinitByImpulse=true,
          initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
          useQuaternions=false,
          enforceStates=false,
          I_11=0.04e10,
          I_22=0.04e10,
          I_33=0.04e10)       annotation (extent=[-20,40; 0,60]);
        Interfaces.InsertImpulse InsertImpulse3(CPIndeces={3})
          annotation (extent=[-38,0; -18,20]);
        Parts.Body Body3(
          sphereDiameter=0.2,
          CPIndex=3,
          GPIndex=3,
          v_start={0,0,0},
          x_start={1.0,0.0,-0.5},
          m=1e10,
          initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
          reinitByImpulse=true,
          useQuaternions=false,
          enforceStates=false,
          I_11=0.04e10,
          I_22=0.04e10,
          I_33=0.04e10)       annotation (extent=[-18,0; 2,20]);
        Interfaces.InsertImpulse InsertImpulse4(CPIndeces={4})
          annotation (extent=[-40,-40; -20,-20]);
        Parts.Body Body4(
          sphereDiameter=0.2,
          CPIndex=4,
          GPIndex=4,
          x_start={0,0,1},
          m=1e10,
          initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
          reinitByImpulse=true,
          useQuaternions=false,
          enforceStates=false,
          I_11=0.04e10,
          I_22=0.04e10,
          I_33=0.04e10)       annotation (extent=[-20,-40; 0,-20]);
        Interfaces.InsertImpulse InsertImpulse5(CPIndeces={5})
          annotation (extent=[-40,-80; -20,-60]);
        Parts.Body Body5(
          sphereDiameter=0.2,
          v_start={0,0,0},
          CPIndex=5,
          GPIndex=5,
          x_start={0,-1,-0.8},
          m=1e10,
          initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
          reinitByImpulse=true,
          useQuaternions=false,
          enforceStates=false,
          I_11=0.04e10,
          I_22=0.04e10,
          I_33=0.04e10)       annotation (extent=[-20,-80; 0,-60]);
        inner World3D world3D(
          g=0,
          gravityPoolSize=5)   annotation (extent=[58,60; 78,80]);
        inner CollisionPool collisionPool(poolSize=5)
          annotation (extent=[60,20; 80,40]);
      equation
        connect(InsertImpulse2.frame_b, Body1.frame_a) annotation (points=[-23,90;
              -21,90],     style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(Body2.frame_a, InsertImpulse1.frame_b) annotation (points=[-21,50;
              -23,50],       style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(Body3.frame_a,InsertImpulse3. frame_b) annotation (points=[-19,10;
              -21,10],       style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(Body4.frame_a,InsertImpulse4. frame_b) annotation (points=[-21,-30;
              -23,-30],      style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(Body5.frame_a,InsertImpulse5. frame_b) annotation (points=[-21,-70;
              -23,-70],      style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
      end CP2;

      model PistonEngine "pendulum bouncing on the floor"
                  extends Modelica.Icons.Example;
        annotation (Diagram, experiment(StopTime=10, NumberOfIntervals=2500),
      preferedView="info",  Documentation(info="<html>
This example presents a the model of a single piston engine. <br>
The powering explosions are modelled as force impulses.
<p>
This example demonstrates a planar loop and the usage
of the EnergyInjection element.
<br>This element contains a non-linear (quadratic)
equation that leads to a large non-linear system.<br>
The system can rapidly be solved through Newton-iteration.
</p>
<p>
<img src=\"../Images/PistonEngine.png\">
</p>
</html>"));
        Parts.SimpleBody SimpleBody1(sphereDiameter=0.1,
          m=2,
          I_11=0.3,
          I_22=0.3,
          I_33=0.3)                  annotation (extent=[-20,60; 0,80]);
        Interfaces.InsertImpulse InsertImpulse1
          annotation (extent=[-80,60; -60,40]);
        Parts.Fixed Fixed2(r={0,0.4,0})
                           annotation (extent=[-100,40; -80,60], rotation=0);
        Joints.Revolute Revolute1(enforceStates=true,
          initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
          w_start=300)
          annotation (extent=[-60,40; -40,60]);
        Parts.FixedTranslation FixedTranslation1(r={0.1,0,0}, width=0.04)
          annotation (extent=[-20,40; 0,60]);
        Parts.Fixed Fixed1 annotation (extent=[20,-90; 40,-70], rotation=90);
        Interfaces.InsertImpulse InsertImpulse2
          annotation (extent=[20,-40; 40,-60],
                                             rotation=90);
        inner CollisionPool collisionPool
          annotation (extent=[-60,-100; -40,-80]);
        Joints.Revolute Revolute2(enforceStates=false, reinitByImpulse=false)
          annotation (extent=[20,40; 40,60], rotation=0);
        Joints.CutJoints.PlanarRevolute planarRevolute
          annotation (extent=[20,0; 40,20], rotation=90);
        Joints.Prismatic prismatic(
          n={0,1,0},
          enforceStates=false,
          reinitByImpulse=false)
          annotation (extent=[20,-40; 40,-20], rotation=90);
        Parts.SimpleBody SimpleBody2(sphereDiameter=0.1,
          m=1,
          I_11=0.03,
          I_22=0.03,
          I_33=0.03)                 annotation (extent=[60,-20; 80,0]);
        Parts.FixedTranslation FixedTranslation2(r={0,-0.25,0}, width=0.025)
          annotation (extent=[50,28; 70,48], rotation=270);
        inner Mechanics3D.World3D world3D(g=0,
          animateGravity=false,
          axisShowLabels=false,
          axisLength=0.2,
          axisDiameter=0.01)
          annotation (extent=[-98,-100; -78,-80]);
        Forces.Spring spring(s0=0.18, c=40,
          animation=false)
          annotation (extent=[40,-60; 60,-40], rotation=270);
        Contacts.EnergyInjection energyInjection2_1(n={0,1,0}, E=2)
          annotation (extent=[-20,0; 0,-20],  rotation=180);

      protected
        Modelica.Blocks.Interfaces.BooleanOutput ignition
          annotation (extent=[-94,-20; -74,0]);

      initial equation
        ignition = false;

      equation

      algorithm
        when ignition then
          ignition := false;
        end when;

        when prismatic.s > 0.07 then
          ignition :=true;
        end when;

      equation

        connect(FixedTranslation1.frame_a, Revolute1.frame_b) annotation (
            points=[-21,50; -39,50], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(InsertImpulse2.frame_b, Fixed1.frame_b) annotation (points=[30,-57;
              30,-69],      style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(SimpleBody1.frame_a, FixedTranslation1.frame_a) annotation (
            points=[-21,70; -30,70; -30,50; -21,50], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(prismatic.frame_a, InsertImpulse2.frame_a) annotation (points=[
              30,-41; 30,-43], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(InsertImpulse1.frame_a, Fixed2.frame_b) annotation (points=[-77,
              50; -79,50], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(InsertImpulse1.frame_b, Revolute1.frame_a) annotation (points=[
              -63,50; -61,50], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(SimpleBody2.frame_a, prismatic.frame_b) annotation (points=[59,-10;
              30,-10; 30,-19],      style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(planarRevolute.frame_a, prismatic.frame_b) annotation (points=[
              30,-1; 30,-19], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Revolute2.frame_a, FixedTranslation1.frame_b) annotation (
            points=[19,50; 1,50], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Revolute2.frame_b, FixedTranslation2.frame_a) annotation (
            points=[41,50; 60,50; 60,49],            style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FixedTranslation2.frame_b, planarRevolute.frame_b) annotation (
            points=[60,27; 60,26; 30,26; 30,21],        style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(energyInjection2_1.frame_a, SimpleBody2.frame_a) annotation (
            points=[1,-10; 30,-10; 30,-10; 59,-10],  style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(ignition, InsertImpulse1.u) annotation (points=[-84,-10; -70,
              -10; -70,43],
            style(color=5, rgbcolor={255,0,255}));
        connect(ignition, InsertImpulse2.u) annotation (points=[-84,-10; -70,
              -10; -70,-50; 23,-50],
                                style(color=5, rgbcolor={255,0,255}));

        connect(SimpleBody2.frame_a, spring.frame_a) annotation (points=[59,-10;
              50,-10; 50,-39], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(energyInjection2_1.u, ignition) annotation (points=[-11,-10;
              -84,-10], style(color=5, rgbcolor={255,0,255}));
        connect(Fixed1.frame_b, spring.frame_b) annotation (points=[30,-69; 30,
              -70; 50,-70; 50,-61], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            gradient=3,
            fillColor=51,
            rgbfillColor={255,255,170}));
      end PistonEngine;
    end Examples;

  end Mechanics3DwithImpulses;

  package Examples "Basic examples for MultiBond Graphs"
    model ElectricCircuit "models of an electric circuit"
      extends Modelica.Icons.Example;
      import SI = Modelica.SIunits;

      SI.Voltage Vleft_Single "voltage on the left hand side of the C-field";
      SI.Voltage Vright_Single "voltage on the right hand side of the C-field";
      SI.Voltage Vleft_Multi "voltage on the left hand side of the C-field";
      SI.Voltage Vright_Multi "voltage on the right hand side of the C-field";

    protected
      Bonds.MultiBond MultiBond1      annotation (extent=[-30,-40; -10,-20]);
      annotation (Diagram(Line(points=[-100,-10; 100,-10; 98,-10; 98,-10; 100,
                -10], style(
              color=10,
              rgbcolor={135,135,135},
              pattern=2,
              thickness=4))), experiment(StopTime=10), preferedView="info",
        Documentation(info="<html>
This example presents two models of the same electric circuit.<br>
The circuit is modeled by a single bond graph and by a multibond graph.
<p>
<img src=\"../Images/ECircuit.png\">
</p>
<p>
</html>"));
      Passive.R R1(R={30,75})
                   annotation (extent=[-10,-80; 10,-60],
                                                     rotation=270);
      BondLib.Passive.R R_right(R=75)
                           annotation (extent=[70,40; 90,60],    rotation=0);
      BondLib.Passive.C C_middle(C=0.025)
                           annotation (extent=[-10,0; 10,20], rotation=270);
      BondLib.Bonds.Bond Bond2 annotation (extent=[-30,40; -10,60]);
      BondLib.Bonds.Bond Bond3 annotation (extent=[-10,20; 10,40],  rotation=270);
      BondLib.Bonds.Bond Bond4 annotation (extent=[-50,20; -30,40], rotation=-90);
      BondLib.Bonds.Bond Bond1 annotation (extent=[-70,40; -50,60], rotation=0);
      inner Defaults MBG_defaults(n=2)
                                  annotation (extent=[-50,-80; -30,-60]);
      BondLib.Junctions.J1p3 J1p3_1
        annotation (extent=[-10,40; 10,60], rotation=0);
      BondLib.Passive.C C_left(C=0.02)
                           annotation (extent=[-50,0; -30,20], rotation=270);
      BondLib.Junctions.J0p3 J0p3_2 annotation (extent=[30,40; 50,60]);
      BondLib.Bonds.Bond Bond5 annotation (extent=[10,40; 30,60]);
      BondLib.Bonds.Bond Bond6 annotation (extent=[50,40; 70,60]);
      BondLib.Passive.C C_right(C=0.05)
                           annotation (extent=[30,0; 50,20], rotation=270);
      BondLib.Bonds.Bond Bond7 annotation (extent=[30,20; 50,40],   rotation=270);
      Bonds.MultiBond MultiBond2 annotation (extent=[10,-40; 30,-20]);
      Bonds.MultiBond MultiBond5      annotation (extent=[-10,-60; 10,-40],
          rotation=270);
      Passive.CF CF1(C=[0.045,-0.025; -0.025,0.075])
        annotation (extent=[30,-40; 50,-20]);
      BondLib.Bonds.Bond Bond8 annotation (extent=[-50,60; -30,80], rotation=90);
      BondLib.Junctions.J0p4 J0p4_1 annotation (extent=[-50,40; -30,60]);
      BondLib.Passive.R R_left(R=30)
                           annotation (extent=[-50,80; -30,100], rotation=90);
      BondLib.Sources.Sf Sf_left(f0=0.5) annotation (extent=[-70,40; -90,60]);
      Junctions.J0 J0_1 annotation (extent=[-10,-40; 10,-20]);
      Sources.Sf Sf1(f0={0.5,0}) annotation (extent=[-30,-40; -50,-20]);
    equation

       Vleft_Single = R_left.e;
       Vright_Single = R_right.e;
       Vleft_Multi = R1.e[1];
       Vright_Multi = R1.e[2];

      connect(MultiBond2.MultiBondCon2, CF1.MultiBondCon1) annotation (points=[
            30,-30; 30,-30], style(color=71, rgbcolor={85,170,255}));
      connect(C_left.BondCon1, Bond4.BondCon2) annotation (points=[-40,20; -40,
            20], style(color=8, rgbcolor={192,192,192}));
      connect(J1p3_1.BondCon2, Bond5.BondCon1) annotation (points=[10,50; 10.2,
            50], style(color=8, rgbcolor={192,192,192}));
      connect(J1p3_1.BondCon3, Bond3.BondCon1) annotation (points=[0,40; -2,40;
            -2,39.8; 1.80017e-015,39.8], style(color=8, rgbcolor={192,192,192}));
      connect(J1p3_1.BondCon1, Bond2.BondCon2) annotation (points=[-10,50; -10,
            50], style(color=8, rgbcolor={192,192,192}));
      connect(Bond3.BondCon2, C_middle.BondCon1) annotation (points=[
            -1.83691e-015,20; 1.83691e-015,20], style(color=8, rgbcolor={192,
              192,192}));
      connect(J0p3_2.BondCon1, Bond5.BondCon2) annotation (points=[30,50; 30,50],
          style(color=8, rgbcolor={192,192,192}));
      connect(J0p3_2.BondCon3, Bond7.BondCon1) annotation (points=[40,40; 38,40;
            38,39.8; 40,39.8], style(color=8, rgbcolor={192,192,192}));
      connect(J0p3_2.BondCon2, Bond6.BondCon1) annotation (points=[50,50; 50.2,
            50], style(color=8, rgbcolor={192,192,192}));
      connect(Bond6.BondCon2, R_right.BondCon1) annotation (points=[70,50; 70,
            50], style(color=8, rgbcolor={192,192,192}));
      connect(C_right.BondCon1, Bond7.BondCon2) annotation (points=[40,20; 40,
            20], style(color=8, rgbcolor={192,192,192}));
      connect(Bond8.BondCon1, J0p4_1.BondCon4) annotation (points=[-40,60.2;
            -40,60], style(color=8, rgbcolor={192,192,192}));
      connect(J0p4_1.BondCon2, Bond2.BondCon1) annotation (points=[-30,50;
            -29.8,50], style(color=8, rgbcolor={192,192,192}));
      connect(J0p4_1.BondCon3, Bond4.BondCon1) annotation (points=[-40,40; -40,
            39.8], style(color=8, rgbcolor={192,192,192}));
      connect(J0p4_1.BondCon1, Bond1.BondCon2) annotation (points=[-50,50; -50,
            50], style(color=8, rgbcolor={192,192,192}));
      connect(R_left.BondCon1, Bond8.BondCon2) annotation (points=[-40,80; -40,
            80], style(color=8, rgbcolor={192,192,192}));
      connect(Sf_left.BondCon1, Bond1.BondCon1) annotation (points=[-70,50;
            -69.8,50], style(color=8, rgbcolor={192,192,192}));
      connect(R1.MultiBondCon1, MultiBond5.MultiBondCon2) annotation (points=[
            1.83691e-015,-60; -1.83691e-015,-60], style(color=71, rgbcolor={85,
              170,255}));
      connect(J0_1.MultiBondCon1, MultiBond1.MultiBondCon2) annotation (points=
            [-10,-30; -10,-30], style(color=71, rgbcolor={85,170,255}));
      connect(J0_1.MultiBondCon3, MultiBond5.MultiBondCon1) annotation (points=[0,-40;
            1.83691e-015,-40],         style(color=71, rgbcolor={85,170,255}));
      connect(J0_1.MultiBondCon2, MultiBond2.MultiBondCon1) annotation (points=
            [10,-30; 10,-30], style(color=71, rgbcolor={85,170,255}));
      connect(Sf1.MultiBondCon1, MultiBond1.MultiBondCon1) annotation (points=[
            -30,-30; -30,-30], style(color=71, rgbcolor={85,170,255}));
    end ElectricCircuit;
  annotation (Icon(
        Rectangle(extent=[-100,-100; 80,50],   style(
            color=0,
            fillColor=30,
            fillPattern=1)),
        Polygon(points=[100,70; 100,-80; 80,-100; 80,50; 100,70],      style(
            color=0,
            fillColor=30,
            fillPattern=1)),
        Text(
          extent=[-85,71; 65,-49],
          string="Sample",
          style(color=0)),
        Text(
          extent=[-97,23; 78,-98],
          string="Programs",
          style(color=0)),
        Text(
          extent=[-112,112; 128,63],
          string="%name",
          style(color=1)),
        Polygon(points=[-100,50; -80,70; 100,70; 80,50; -100,50], style(
          color=0,
          rgbcolor={0,0,0},
          fillColor=30,
          rgbfillColor={235,235,235},
          fillPattern=1))), preferedView="info", Documentation(info="<html>
This package contains various examples.
<p>
These examples demonstrate the usage of multi bond graphs.
<p>
For all these examples the following simulation setup is proposed.
<ul>
<li>Start time: 0 seconds
<li>Stop time: 10 seconds
<li>Number of intervals: 2500
<li>Algorithm: DASSL
</ul>
</html>"));

    model PlanarPendulum "multibond graph of a planar pendulum"
      extends Modelica.Icons.Example;
      import SI = Modelica.SIunits;

      SI.Angle phi "angle of the pendulum";
      SI.Velocity vx "x-velocity of the point mass";
      SI.Velocity vy "y-velocity of the point mass";

    protected
      Junctions.J1 J1_2(n=3) annotation (extent=[0,-60; 20,-40]);
      Sources.Se gravity(n=3, e0={0,-9.81,0})
                                          annotation (extent=[-20,-60; -40,-40]);
      Passive.I mass(n=3, I={1,1,0})
                                   annotation (extent=[40,-60; 60,-40]);
      annotation (Diagram, preferedView="info", Documentation(info="<html>
This example presents the bondgraphic model of a planar pendulum
</html>"),
        experiment(StopTime=10));
      Bonds.MultiBond MultiBond6      annotation (extent=[20,-60; 40,-40]);
      Bonds.MultiBond MultiBond7      annotation (extent=[-20,-60; 0,-40]);
      Junctions.J1 J1_1(n=3) annotation (extent=[0,20; 20,40]);
      Sources.Sf Fixation(n=2, f0={0})
                                  annotation (extent=[-60,20; -80,40]);
      Sources.Se NoTorque(e0={0}, n=1)
                             annotation (extent=[-60,0; -80,20]);
      Compositions.Composition Composition1(nA=2, nB=1)
        annotation (extent=[-40,0; -20,40]);
      Bonds.MultiBond MultiBond1(n=2) annotation (extent=[-60,20; -40,40]);
      Bonds.MultiBond MultiBond2(n=1)
                                 annotation (extent=[-60,0; -40,20]);
      Bonds.MultiBond MultiBond3      annotation (extent=[-20,20; 0,40]);
      Bonds.MultiBond MultiBond4
        annotation (extent=[0,0; 20,20],   rotation=270);
      Bonds.MultiBond MultiBond5
        annotation (extent=[0,-40; 20,-20],  rotation=270);
      PlanarMechanics.AdditionalMBG.translationalTF rod(d={1,-3})
        annotation (extent=[20,-20; 0,0],   rotation=-90);
      Sensors.Dq Angle(n=3, q_start={0,0,0})
                                          annotation (extent=[40,20; 60,40]);
      Bonds.MultiBond MultiBond8      annotation (extent=[20,20; 40,40]);
      inner Defaults MBG_defaults(n=3) annotation (extent=[60,60; 80,80]);
    equation

      phi = Angle.q[3];
      vx = mass.f[1];
      vy = mass.f[2];

      connect(MultiBond7.MultiBondCon2, J1_2.MultiBondCon1) annotation (points=[0,-50; 0,
            -50],          style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond7.MultiBondCon1, gravity.MultiBondCon1)
                                                           annotation (points=[-20,-50;
            -20,-50],      style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond6.MultiBondCon2, mass.MultiBondCon1)
                                                          annotation (points=[40,-50;
            40,-50],      style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond6.MultiBondCon1, J1_2.MultiBondCon2)
        annotation (points=[20,-50; 20,-50],
                                           style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond1.MultiBondCon2, Composition1.MultiBondCon1) annotation (
          points=[-40,30; -40.2,30], style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond1.MultiBondCon1, Fixation.MultiBondCon1)
                                                           annotation (points=[-60,30;
            -60,30],     style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond2.MultiBondCon2, Composition1.MultiBondCon2) annotation (
          points=[-40,10; -40,10], style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond2.MultiBondCon1, NoTorque.MultiBondCon1)
                                                           annotation (points=[-60,10;
            -60,10],     style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond3.MultiBondCon2, J1_1.MultiBondCon1) annotation (points=[0,30; 0,
            30],         style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond3.MultiBondCon1, Composition1.MultiBondCon3) annotation (
          points=[-20,30; -20,30], style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond4.MultiBondCon1, J1_1.MultiBondCon3) annotation (points=[10,20;
            10,20],      style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond5.MultiBondCon2, J1_2.MultiBondCon4) annotation (points=[10,-40;
            10,-40],       style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond4.MultiBondCon2, rod.MultiBondCon1)              annotation (
         points=[10,0; 10,0],                     style(color=71, rgbcolor={85,170,
              255}));
      connect(rod.MultiBondCon2, MultiBond5.MultiBondCon1)              annotation (
         points=[10,-20; 10,-20],                     style(color=71, rgbcolor={85,
              170,255}));
      connect(Angle.q[3], rod.phi)                   annotation (points=[60,
            30.6667; 70,30.6667; 70,-6; 20,-6],               style(color=74,
            rgbcolor={0,0,127}));
      connect(MultiBond8.MultiBondCon2, Angle.MultiBondCon1)
        annotation (points=[40,30; 40,30], style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond8.MultiBondCon1, J1_1.MultiBondCon2)
        annotation (points=[20,30; 20,30],
                                         style(color=71, rgbcolor={85,170,255}));
    end PlanarPendulum;

    model CraneCrab1 "multibond graph of a free crane crab"
      extends Modelica.Icons.Example;
      import SI = Modelica.SIunits;

      SI.Position x1 "x-position of the crab";
      SI.Position x2 "x-position of the pendulum";
      SI.Position y2 "y-position of the pendulum";
      SI.Angle phi2 "angle of the pendulum";

    protected
      Junctions.J1 J1_2(n=3) annotation (extent=[-60,-20; -40,0]);
      Sources.Se gravity1(n=3, e0={0,-9.81,0})
                                          annotation (extent=[-40,-40; -60,-60],
          rotation=90);
      Passive.I mass1(n=3, I={1,1,1})
                                   annotation (extent=[-60,20; -40,40],
                                                                     rotation=-270);
      annotation (Diagram, Coordsys(extent=[-200,-140; 120,140]),
        Icon,
        experiment(StopTime=10), preferedView="info",
        Documentation(info="<html>
This example presents the multibond graph of a free crane crab.
A second implementation of this example is provided in <br><a href=\"Modelica://MultiBondLib.Examples.CraneCrab2\">MultiBondLib.Examples.CraneCrab2</a>.
<p>
<img src=\"../Images/CraneCrabSketch.png\">
</p>
<p>
</html>"));
      Bonds.MultiBond MultiBond6(n=3) annotation (extent=[-60,0; -40,20],
                                                                       rotation=90);
      Bonds.MultiBond MultiBond7(n=3) annotation (extent=[-60,-40; -40,-20],
                                                                           rotation=
           90);
      Sources.Sf Wall(f0={0}, n=3)
                                  annotation (extent=[-160,-20; -180,0]);
      PlanarMechanics.AdditionalMBG.translationalTF translationalTF1(d={1,0})
        annotation (extent=[-140,0; -120,-20]);
      Sources.Se Prismatic(n=1, e0={0})
                                  annotation (extent=[-80,120; -100,100],rotation=
            -90);
      Junctions.J1 J1_3(n=1) annotation (extent=[-100,60; -80,80]);
      Bonds.MultiBond MultiBond2(n=1) annotation (extent=[-100,80; -80,100],
          rotation=-90);
      Bonds.MultiBond MultiBond3(n=1) annotation (extent=[-100,40; -80,60],rotation=
           -90);
      PlanarMechanics.AdditionalMBG.prismaticTF prismaticTF1(d={1,0})
        annotation (extent=[-100,20; -80,40],rotation=-90);
      Junctions.J0Partial J0Partial1(
        n=3,
        nPartial=2,
        order={1,2,3}) annotation (extent=[-100,-20; -80,0]);
      Bonds.MultiBond MultiBond4      annotation (extent=[-120,-20; -100,0]);
      Bonds.MultiBond MultiBond5      annotation (extent=[-80,-20; -60,0]);
      Bonds.MultiBond MultiBond8(n=2) annotation (extent=[-100,0; -80,20],
                                                                        rotation=
            -90);
      Sensors.Dq JointLength(n=1, q_start={0},
        f(stateSelect=StateSelect.always))
                                          annotation (extent=[-140,80; -120,60],
          rotation=-180);
      Bonds.MultiBond MultiBond9      annotation (extent=[-160,-20; -140,0]);
      Bonds.MultiBond MultiBond10     annotation (extent=[-40,-20; -20,0]);
      Junctions.J0Partial J0Partial2(
        n=3,
        nPartial=1,
        order={3,1,2}) annotation (extent=[-20,-20; 0,0]);
      Sources.Se revolute(n=1, e0={0})
                                  annotation (extent=[0,80; -20,60], rotation=-90);
      Bonds.MultiBond MultiBond11(n=1)
                                      annotation (extent=[-20,0; 0,20], rotation=
            -90);
      Bonds.MultiBond MultiBond12     annotation (extent=[0,-20; 20,0]);
      PlanarMechanics.AdditionalMBG.translationalTF rod(d={1,-3})
        annotation (extent=[20,-20; 40,0]);
      Bonds.MultiBond MultiBond14     annotation (extent=[40,-20; 60,0]);
      Junctions.J1 J1_5(n=3) annotation (extent=[60,-20; 80,0]);
      Passive.I mass2(n=3, I={1,1,0})
                                   annotation (extent=[60,20; 80,40],   rotation=
            -270);
      Bonds.MultiBond MultiBond15     annotation (extent=[60,0; 80,20],   rotation=
            90);
      Sources.Se gravity2(n=3, e0={0,-9.81,0})
                                          annotation (extent=[80,-40; 60,-60],
          rotation=90);
      Bonds.MultiBond MultiBond16     annotation (extent=[60,-40; 80,-20], rotation=
           90);
      PlanarMechanics.AdditionalMBG.Translation Translation1(d={1,0})
        annotation (extent=[-128,-100; -108,-80]);
      PlanarMechanics.AdditionalMBG.Translation Translation2(d={1,-3})
        annotation (extent=[40,-100; 60,-80]);
      Modelica.Blocks.Sources.Constant Constant1[3](k={0,0,0})
        annotation (extent=[-180,-100; -160,-80]);
      Junctions.J1 J1_6(n=1) annotation (extent=[-20,20; 0,40]);
      Bonds.MultiBond MultiBond17(n=1)
                                      annotation (extent=[-20,40; 0,60], rotation=
            -90);
      Sensors.Dq revoluteAngle(n=1, q_start={0},
        q(stateSelect=StateSelect.always),
        f(stateSelect=StateSelect.always))
                                          annotation (extent=[40,40; 20,20],
          rotation=-180);
      Bonds.MultiBond MultiBond13(
                                 n=1) annotation (extent=[-120,80; -100,60],
          rotation=180);
      Bonds.MultiBond MultiBond18(
                                 n=1) annotation (extent=[0,20; 20,40],
          rotation=0);
      inner Defaults MBG_defaults(n=3) annotation (extent=[-180,80; -160,100]);
      PlanarMechanics.AdditionalMBG.Translation Translation3(d={1,0})
        annotation (extent=[0,-100; 20,-80]);
      Interfaces.RealSignal q1[3] annotation (extent=[69,-91; 71,-89]);
    equation
      x1 = JointLength.q[1];
      {x2,y2,phi2} = q1;

      connect(MultiBond7.MultiBondCon1, gravity1.MultiBondCon1)
                                                           annotation (points=[-50,-40;
            -50,-40],      style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond6.MultiBondCon2, mass1.MultiBondCon1)
                                                          annotation (points=[-50,20;
            -50,20],      style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond2.MultiBondCon1, Prismatic.MultiBondCon1)
                                                           annotation (points=[-90,100;
            -90,100],    style(color=71, rgbcolor={85,170,255}));
      connect(prismaticTF1.MultiBondConA, MultiBond3.MultiBondCon2)
        annotation (points=[-90,40; -90,40],
                                         style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond4.MultiBondCon1, translationalTF1.MultiBondCon2)
        annotation (points=[-120,-10; -120,-10],
                                           style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond4.MultiBondCon2, J0Partial1.MultiBondCon1) annotation (
          points=[-100,-10; -100,-10],
                                   style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond5.MultiBondCon1, J0Partial1.MultiBondCon2) annotation (
          points=[-80,-10; -80,-9.9],style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond5.MultiBondCon2, J1_2.MultiBondCon1) annotation (points=[-60,-10;
            -60,-10],     style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond8.MultiBondCon2, J0Partial1.MultiBondCon3)
        annotation (points=[-90,0; -90,0], style(color=71, rgbcolor={85,170,255}));
      connect(prismaticTF1.MultiBondConB, MultiBond8.MultiBondCon1) annotation (
          points=[-90,20; -90,20],      style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond7.MultiBondCon2, J1_2.MultiBondCon3) annotation (points=[-50,-20;
            -50,-20],     style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond9.MultiBondCon2, translationalTF1.MultiBondCon1) annotation (
         points=[-140,-10; -140,-10],
                                    style(color=71, rgbcolor={85,170,255}));
      connect(J1_3.MultiBondCon3, MultiBond3.MultiBondCon1) annotation (points=[-90,60;
            -90,60],     style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond2.MultiBondCon2, J1_3.MultiBondCon4) annotation (points=[-90,80;
            -90,80],     style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond6.MultiBondCon1, J1_2.MultiBondCon4)
        annotation (points=[-50,0; -50,0],
                                         style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond10.MultiBondCon1, J1_2.MultiBondCon2) annotation (points=[-40,-10;
            -40,-10],     style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond10.MultiBondCon2, J0Partial2.MultiBondCon1) annotation (
          points=[-20,-10; -20,-10],
                                   style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond11.MultiBondCon2, J0Partial2.MultiBondCon3)
        annotation (points=[-10,0; -10,0],
                                         style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond12.MultiBondCon1, J0Partial2.MultiBondCon2) annotation (
          points=[0,-10; 0,-9.9],   style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond14.MultiBondCon1, rod.MultiBondCon2)
        annotation (points=[40,-10; 40,-10],   style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond14.MultiBondCon2, J1_5.MultiBondCon1) annotation (points=[60,-10;
            60,-10],           style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond15.MultiBondCon1, J1_5.MultiBondCon4)
        annotation (points=[70,0; 70,0],   style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond15.MultiBondCon2, mass2.MultiBondCon1)
                                                           annotation (points=[70,20;
            70,20],      style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond16.MultiBondCon2, J1_5.MultiBondCon3) annotation (points=[70,-20;
            70,-20],           style(color=71, rgbcolor={85,170,255}));
      connect(gravity2.MultiBondCon1, MultiBond16.MultiBondCon1)
                                                            annotation (points=[70,-40;
            70,-40],       style(color=71, rgbcolor={85,170,255}));
      connect(J1_6.MultiBondCon3, MultiBond11.MultiBondCon1)
        annotation (points=[-10,20; -10,20],
                                           style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond17.MultiBondCon2, J1_6.MultiBondCon4)
        annotation (points=[-10,40; -10,40],
                                           style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond17.MultiBondCon1, revolute.MultiBondCon1)
        annotation (points=[-10,60; -10,60],
                                           style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond12.MultiBondCon2, rod.MultiBondCon1)
        annotation (points=[20,-10; 20,-10], style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond13.MultiBondCon2, JointLength.MultiBondCon1)
                                                            annotation (points=[-120,70;
            -120,70],    style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond13.MultiBondCon1, J1_3.MultiBondCon1) annotation (points=[-100,70;
            -100,70],        style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond18.MultiBondCon1, J1_6.MultiBondCon2)
        annotation (points=[0,30; 0,30],   style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond18.MultiBondCon2, revoluteAngle.MultiBondCon1)
        annotation (points=[20,30; 20,30], style(color=71, rgbcolor={85,170,255}));
      connect(prismaticTF1.phi, Constant1[3].y) annotation (points=[-100,30; -150,30;
            -150,-90; -159,-90], style(color=3, rgbcolor={0,0,255}));
      connect(Translation1.q1, Constant1.y) annotation (points=[-128,-90; -159,
            -90], style(color=3, rgbcolor={0,0,255}));
      connect(JointLength.q[1], Translation1.ampl) annotation (points=[-140,70;
            -146,70; -146,58; -114,58; -114,-80], style(color=3, rgbcolor={0,0,
              255}));
      connect(translationalTF1.phi, Constant1[3].y) annotation (points=[-134,0;
            -134,30; -150,30; -150,-90; -159,-90], style(color=3, rgbcolor={0,0,
              255}));
      connect(translationalTF1.ampl, JointLength.q[1]) annotation (points=[-126,0;
            -114,0; -114,58; -146,58; -146,70; -140,70],    style(color=3,
            rgbcolor={0,0,255}));
      connect(Translation1.q2, Translation3.q1) annotation (points=[-108,-90; 0,
            -90], style(color=3, rgbcolor={0,0,255}));
      connect(revoluteAngle.q[1], Translation3.phi) annotation (points=[40,30;
            48,30; 48,10; 6,10; 6,-80], style(color=3, rgbcolor={0,0,255}));
      connect(Translation3.q2, Translation2.q1) annotation (points=[20,-90; 40,
            -90], style(color=3, rgbcolor={0,0,255}));
      connect(rod.phi, Translation3.q2[3]) annotation (points=[26,-20; 26,-90;
            20,-90; 20,-89.3333], style(color=3, rgbcolor={0,0,255}));
      connect(Wall.MultiBondCon1, MultiBond9.MultiBondCon1) annotation (points=
            [-160,-10; -160,-10], style(color=71, rgbcolor={85,170,255}));
      connect(Translation2.q2, q1) annotation (points=[60,-90; 70,-90], style(
            color=3, rgbcolor={0,0,255}));
    end CraneCrab1;

    model CraneCrab2 "multibond graph of a free crane crab"
       extends Modelica.Icons.Example;
      import SI = Modelica.SIunits;

      SI.Position x1 "x-position of the crab";
      SI.Position x2 "x-position of the pendulum";
      SI.Position y2 "y-position of the pendulum";
      SI.Angle phi2 "angle of the pendulum";

    protected
      Junctions.J1 J1_2(n=3) annotation (extent=[60,-20; 80,0]);
      Sources.Se gravity1(n=3, e0={0,-9.81,0})
                                          annotation (extent=[80,-40; 60,-60],
          rotation=90);
      Passive.I mass1(n=3, I={1,1,1})
                                   annotation (extent=[60,20; 80,40], rotation=-270);
      annotation (Diagram(
          Rectangle(extent=[92,126; 206,-114], style(
              color=9,
              rgbcolor={175,175,175},
              thickness=4)),
          Rectangle(extent=[292,126; 326,-114], style(
              color=9,
              rgbcolor={175,175,175},
              thickness=4)),
          Rectangle(extent=[214,126; 286,-114], style(
              color=9,
              rgbcolor={175,175,175},
              thickness=4)),
          Rectangle(extent=[-188,126; -114,-114], style(
              color=9,
              rgbcolor={175,175,175},
              thickness=4)),
          Rectangle(extent=[-106,126; 46,-114], style(
              color=9,
              rgbcolor={175,175,175},
              thickness=4)),
          Rectangle(extent=[52,126; 86,-114], style(
              color=9,
              rgbcolor={175,175,175},
              thickness=4)),
          Text(
            extent=[-180,-120; -120,-140],
            string="Wall",
            style(
              color=10,
              rgbcolor={95,95,95},
              thickness=4,
              fillPattern=1)),
          Text(
            extent=[-100,-120; 40,-140],
            style(
              color=10,
              rgbcolor={95,95,95},
              thickness=4,
              fillPattern=1),
            string="Prismatic Joint"),
          Text(
            extent=[116,-122; 176,-142],
            style(
              color=10,
              rgbcolor={95,95,95},
              thickness=4,
              fillPattern=1),
            string="Revolute"),
          Text(
            extent=[30,-120; 100,-140],
            style(
              color=10,
              rgbcolor={95,95,95},
              thickness=4,
              fillPattern=1),
            string="Body"),
          Text(
            extent=[278,-120; 348,-140],
            style(
              color=10,
              rgbcolor={95,95,95},
              thickness=4,
              fillPattern=1),
            string="Body"),
          Text(
            extent=[194,-122; 290,-142],
            style(
              color=10,
              rgbcolor={95,95,95},
              thickness=4,
              fillPattern=1),
            string="Translation")),
                           Coordsys(extent=[-200,-180; 360,140]),
        Icon, preferedView="info",
        Documentation(info="<html>
This example presents the multibond graph of a free crane crab.
The mechanic system is separated into meaningful subparts that are marked by rectangular frames.
This example shows the first step of the wrapping process.
The resulting wrapped models are presented in <br><a href=\"Modelica://MultiBondLib.PlanarMechanics.Examples.CraneCrab3\">PlanarMechanics.Examples.CraneCrab3</a>.
<p>
<img src=\"../Images/CraneCrabSketch.png\">
</p>
<p>
</html>"),
        experiment(StopTime=10));
      Bonds.MultiBond MultiBond6      annotation (extent=[60,0; 80,20], rotation=90);
      Bonds.MultiBond MultiBond7      annotation (extent=[60,-40; 80,-20], rotation=
           90);
      Junctions.J1 J1_1(n=3) annotation (extent=[-140,-20; -120,0]);
      Sources.Sf Wall(f0={0}, n=3)
                                  annotation (extent=[-160,-20; -180,0]);
      Bonds.MultiBond MultiBond1      annotation (extent=[-160,-20; -140,0]);
      PlanarMechanics.AdditionalMBG.translationalTF translationalTF1( d={1,0})
        annotation (extent=[-60,-2; -40,-22]);
      Sources.Se Prismatic(n=1, e0={0})
                                  annotation (extent=[0,120; -20,100], rotation=-90);
      Junctions.J1 J1_3(n=1) annotation (extent=[-20,60; 0,80]);
      Bonds.MultiBond MultiBond2(n=1) annotation (extent=[-20,80; 0,100], rotation=
            -90);
      Bonds.MultiBond MultiBond3(n=1) annotation (extent=[-20,40; 0,60], rotation=
            -90);
      PlanarMechanics.AdditionalMBG.prismaticTF prismaticTF1(d={1,0})
        annotation (extent=[-20,20; 0,40], rotation=-90);
      Junctions.J0Partial J0Partial1(
        n=3,
        nPartial=2,
        order={1,2,3}) annotation (extent=[-20,-20; 0,0]);
      Bonds.MultiBond MultiBond4      annotation (extent=[-40,-20; -20,0]);
      Bonds.MultiBond MultiBond5      annotation (extent=[0,-20; 20,0]);
      Bonds.MultiBond MultiBond8(n=2) annotation (extent=[-20,0; 0,20], rotation=
            -90);
      Sensors.Dq JointLength(n=1, q_start={0},
        f(stateSelect=StateSelect.always))
                                          annotation (extent=[-60,80; -40,60],
          rotation=-180);
      Bonds.MultiBond MultiBond9      annotation (extent=[-80,-20; -60,0]);
      Bonds.MultiBond MultiBond10     annotation (extent=[80,-20; 100,0]);
      Junctions.J0Partial J0Partial2(
        n=3,
        nPartial=1,
        order={3,1,2}) annotation (extent=[140,-20; 160,0]);
      Sources.Se Revolute(n=1, e0={0})
                                  annotation (extent=[160,80; 140,60], rotation=-90);
      Bonds.MultiBond MultiBond11(n=1)
                                      annotation (extent=[140,0; 160,20], rotation=
            -90);
      Bonds.MultiBond MultiBond12     annotation (extent=[160,-20; 180,0]);
      PlanarMechanics.AdditionalMBG.translationalTF translationalTF2(d={1,-3})
        annotation (extent=[220,-20; 240,0]);
      Bonds.MultiBond MultiBond14     annotation (extent=[240,-20; 260,0]);
      Junctions.J1 J1_5(n=3) annotation (extent=[300,-20; 320,0]);
      Passive.I mass2(n=3, I={1,1,0})
                                   annotation (extent=[300,20; 320,40], rotation=
            -270);
      Bonds.MultiBond MultiBond15     annotation (extent=[300,0; 320,20], rotation=
            90);
      Sources.Se gravity2(n=3, e0={0,-9.81,0})
                                          annotation (extent=[320,-40; 300,-60],
          rotation=90);
      Bonds.MultiBond MultiBond16     annotation (extent=[300,-40; 320,-20],
                                                                           rotation=
           90);
      PlanarMechanics.AdditionalMBG.Translation Translation1(d={1,0})
        annotation (extent=[-60,-100; -40,-80]);
      PlanarMechanics.AdditionalMBG.Translation Translation2(d={1,-3})
        annotation (extent=[242,-100; 262,-80]);
      Modelica.Blocks.Sources.Constant Constant1[3](k={0,0,0})
        annotation (extent=[-180,-100; -160,-80]);
      Junctions.J1 J1_6(n=1) annotation (extent=[140,20; 160,40]);
      Bonds.MultiBond MultiBond17(n=1)
                                      annotation (extent=[140,40; 160,60], rotation=
           -90);
      Sensors.Dq RevoluteAngle(n=1, q_start={0},
        f(stateSelect=StateSelect.always))
                                          annotation (extent=[100,40; 120,20],
          rotation=-180);
      Junctions.J1 J1_4(n=3) annotation (extent=[-100,-20; -80,0]);
      Bonds.MultiBond MultiBond13     annotation (extent=[-120,-20; -100,0]);
      Junctions.J1 J1_7(n=3) annotation (extent=[20,-20; 40,0]);
      Bonds.MultiBond MultiBond18     annotation (extent=[40,-20; 60,0]);
      Junctions.J1 J1_8(n=3) annotation (extent=[100,-20; 120,0]);
      Bonds.MultiBond MultiBond19     annotation (extent=[120,-20; 140,0]);
      Junctions.J1 J1_9(n=3) annotation (extent=[260,-20; 280,0]);
      Bonds.MultiBond MultiBond20     annotation (extent=[280,-20; 300,0]);
      Junctions.J1 J1_10(n=3)
                             annotation (extent=[180,-20; 200,0]);
      Bonds.MultiBond MultiBond21     annotation (extent=[200,-20; 220,0]);
      Bonds.MultiBond MultiBond22(
                                 n=1) annotation (extent=[-20,60; -40,80],rotation=0);
      Bonds.MultiBond MultiBond23(
                                 n=1) annotation (extent=[140,20; 120,40],rotation=0);
      inner Defaults MBG_defaults(n=3) annotation (extent=[-182,100; -162,120]);
      PlanarMechanics.AdditionalMBG.Translation Translation3(d={1,-3})
        annotation (extent=[120,-100; 140,-80]);
    protected
      Interfaces.RealSignal q1[3] annotation (extent=[307,-91; 309,-89]);
    equation

      x1 = JointLength.q[1];
      {x2,y2,phi2} = q1;

      connect(MultiBond7.MultiBondCon1, gravity1.MultiBondCon1)
                                                           annotation (points=[70,-40;
            70,-40],       style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond6.MultiBondCon2, mass1.MultiBondCon1)
                                                          annotation (points=[70,20;
            70,20],       style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond1.MultiBondCon1, Wall.MultiBondCon1)
                                                           annotation (points=[-160,-10;
            -160,-10],   style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond1.MultiBondCon2, J1_1.MultiBondCon1) annotation (points=[-140,-10;
            -140,-10],     style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond2.MultiBondCon1, Prismatic.MultiBondCon1)
                                                           annotation (points=[-10,100;
            -10,100],    style(color=71, rgbcolor={85,170,255}));
      connect(prismaticTF1.MultiBondConA, MultiBond3.MultiBondCon2)
        annotation (points=[-10,40; -10,40],
                                         style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond4.MultiBondCon1, translationalTF1.MultiBondCon2)
        annotation (points=[-40,-10; -40,-12],
                                           style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond4.MultiBondCon2, J0Partial1.MultiBondCon1) annotation (
          points=[-20,-10; -20,-10],
                                   style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond5.MultiBondCon1, J0Partial1.MultiBondCon2) annotation (
          points=[0,-10; 0,-9.9],    style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond8.MultiBondCon2, J0Partial1.MultiBondCon3)
        annotation (points=[-10,0; -10,0], style(color=71, rgbcolor={85,170,255}));
      connect(prismaticTF1.MultiBondConB, MultiBond8.MultiBondCon1) annotation (
          points=[-10,20; -10,20],      style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond7.MultiBondCon2, J1_2.MultiBondCon3) annotation (points=[70,-20;
            70,-20],      style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond9.MultiBondCon2, translationalTF1.MultiBondCon1) annotation (
         points=[-60,-10; -60,-12], style(color=71, rgbcolor={85,170,255}));
      connect(J1_3.MultiBondCon3, MultiBond3.MultiBondCon1) annotation (points=[-10,
            60; -10,60], style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond2.MultiBondCon2, J1_3.MultiBondCon4) annotation (points=[-10,
            80; -10,80], style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond6.MultiBondCon1, J1_2.MultiBondCon4)
        annotation (points=[70,0; 70,0], style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond10.MultiBondCon1, J1_2.MultiBondCon2) annotation (points=[80,
            -10; 80,-10], style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond11.MultiBondCon2, J0Partial2.MultiBondCon3)
        annotation (points=[150,0; 150,0], style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond12.MultiBondCon1, J0Partial2.MultiBondCon2) annotation (
          points=[160,-10; 160,-9.9], style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond14.MultiBondCon1, translationalTF2.MultiBondCon2)
        annotation (points=[240,-10; 240,-10], style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond15.MultiBondCon1, J1_5.MultiBondCon4)
        annotation (points=[310,0; 310,0], style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond15.MultiBondCon2, mass2.MultiBondCon1)
                                                           annotation (points=[310,
            20; 310,20], style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond16.MultiBondCon2, J1_5.MultiBondCon3) annotation (points=[
            310,-20; 310,-20], style(color=71, rgbcolor={85,170,255}));
      connect(gravity2.MultiBondCon1, MultiBond16.MultiBondCon1)
                                                            annotation (points=[310,
            -40; 310,-40], style(color=71, rgbcolor={85,170,255}));
      connect(J1_6.MultiBondCon3, MultiBond11.MultiBondCon1) annotation (points=[
            150,20; 150,20], style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond17.MultiBondCon2, J1_6.MultiBondCon4) annotation (points=[
            150,40; 150,40], style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond17.MultiBondCon1, Revolute.MultiBondCon1)
                                                            annotation (points=[150,
            60; 150,60], style(color=71, rgbcolor={85,170,255}));
      connect(J1_4.MultiBondCon2, MultiBond9.MultiBondCon1) annotation (points=[-80,
            -10; -80,-10], style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond13.MultiBondCon2, J1_4.MultiBondCon1) annotation (points=[
            -100,-10; -100,-10], style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond13.MultiBondCon1, J1_1.MultiBondCon2) annotation (points=[
            -120,-10; -120,-10], style(color=71, rgbcolor={85,170,255}));
      connect(J1_7.MultiBondCon1, MultiBond5.MultiBondCon2) annotation (points=[20,
            -10; 20,-10], style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond18.MultiBondCon1, J1_7.MultiBondCon2) annotation (points=[40,
            -10; 40,-10], style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond18.MultiBondCon2, J1_2.MultiBondCon1) annotation (points=[60,
            -10; 60,-10], style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond19.MultiBondCon1, J1_8.MultiBondCon2) annotation (points=[
            120,-10; 120,-10], style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond19.MultiBondCon2, J0Partial2.MultiBondCon1) annotation (
          points=[140,-10; 140,-10], style(color=71, rgbcolor={85,170,255}));
      connect(J1_8.MultiBondCon1, MultiBond10.MultiBondCon2) annotation (points=[
            100,-10; 100,-10], style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond20.MultiBondCon1, J1_9.MultiBondCon2) annotation (points=[
            280,-10; 280,-10], style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond20.MultiBondCon2, J1_5.MultiBondCon1) annotation (points=[
            300,-10; 300,-10], style(color=71, rgbcolor={85,170,255}));
      connect(J1_9.MultiBondCon1, MultiBond14.MultiBondCon2) annotation (points=[
            260,-10; 260,-10], style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond21.MultiBondCon1, J1_10.MultiBondCon2) annotation (points=[
            200,-10; 200,-10], style(color=71, rgbcolor={85,170,255}));
      connect(J1_10.MultiBondCon1, MultiBond12.MultiBondCon2) annotation (points=[
            180,-10; 180,-10], style(
          color=71,
          rgbcolor={85,170,255},
          fillPattern=1));
      connect(MultiBond21.MultiBondCon2, translationalTF2.MultiBondCon1)
        annotation (points=[220,-10; 220,-10], style(
          color=71,
          rgbcolor={85,170,255},
          fillPattern=1));
      connect(MultiBond22.MultiBondCon1, J1_3.MultiBondCon1) annotation (points=[
            -20,70; -20,70], style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond22.MultiBondCon2, JointLength.MultiBondCon1)
                                                            annotation (points=[-40,
            70; -40,70], style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond23.MultiBondCon1, J1_6.MultiBondCon1) annotation (points=[
            140,30; 140,30], style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond23.MultiBondCon2, RevoluteAngle.MultiBondCon1)
                                                            annotation (points=[120,
            30; 120,30], style(color=71, rgbcolor={85,170,255}));
      connect(RevoluteAngle.q[1], Translation3.phi) annotation (points=[100,30;
            100,-72; 126,-72; 126,-80], style(color=3, rgbcolor={0,0,255}));
      connect(Translation3.q2, Translation2.q1) annotation (points=[140,-90;
            242,-90], style(color=3, rgbcolor={0,0,255}));
      connect(Translation2.q2, q1) annotation (points=[262,-90; 308,-90], style(
            color=3, rgbcolor={0,0,255}));
      connect(Translation2.q1[3], translationalTF2.phi) annotation (points=[242,
            -89.3333; 242,-90; 226,-90; 226,-20], style(color=3, rgbcolor={0,0,
              255}));
      connect(Translation1.q2, Translation3.q1) annotation (points=[-40,-90;
            120,-90], style(color=3, rgbcolor={0,0,255}));
      connect(Translation1.q1, Constant1.y) annotation (points=[-60,-90; -159,
            -90], style(color=3, rgbcolor={0,0,255}));
      connect(prismaticTF1.phi, Constant1[3].y) annotation (points=[-20,30; -76,
            30; -76,-90; -159,-90], style(color=3, rgbcolor={0,0,255}));
      connect(translationalTF1.phi, Constant1[3].y) annotation (points=[-54,-2;
            -54,30; -76,30; -76,-90; -159,-90], style(color=3, rgbcolor={0,0,
              255}));
      connect(JointLength.q[1], Translation1.ampl) annotation (points=[-60,70;
            -70,70; -70,52; -36,52; -36,-80; -46,-80], style(color=3, rgbcolor=
              {0,0,255}));
      connect(JointLength.q[1], translationalTF1.ampl) annotation (points=[-60,
            70; -70,70; -70,52; -36,52; -36,-2; -46,-2], style(color=3,
            rgbcolor={0,0,255}));
    end CraneCrab2;

  end Examples;

end MultiBondLib;
